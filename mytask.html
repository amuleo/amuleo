<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø²ÛŒ ØªØ³Ú© | Ù¾Ù„ØªÙØ±Ù… Ø¢Ù†Ù„Ø§ÛŒÙ† Ø§Ù†Ø¬Ø§Ù… ÙˆØ¸Ø§ÛŒÙ</title>
    <meta name="description" content="Ø²ÛŒ ØªØ³Ú©: Ù¾Ù„ØªÙØ±Ù… Ù…Ø¯ÛŒØ±ÛŒØª ÙˆØ¸Ø§ÛŒÙ Ú¯ÛŒÙ…ÛŒÙØ§ÛŒ Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø§ÙØ²Ø§ÛŒØ´ Ø§Ù†Ú¯ÛŒØ²Ù‡ Ùˆ Ø¨Ù‡Ø±Ù‡â€ŒÙˆØ±ÛŒ. ÙˆØ¸Ø§ÛŒÙ Ø®ÙˆØ¯ Ø±Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù†ÛŒØ¯ØŒ Ø²ÛŒ Ù¾ÙˆÛŒÙ†Øª Ú©Ø³Ø¨ Ú©Ù†ÛŒØ¯ Ùˆ Ø¨Ù‡ Ø³Ø·ÙˆØ­ Ø¨Ø§Ù„Ø§ØªØ± Ø¨Ø±Ø³ÛŒØ¯.">
    <meta name="keywords" content="Ù…Ø¯ÛŒØ±ÛŒØª ÙˆØ¸Ø§ÛŒÙ, Ú¯ÛŒÙ…ÛŒÙÛŒÚ©ÛŒØ´Ù†, Ø²ÛŒ ØªØ³Ú©, Z-Point, Ø¨Ù‡Ø±Ù‡â€ŒÙˆØ±ÛŒ, Ø³Ø§Ø²Ù…Ø§Ù†Ø¯Ù‡ÛŒ, Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø±ÛŒØ²ÛŒ, Ø§Ù†Ú¯ÛŒØ²Ù‡, ÙˆØ¸Ø§ÛŒÙ Ø±ÙˆØ²Ø§Ù†Ù‡">
    <!-- Ø§Ú¯Ø± Ù‡Ø¯Ù Ø§ÛŒÙ† Ø§Ø³Øª Ú©Ù‡ Ø¨Ø±Ù†Ø§Ù…Ù‡ ØªÙˆØ³Ø· Ù…ÙˆØªÙˆØ±Ù‡Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ù‚Ø§Ø¨Ù„ Ú©Ø´Ù Ø¨Ø§Ø´Ø¯ØŒ
         Ø§ÛŒÙ† Ù…ØªØ§ØªÚ¯ Ø¨Ø§ÛŒØ¯ Ø­Ø°Ù Ø´ÙˆØ¯ ÛŒØ§ Ø¨Ù‡ "index, follow" ØªØºÛŒÛŒØ± ÛŒØ§Ø¨Ø¯.
         Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø±ØŒ Ø§Ø² Ø§ÛŒÙ†Ø¯Ú©Ø³ Ø´Ø¯Ù† ØµÙØ­Ù‡ ØªÙˆØ³Ø· Ù…ÙˆØªÙˆØ±Ù‡Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ù…ÛŒâ€ŒÚ©Ù†Ø¯. -->
    <meta name="robots" content="noindex, nofollow">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* CSS Variables for Dynamic Theming */
        :root {
            --theme-primary: #3b82f6; /* Ø±Ù†Ú¯ Ø§ØµÙ„ÛŒ ØªÙ… */
            --theme-secondary: #60a5fa; /* Ø±Ù†Ú¯ Ø«Ø§Ù†ÙˆÛŒÙ‡ ØªÙ… Ø¨Ø±Ø§ÛŒ Ù‡Ø§ÙˆØ±/Ø§Ú©Ø³Ù†Øª */
            --theme-accent-bg: #eff6ff; /* Ø±Ù†Ú¯ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø¨Ø®Ø´ Ø§Ú©Ø³Ù†Øª (Ø§ÙØ²ÙˆØ¯Ù† ÙˆØ¸ÛŒÙÙ‡) */
            --theme-accent-text: #1e40af; /* Ø±Ù†Ú¯ Ù…ØªÙ† Ø¨Ø®Ø´ Ø§Ú©Ø³Ù†Øª (Ø§ÙØ²ÙˆØ¯Ù† ÙˆØ¸ÛŒÙÙ‡) */
            --theme-progress-from: #3b82f6; /* Ø±Ù†Ú¯ Ø´Ø±ÙˆØ¹ Ú¯Ø±Ø§Ø¯ÛŒØ§Ù† Ù†ÙˆØ§Ø± Ù¾ÛŒØ´Ø±ÙØª */
            --theme-progress-to: #8b5cf6; /* Ø±Ù†Ú¯ Ù¾Ø§ÛŒØ§Ù† Ú¯Ø±Ø§Ø¯ÛŒØ§Ù† Ù†ÙˆØ§Ø± Ù¾ÛŒØ´Ø±ÙØª */
            --drag-border-color: #3b82f6; /* Ø±Ù†Ú¯ Ø­Ø§Ø´ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ú©Ø´ÛŒØ¯Ù† Ùˆ Ø±Ù‡Ø§ Ú©Ø±Ø¯Ù† */
            --drag-border-color-rgb: 59, 130, 246; /* Ù†Ø³Ø®Ù‡ RGB Ø±Ù†Ú¯ Ø­Ø§Ø´ÛŒÙ‡ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¯Ø± rgba() */
            --theme-input-border: #93c5fd; /* Ø±Ù†Ú¯ Ø­Ø§Ø´ÛŒÙ‡ ÙˆØ±ÙˆØ¯ÛŒâ€ŒÙ‡Ø§ */
            --theme-input-focus-ring: #60a5fa; /* Ø±Ù†Ú¯ Ø­Ù„Ù‚Ù‡ ÙÙˆÚ©ÙˆØ³ ÙˆØ±ÙˆØ¯ÛŒâ€ŒÙ‡Ø§ */
        }

        /* Custom Scrollbar for Modals */
        .modal-scrollable-content::-webkit-scrollbar {
            width: 8px;
        }
        .modal-scrollable-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .modal-scrollable-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .modal-scrollable-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Dark mode scrollbar */
        .dark .modal-scrollable-content::-webkit-scrollbar-track {
            background: #333;
        }
        .dark .modal-scrollable-content::-webkit-scrollbar-thumb {
            background: #666;
        }
        .dark .modal-scrollable-content::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        /* Styles for drag and drop feedback */
        .dragging {
            opacity: 0.5;
            border: 2px dashed var(--drag-border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); /* More prominent shadow */
        }
        .drop-target {
            border: 2px solid var(--drag-border-color); /* Full border */
            background-color: rgba(var(--drag-border-color-rgb), 0.1); /* Transparent background */
            transition: all 0.2s ease-in-out; /* Animation for changes */
        }

        /* Main font for the whole body */
        body {
            font-family: 'Vazirmatn', sans-serif;
            direction: rtl; /* Ensure RTL direction for the whole body */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* Internet Explorer/Edge */
            user-select: none;         /* Standard */
        }
        /* Allow selection for inputs and textareas */
        input, textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        /* Force Vazirmatn to use Persian numerals for all numbers */
        body, input[type="number"], input[type="text"], select {
            font-feature-settings: "ss02", "locl"; /* Stylistic Set 2 and Localized Forms for Vazirmatn */
            font-variant-numeric: traditional; /* Use traditional numeral forms */
            unicode-bidi: plaintext; /* Helps with mixed directionality in inputs */
        }

        /* Modal box styles */
        .modal-box {
            height: 75vh; /* Dynamic height: 3/4 of viewport height */
            max-height: 400px; /* Max height for modal content */
        }

        /* Inner scrollable content area */
        .modal-scrollable-content {
            flex-grow: 1; /* Allows content to take available space */
            overflow-y: auto; /* Enable vertical scrolling */
            padding-left: 1rem; /* Adjust padding for scrollbar */
            padding-right: 1rem;
        }

        /* Points gain animation */
        .points-gain-feedback {
            position: absolute;
            font-weight: bold;
            color: #22C55E; /* Green color, remains constant */
            animation: fadeOutUp 1.5s forwards;
            pointer-events: none; /* Ensure it doesn't block clicks */
            z-index: 20;
        }

        @keyframes fadeOutUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }

        /* Confetti effect */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f0f; /* Default color */
            animation: confetti-fall 3s ease-out forwards;
            opacity: 0;
        }

        @keyframes confetti-fall {
            0% {
                opacity: 0;
                transform: translateY(-100px) rotate(0deg);
            }
            10% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(100vh) rotate(720deg);
            }
            /* Adjusted to ensure confetti falls off screen */
            100% {
                opacity: 0;
                transform: translateY(100vh) rotate(720deg);
            }
        }

        /* Dynamic styles for inputs and selectors */
        input[type="text"], input[type="number"], select {
            border-color: var(--theme-input-border);
        }
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--theme-input-focus-ring);
        }

        /* Dynamic styles for inputs and selectors in dark mode */
        .dark input[type="text"], .dark input[type="number"], .dark select {
            border-color: var(--theme-input-border); /* Use specific dark mode border color */
        }
        .dark input[type="text"]:focus, .dark input[type="number"]:focus, .dark select:focus {
            box-shadow: 0 0 0 2px var(--theme-input-focus-ring); /* Use specific dark mode focus ring color */
        }
        .clickable-item {
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .clickable-item:hover {
            background-color: rgba(0, 0, 0, 0.05); /* Light hover for light mode */
        }
        .dark .clickable-item:hover {
            background-color: rgba(255, 255, 255, 0.05); /* Dark hover for dark mode */
        }

        /* Style for task title to wrap, not scroll */
        .task-name-wrapper {
            white-space: normal; /* Allow text to wrap */
            word-break: break-word; /* Break long words */
            flex-grow: 1; /* Allow it to take available space */
            min-width: 0; /* Allow it to shrink below its content size */
        }

        /* Strikethrough animation for task text - removed */
        /* .task-name {
            transition: text-decoration 0.3s ease-in-out, color 0.3s ease-in-out;
        } */
        .line-through .task-name {
            text-decoration: line-through;
        }

        /* Styles for the three-dot menu pop-up */
        .task-action-menu {
            position: absolute;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 0.5rem;
            z-index: 50;
            min-width: 150px;
            transform-origin: top right;
            animation: scaleIn 0.15s ease-out forwards;
        }
        .dark .task-action-menu {
            background-color: #374151; /* gray-700 */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .task-action-menu button {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            text-align: right;
            font-size: 0.875rem; /* text-sm */
            color: #374151; /* gray-700 */
            transition: background-color 0.2s ease-in-out;
        }
        .dark .task-action-menu button {
            color: #d1d5db; /* gray-300 */
        }
        .task-action-menu button:hover {
            background-color: #f3f4f6; /* gray-100 */
        }
        .dark .task-action-menu button:hover {
            background-color: #4b5563; /* gray-600 */
        }
        .task-action-menu button svg {
            margin-left: 0.5rem; /* ml-2 */
        }

        @keyframes scaleIn {
            0% { transform: scale(0.95); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Styles for dynamic modals (edit/change order) */
        .dynamic-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            z-index: 60; /* Higher than other modals */
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            pointer-events: none;
        }
        .dynamic-modal.show {
            opacity: 1;
            pointer-events: auto;
        }
        .dynamic-modal-content {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            padding: 1.5rem;
            width: 100%;
            max-width: 400px;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            opacity: 0;
            position: relative;
        }
        .dark .dynamic-modal-content {
            background-color: #374151; /* gray-700 */
        }
        .dynamic-modal.show .dynamic-modal-content {
            transform: translateY(0);
            opacity: 1;
        }
        .dynamic-modal-content input, .dynamic-modal-content select {
            width: 100%;
            margin-bottom: 1rem;
        }
        .dynamic-modal-content button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: bold;
            transition: transform 0.1s ease-in-out;
        }
        .dynamic-modal-content button:hover {
            transform: scale(1.02);
        }
    </style>
</head>
<body class="p-4 flex items-center justify-center min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-100">
    <div class="container bg-white dark:bg-gray-800 shadow-xl rounded-xl p-4 sm:p-6 md:p-8 w-full max-w-4xl relative pt-16 md:pt-20">
        <div class="absolute top-4 right-4 md:top-6 md:right-6 z-10">
            <button id="menuBtn" class="p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400" aria-label="Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ù…Ù†Ùˆ">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2z"></path>
                </svg>
            </button>
            <div id="menuDropdown" class="absolute right-0 mt-2 w-48 bg-white dark:bg-gray-700 rounded-md shadow-lg py-1 hidden z-20">
                <a href="#" id="profileMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out">Ù¾Ø±ÙˆÙØ§ÛŒÙ„</a>
                <a href="#" id="helpMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out">Ø±Ø§Ù‡Ù†Ù…Ø§</a>
                <a href="#" id="aboutMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out">Ø¯Ø±Ø¨Ø§Ø±Ù‡</a>
                <a href="#" id="backupMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-300 ease-in-out">Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ</a>
                <a href="#" id="donateMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out">Ø¯ÙˆÙ†ÛŒØª</a>
                <a href="#" id="resetMenuItem" class="block px-4 py-2 text-sm text-red-700 dark:text-red-200 hover:bg-red-100 dark:hover:bg-red-600 transition duration-200 ease-in-out">Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§</a>
            </div>
        </div>

        <button id="themeToggleBtn" class="absolute top-4 left-4 md:top-6 md:left-6 p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-100 shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400" aria-label="ØªØºÛŒÛŒØ± ØªÙ…">
            <svg id="themeIcon" class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.325 6.675l-.707-.707M6.318 6.318l-.707-.707m12.728 0l-.707.707M6.318 17.682l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
            </svg>
        </button>

        <div class="flex flex-col md:flex-row justify-between items-center mb-6 border-b pb-4 border-gray-200 dark:border-gray-700 md:px-16">
            <h1 class="text-3xl sm:text-4xl md:text-6xl font-bold text-gray-800 dark:text-gray-100 mb-4 md:mb-0 text-center md:text-right w-full md:w-auto">Ø²ÛŒ ØªØ³Ú©</h1>
            <div class="flex flex-col sm:flex-row items-center space-y-2 sm:space-y-0 sm:space-x-4 sm:space-x-reverse w-full md:w-auto justify-center md:justify-end">
                <div class="flex items-center bg-yellow-100 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-200 px-3 py-1 rounded-full shadow-sm">
                    <span class="text-xl mr-2">ğŸ’°</span>
                    <span class="text-base sm:text-lg font-semibold">Ù¾ÙˆÛŒÙ†Øª: <span id="zPoint" class="text-yellow-800 dark:text-yellow-200">0</span></span>
                </div>
                <div class="flex items-center bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 px-3 py-1 rounded-full shadow-sm clickable-item" id="currentLevelDisplay">
                    <span class="text-xl mr-2">ğŸ†</span>
                    <span class="text-base sm:text-lg font-semibold">Ø³Ø·Ø­: <span id="level" class="text-blue-800 dark:text-blue-200">1</span></span>
                </div>
                <div class="flex items-center bg-purple-100 dark:bg-purple-800 text-purple-800 dark:text-purple-200 px-3 py-1 rounded-full shadow-sm">
                    <span class="text-xl mr-2">ğŸ”¥</span>
                    <span class="text-base sm:text-lg font-semibold">Ø²Ù†Ø¬ÛŒØ±Ù‡: <span id="dailyStreak" class="text-purple-800 dark:text-purple-200">0</span></span>
                </div>
            </div>
        </div>

        <div class="mb-6 px-2 md:px-0">
            <h2 class="text-lg sm:text-xl font-semibold text-gray-700 dark:text-gray-300 mb-2">Ù¾ÛŒØ´Ø±ÙØª Ø´Ù…Ø§ Ø¨Ù‡ Ø³Ø·Ø­ Ø¨Ø¹Ø¯ÛŒ:</h2>
            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4">
                <div id="progressBar" class="h-4 rounded-full transition-all duration-500 ease-out" style="width: 0%;"></div>
            </div>
            <p id="progressText" class="text-sm text-gray-500 dark:text-gray-400 mt-1 text-left">0%</p>
        </div>

        <div class="mb-6 px-2 md:px-0">
            <h2 class="text-lg sm:text-xl font-semibold text-gray-700 dark:text-gray-300 mb-2">Ø¯Ø³ØªØ§ÙˆØ±Ø¯Ù‡Ø§:</h2>
            <div id="achievementsList" class="flex flex-wrap gap-3">
                <p id="noAchievementsMessage" class="text-gray-500 dark:text-gray-400">Ù‡Ù†ÙˆØ² Ø¯Ø³ØªØ§ÙˆØ±Ø¯ÛŒ Ú©Ø³Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.</p>
            </div>
        </div>

        <div class="mb-8 p-4 rounded-lg shadow-sm" id="addTaskSection">
            <h2 class="text-xl sm:text-2xl font-semibold mb-4" id="addTaskTitle">Ø§ÙØ²ÙˆØ¯Ù† ÙˆØ¸ÛŒÙÙ‡ Ø¬Ø¯ÛŒØ¯</h2>
            <div class="flex flex-col md:flex-row gap-4 items-stretch md:items-center">
                <input type="text" id="taskInput" placeholder="Ù†Ø§Ù… ÙˆØ¸ÛŒÙÙ‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯..." maxlength="15"
                       class="flex-grow p-3 border rounded-lg text-base sm:text-lg text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700 h-12">
                <select id="importanceSelect"
                        class="p-3 border rounded-lg text-base sm:text-lg text-gray-700 dark:text-gray-100 bg-white dark:bg-gray-700 appearance-none h-12 w-full md:w-40">
                    <option value="important">Ù…Ù‡Ù…</option>
                    <option value="normal" selected>Ø¹Ø§Ø¯ÛŒ</option>
                    <option value="custom">Ø³ÙØ§Ø±Ø´ÛŒ</option>
                </select>
                <input type="number" id="customPointsInput" placeholder="Ù¾ÙˆÛŒÙ†Øª Ø³ÙØ§Ø±Ø´ÛŒ (Ø­Ø¯Ø§Ú©Ø«Ø± 50)"
                       class="p-3 border rounded-lg text-base sm:text-lg text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700 h-12 w-full md:w-32 hidden">
                <button id="addTaskBtn"
                        class="text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 text-lg w-full md:w-auto">
                    Ø§ÙØ²ÙˆØ¯Ù† ÙˆØ¸ÛŒÙÙ‡
                </button>
            </div>
        </div>

        <div class="mb-6 px-2 md:px-0">
            <div class="flex flex-col sm:flex-row items-center justify-between mb-4">
                <h2 class="text-xl sm:text-2xl font-semibold text-gray-800 dark:text-gray-100 mb-2 sm:mb-0">ÙˆØ¸Ø§ÛŒÙ ÙØ¹Ø§Ù„</h2>
                <div id="activeTasksPagination" class="flex items-center space-x-2 space-x-reverse hidden">
                    </div>
            </div>
            <div id="activeTaskList" class="task-list-container pr-2">
                </div>
        </div>

        <div class="mt-8 px-2 md:px-0">
            <button id="toggleCompletedTasksBtn" class="w-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out flex items-center justify-between focus:outline-none focus:ring-2 focus:ring-blue-400">
                <span>ÙˆØ¸Ø§ÛŒÙ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡</span>
                <svg id="toggleIcon" class="h-5 w-5 transform transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
            <div id="completedTasksSection" class="hidden mt-4">
                <div class="flex flex-col sm:flex-row items-center justify-between mb-4 mt-4">
                    <h2 class="text-xl sm:text-2xl font-semibold text-gray-800 dark:text-gray-100 mb-2 sm:mb-0"></h2> <div id="completedTasksPagination" class="flex items-center space-x-2 space-x-reverse hidden">
                        </div>
                </div>
                <div id="completedTasksContainer" class="task-list-container pr-2">
                    </div>
            </div>
        </div>
    </div>

    <div id="welcomeModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm relative text-gray-800 dark:text-gray-100 transition-transform duration-300 transform scale-95 opacity-0" id="welcomeModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700 text-center">Ø¨Ù‡ Ø²ÛŒ ØªØ³Ú© Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯!</h3>
            <p class="mb-4 text-center text-gray-700 dark:text-gray-300">Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ ØªØ§ Ø´Ø±ÙˆØ¹ Ú©Ù†ÛŒÙ…:</p>
            <input type="text" id="userNameInput" placeholder="Ù†Ø§Ù… Ø´Ù…Ø§..." maxlength="15"
                   class="w-full p-3 border border-blue-300 dark:border-blue-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 dark:focus:ring-blue-300 text-base sm:text-lg text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-500 bg-white dark:bg-gray-700 mb-4">
            <button id="startBtn"
                    class="w-full bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 text-lg">
                Ø¨Ø²Ù† Ø¨Ø±ÛŒÙ…!
            </button>
        </div>
    </div>

    <div id="profileModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="profileModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ú©Ø§Ø±Ø¨Ø±ÛŒ</h3>
            <div id="profileModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
                </div>
            <button id="closeProfileModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="helpModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">Ø±Ø§Ù‡Ù†Ù…Ø§</h3>
            <div id="helpModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
                </div>
            <button id="closeHelpModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="aboutModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="aboutModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">Ø¯Ø±Ø¨Ø§Ø±Ù‡</h3>
            <div id="aboutModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
                <p class="mb-3">Ø§ÛŒÙ† Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø¨Ø±Ø§ÛŒ Ú©Ù…Ú© Ø¨Ù‡ Ù…Ø¯ÛŒØ±ÛŒØª ÙˆØ¸Ø§ÛŒÙ Ùˆ Ø§ÙØ²Ø§ÛŒØ´ Ø§Ù†Ú¯ÛŒØ²Ù‡ Ø·Ø±Ø§Ø­ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª.</p>
                <p class="mb-3">Ø§ÛŒÙ† Ù¾Ø±ÙˆÚ˜Ù‡ Ø¨Ù‡ ØµÙˆØ±Øª Ø§Ø®ØªØµØ§ØµÛŒ ØªÙˆØ³Ø· <strong class="text-blue-600 dark:text-blue-400"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">Ø³Ø§ÛŒØª Ø¹Ù…Ùˆ Ù„Ø¦Ùˆ</a></strong> Ø·Ø±Ø§Ø­ÛŒ Ø´Ø¯Ù‡ Ø§Ø³ØªØŒ Ø§ÛŒÙ† Ø¢ÙˆÙ„ÛŒÙ† Ùˆ Ø¢Ø®Ø±ÛŒÙ† Ù†Ø³Ø®Ù‡ Ø§Ø² Ø§Ø² Ø§ÛŒÙ† Ù¾Ø±ÙˆÚ˜Ù‡ Ø§Ø³Øª.</p>
                <p class="mb-3">ØªÙ…Ø§Ù…ÛŒ Ø­Ù‚ÙˆÙ‚ Ù…ØªØ¹Ù„Ù‚ Ø¨Ù‡ <strong class="text-blue-600 dark:text-blue-400"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">Ø¹Ù…Ùˆ Ù„Ø¦Ùˆ</a></strong> Ø§Ø³Øª.</p>
                <p class="mb-3">ØªØ§Ø±ÛŒØ®: Û´ Ø®Ø±Ø¯Ø§Ø¯ Û±Û´Û°Û´</p>
            </div>
            <button id="closeAboutModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="backupModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="backupModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ùˆ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§</h3>
            <div class="modal-scrollable-content flex flex-col gap-4">
                <p class="text-sm text-gray-700 dark:text-gray-300">Ø¨Ø±Ø§ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒØŒ Ø¯Ú©Ù…Ù‡ "Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§" Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯ ØªØ§ ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù† Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø´ÙˆØ¯. Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒØŒ ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù† Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯Ù‡ Ùˆ "Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø² ÙØ§ÛŒÙ„" Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯.</p>
                
                <button id="exportDataBtn" class="bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ (Ø¯Ø§Ù†Ù„ÙˆØ¯ ÙØ§ÛŒÙ„)
                </button>

                <div class="flex items-center gap-2 mt-2">
                    <label for="importFileInput" class="bg-violet-500 hover:bg-violet-600 dark:bg-violet-700 dark:hover:bg-violet-800 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out cursor-pointer focus:outline-none focus:ring-2 focus:ring-violet-400">
                        Ø§Ù†ØªØ®Ø§Ø¨ ÙØ§ÛŒÙ„
                    </label>
                    <span id="selectedFileName" class="text-sm text-gray-600 dark:text-gray-300 truncate max-w-[calc(100%-120px)]">ÙØ§ÛŒÙ„ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.</span>
                    <input type="file" id="importFileInput" accept=".json" class="hidden">
                </div>
                
                <button id="importDataBtn" class="bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-400">
                    Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø² ÙØ§ÛŒÙ„
                </button>
            </div>
            <button id="closeBackupModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="resetConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm relative text-gray-800 dark:text-gray-100 transition-transform duration-300 transform scale-95 opacity-0" id="resetConfirmModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">ØªØ£ÛŒÛŒØ¯ Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§</h3>
            <p class="mb-6 text-sm">Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ ØªÙ…Ø§Ù…ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø±Ø§ Ø­Ø°Ù Ú©Ù†ÛŒØ¯ØŸ Ø§ÛŒÙ† Ø¹Ù…Ù„ ØºÛŒØ±Ù‚Ø§Ø¨Ù„ Ø¨Ø§Ø²Ú¯Ø´Øª Ø§Ø³Øª.</p>
            <div class="flex justify-end space-x-4 space-x-reverse">
                <button id="confirmResetBtn" class="bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-red-400">
                    ØªØ£ÛŒÛŒØ¯ Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ
                </button>
                <button id="cancelResetBtn" class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100 font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-gray-400">
                    Ù„ØºÙˆ
                </button>
            </div>
            <button id="closeResetModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="detailModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="detailModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700" id="detailModalTitle"></h3>
            <div id="detailModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
            </div>
            <button id="closeDetailModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="editTaskModal" class="dynamic-modal hidden">
        <div class="dynamic-modal-content text-gray-800 dark:text-gray-100" id="editTaskModalContent"> <h3 class="text-xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">ÙˆÛŒØ±Ø§ÛŒØ´ ÙˆØ¸ÛŒÙÙ‡</h3>
            <input type="text" id="editTaskNameInput" placeholder="Ù†Ø§Ù… ÙˆØ¸ÛŒÙÙ‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯..." maxlength="15"
                   class="p-3 border rounded-lg text-base text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700">
            <select id="editTaskImportanceSelect"
                    class="p-3 border rounded-lg text-base text-gray-700 dark:text-gray-100 bg-white dark:bg-gray-700 appearance-none">
                <option value="important">Ù…Ù‡Ù…</option>
                <option value="normal">Ø¹Ø§Ø¯ÛŒ</option>
                <option value="custom">Ø³ÙØ§Ø±Ø´ÛŒ</option>
            </select>
            <input type="number" id="editTaskCustomPointsInput" placeholder="Ù¾ÙˆÛŒÙ†Øª Ø³ÙØ§Ø±Ø´ÛŒ (Ø­Ø¯Ø§Ú©Ø«Ø± 50)"
                   class="p-3 border rounded-lg text-base text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700 hidden">
            <div class="flex justify-end space-x-2 space-x-reverse">
                <button id="saveEditedTaskBtn" class="bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800 text-white">Ø°Ø®ÛŒØ±Ù‡</button>
                <button id="cancelEditTaskBtn" class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100">Ù„ØºÙˆ</button>
            </div>
        </div>
    </div>

    <div id="changeOrderModal" class="dynamic-modal hidden">
        <div class="dynamic-modal-content text-gray-800 dark:text-gray-100" id="changeOrderModalContent">
            <h3 class="text-xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">ØªØºÛŒÛŒØ± Ú†ÛŒØ¯Ù…Ø§Ù† ÙˆØ¸ÛŒÙÙ‡</h3>
            <p class="mb-2 text-sm text-gray-700 dark:text-gray-300">Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¬Ø¯ÛŒØ¯ ÙˆØ¸ÛŒÙÙ‡ Ø±Ø§ (Ø¨Ù‡ ØµÙˆØ±Øª Ø¹Ø¯Ø¯ÛŒ) ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯:</p>
            <input type="number" id="changeOrderInput" placeholder="Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¬Ø¯ÛŒØ¯..."
                   class="p-3 border rounded-lg text-base text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700">
            <div class="flex justify-end space-x-2 space-x-reverse">
                <button id="saveChangedOrderBtn" class="bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800 text-white">Ø°Ø®ÛŒØ±Ù‡</button>
                <button id="cancelChangeOrderBtn" class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100">Ù„ØºÙˆ</button>
            </div>
        </div>
    </div>

    <div id="confettiContainer" class="confetti-container"></div>

    <div id="undoMessageBox" class="fixed bottom-4 left-1/2 -translate-x-1/2 p-4 rounded-lg shadow-lg text-white bg-gray-800 dark:bg-gray-700 z-50 transition-all duration-300 transform scale-0 opacity-0 flex items-center justify-between min-w-[200px] max-w-sm cursor-pointer hidden">
        <span id="undoMessageText" class="flex-grow mr-2"></span>
        <span id="undoCountdown" class="font-bold text-sm"></span>
    </div>

    <script>
        // Task data structure
        let tasks = [];
        let zPoint = 0; // Z-Point
        let level = 1; // Current level
        let dailyStreak = 0; // Daily streak counter
        let highestDailyStreak = 0; // New variable for highest streak
        let lastCompletionDate = null; // Date of last task completion
        let totalCustomTasksCompleted = 0; // Counter for completed custom tasks
        let userName = null; // User's name

        const pointsPerNormalTask = 10; // Points for normal tasks
        const pointsPerImportantTask = 25; // Points for important tasks
        const MAX_CUSTOM_POINTS = 50; // Max points for custom tasks
        const TASKS_PER_PAGE = 7; // Number of tasks displayed per page (Changed from 8 to 7)

        // Pagination status variables
        let activeCurrentPage = 1;
        let completedCurrentPage = 1;

        // Define points required to reach each level (Level 1 is zero points)
        const levelPointsThresholds = [
            { name: 'Ù†ÙˆØ¨Ø§', points: 0 },
            { name: 'Ù…Ø¨ØªØ¯ÛŒ', points: 30 },
            { name: 'Ø¬Ù†Ú¯Ø¬Ùˆ', points: 70 },
            { name: 'Ø´ÙˆØ§Ù„ÛŒÙ‡', points: 120 },
            { name: 'Ù‚Ù‡Ø±Ù…Ø§Ù†', points: 180 },
            { name: 'Ø§Ø³ØªØ§Ø¯', points: 250 },
            { name: 'ÙØ±Ù…Ø§Ù†Ø¯Ù‡', points: 330 },
            { name: 'Ø³Ù„Ø·Ø§Ù†', points: 420 },
            { name: 'Ø§Ú˜Ø¯Ù‡Ø§', points: 520 },
            { name: 'Ø§ÙØ³Ø§Ù†Ù‡', points: 630 },
            { name: 'Ø¬Ø§ÙˆØ¯Ø§Ù†', points: 750 },
            { name: 'Ø®Ø¯Ø§ÛŒÚ¯Ø§Ù†', points: 900 },
            { name: 'Ú©ÛŒÙ‡Ø§Ù†â€ŒÙ†ÙˆØ±Ø¯', points: 1080 },
            { name: 'Ø§Ø¨Ø±Ù‚Ù‡Ø±Ù…Ø§Ù†', points: 1290 },
            { name: 'Ø³ÛŒÚ¯Ù…Ø§', points: 1500 }
        ];

        // Define themes for each level
        const levelThemes = [
            {
                name: 'Ù†ÙˆØ¨Ø§',
                light: { primary: '#3b82f6', secondary: '#60a5fa', accentBg: '#eff6ff', accentText: '#1e40af', inputBorder: '#93c5fd', inputFocusRing: '#60a5fa' },
                dark: { primary: '#1d4ed8', secondary: '#3b82f6', accentBg: '#1e3a8a', accentText: '#bfdbfe', inputBorder: '#1d4ed8', inputFocusRing: '#3b82f6' },
                description: 'Ø¢Ø¨ÛŒ Ø¢Ø±Ø§Ù…'
            },
            {
                name: 'Ù…Ø¨ØªØ¯ÛŒ',
                light: { primary: '#22c55e', secondary: '#4ade80', accentBg: '#f0fdf4', accentText: '#166534', inputBorder: '#bbf7d0', inputFocusRing: '#4ade80' },
                dark: { primary: '#15803d', secondary: '#22c55e', accentBg: '#14532d', accentText: '#86efac', inputBorder: '#15803d', inputFocusRing: '#22c55e' },
                description: 'Ø³Ø¨Ø² ØªØ§Ø²Ù‡'
            },
            {
                name: 'Ø¬Ù†Ú¯Ø¬Ùˆ',
                light: { primary: '#f97316', secondary: '#fb923c', accentBg: '#fff7ed', accentText: '#c2410c', inputBorder: '#fed7aa', inputFocusRing: '#fb923c' },
                dark: { primary: '#ea580c', secondary: '#f97316', accentBg: '#7c2d12', accentText: '#fed7aa', inputBorder: '#ea580c', inputFocusRing: '#f97316' },
                description: 'Ù†Ø§Ø±Ù†Ø¬ÛŒ Ù¾Ø±Ø§Ù†Ø±Ú˜ÛŒ'
            },
            {
                name: 'Ø´ÙˆØ§Ù„ÛŒÙ‡',
                light: { primary: '#6b7280', secondary: '#9ca3af', accentBg: '#f9fafb', accentText: '#374151', inputBorder: '#d1d5db', inputFocusRing: '#9ca3af' },
                dark: { primary: '#4b5563', secondary: '#6b7280', accentBg: '#ffffff', accentText: '#000000', inputBorder: '#4b5563', inputFocusRing: '#6b7280' },
                description: 'Ø®Ø§Ú©Ø³ØªØ±ÛŒ Ù†Ù‚Ø±Ù‡â€ŒØ§ÛŒ (Ø­Ø§Ù„Øª ØªØ§Ø±ÛŒÚ©: Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø³ÙÛŒØ¯ØŒ Ù…ØªÙ† Ù…Ø´Ú©ÛŒ)'
            },
            {
                name: 'Ù‚Ù‡Ø±Ù…Ø§Ù†',
                light: { primary: '#ef4444', secondary: '#f87171', accentBg: '#fef2f2', accentText: '#b91c1c', inputBorder: '#fca5a5', inputFocusRing: '#f87171' },
                dark: { primary: '#dc2626', secondary: '#ef4444', accentBg: '#7f1d1d', accentText: '#fca5a5', inputBorder: '#dc2626', inputFocusRing: '#ef4444' },
                description: 'Ù‚Ø±Ù…Ø² Ø¢ØªØ´ÛŒÙ†'
            },
            {
                name: 'Ø§Ø³ØªØ§Ø¯',
                light: { primary: '#9333ea', secondary: '#a855f7', accentBg: '#faf5ff', accentText: '#6b21a8', inputBorder: '#d8b4fe', inputFocusRing: '#a855f7' },
                dark: { primary: '#7e22ce', secondary: '#9333ea', accentBg: '#4a044e', accentText: '#e9d5ff', inputBorder: '#7e22ce', inputFocusRing: '#9333ea' },
                description: 'Ø¨Ù†ÙØ´ Ø¹Ù…ÛŒÙ‚'
            },
            {
                name: 'ÙØ±Ù…Ø§Ù†Ø¯Ù‡',
                light: { primary: '#14b8a6', secondary: '#2dd4bf', accentBg: '#f0fdfa', accentText: '#0f766e', inputBorder: '#99f6e4', inputFocusRing: '#2dd4bf' },
                dark: { primary: '#0d9488', secondary: '#14b8a6', accentBg: '#042f2e', accentText: '#99f6e4', inputBorder: '#0d9488', inputFocusRing: '#14b8a6' },
                description: 'Ø¢Ø¨ÛŒ-Ø³Ø¨Ø²'
            },
            {
                name: 'Ø³Ù„Ø·Ø§Ù†',
                light: { primary: '#eab308', secondary: '#fcd34d', accentBg: '#fefce8', accentText: '#a16207', inputBorder: '#fde68a', inputFocusRing: '#fcd34d' },
                dark: { primary: '#d97706', secondary: '#eab308', accentBg: '#78350f', accentText: '#fde68a', inputBorder: '#d97706', inputFocusRing: '#eab308' },
                description: 'Ø·Ù„Ø§ÛŒÛŒ'
            },
            {
                name: 'Ø§Ú˜Ø¯Ù‡Ø§',
                light: { primary: '#f59e0b', secondary: '#fbbf24', accentBg: '#fffbeb', accentText: '#b45309', inputBorder: '#fcd34d', inputFocusRing: '#fbbf24' },
                dark: { primary: '#d97706', secondary: '#f59e0b', accentBg: '#78350f', accentText: '#fcd34d', inputBorder: '#d97706', inputFocusRing: '#f59e0b' },
                description: 'Ú©Ù‡Ø±Ø¨Ø§ÛŒÛŒ'
            },
            {
                name: 'Ø§ÙØ³Ø§Ù†Ù‡',
                light: { primary: '#ec4899', secondary: '#f472b6', accentBg: '#fdf2f8', accentText: '#be185d', inputBorder: '#fbcfe8', inputFocusRing: '#f472b6' },
                dark: { primary: '#be185d', secondary: '#ec4899', accentBg: '#500724', accentText: '#fbcfe8', inputBorder: '#be185d', inputFocusRing: '#ec4899' },
                description: 'ØµÙˆØ±ØªÛŒ Ø¯Ø±Ø®Ø´Ø§Ù†'
            },
            {
                name: 'Ø¬Ø§ÙˆØ¯Ø§Ù†',
                light: { primary: '#6366f1', secondary: '#818cf8', accentBg: '#eef2ff', accentText: '#3730a3', inputBorder: '#c7d2fe', inputFocusRing: '#818cf8' },
                dark: { primary: '#4338ca', secondary: '#6366f1', accentBg: '#1e1b4b', accentText: '#c7d2fe', inputBorder: '#4338ca', inputFocusRing: '#6366f1' },
                description: 'Ù†ÛŒÙ„ÛŒ'
            },
            {
                name: 'Ø®Ø¯Ø§ÛŒÚ¯Ø§Ù†',
                light: { primary: '#84cc16', secondary: '#a3e635', accentBg: '#f7fee7', accentText: '#4d7c0f', inputBorder: '#d9f99d', inputFocusRing: '#a3e635' },
                dark: { primary: '#65a30d', secondary: '#84cc16', accentBg: '#365314', accentText: '#d9f99d', inputBorder: '#65a30d', inputFocusRing: '#84cc16' },
                description: 'Ø³Ø¨Ø² Ù„ÛŒÙ…ÙˆÛŒÛŒ'
            },
            {
                name: 'Ú©ÛŒÙ‡Ø§Ù†â€ŒÙ†ÙˆØ±Ø¯',
                light: { primary: '#06b6d4', secondary: '#22d3ee', accentBg: '#ecfeff', accentText: '#0e7490', inputBorder: '#a5f3fc', inputFocusRing: '#22d3ee' },
                dark: { primary: '#0891b2', secondary: '#06b6d4', accentBg: '#042f2e', accentText: '#a5f3fc', inputBorder: '#0891b2', inputFocusRing: '#06b6d4' },
                description: 'ÙÛŒØ±ÙˆØ²Ù‡â€ŒØ§ÛŒ'
            },
            {
                name: 'Ø§Ø¨Ø±Ù‚Ù‡Ø±Ù…Ø§Ù†',
                light: { primary: '#e11d48', secondary: '#f43f5e', accentBg: '#fff1f2', accentText: '#9f1239', inputBorder: '#fda4af', inputFocusRing: '#f43f5e' },
                dark: { primary: '#be123c', secondary: '#e11d48', accentBg: '#4c0519', accentText: '#fda4af', inputBorder: '#be123c', inputFocusRing: '#e11d48' },
                description: 'ØµÙˆØ±ØªÛŒ Ø±Ø²'
            },
            {
                name: 'Ø³ÛŒÚ¯Ù…Ø§', // Special state
                light: { primary: '#3b82f6', secondary: '#60a5fa', accentBg: '#ffffff', accentText: '#000000', inputBorder: '#93c5fd', inputFocusRing: '#60a5fa' },
                dark: { primary: '#3b82f6', secondary: '#60a5fa', accentBg: '#000000', accentText: '#ffffff', inputBorder: '#1d4ed8', inputFocusRing: '#3b82f6' },
                description: 'Ø³ÙÛŒØ¯ Ùˆ Ø¢Ø¨ÛŒ (ØªÙ… Ø±ÙˆØ²: Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ø³ÙÛŒØ¯ØŒ Ù…ØªÙ† Ù…Ø´Ú©ÛŒØ› ØªÙ… Ø´Ø¨: Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ Ù…Ø´Ú©ÛŒØŒ Ù…ØªÙ† Ø³ÙÛŒØ¯)'
            }
        ];

        // Achievements data
        const achievementsData = [
            { level: 1, name: 'Ù†ÙˆØ¨Ø§', icon: 'ğŸ‘¶', type: 'level' },
            { level: 2, name: 'Ù…Ø¨ØªØ¯ÛŒ', icon: 'ğŸŒ±', type: 'level' },
            { level: 3, name: 'Ø¬Ù†Ú¯Ø¬Ùˆ', icon: 'âš”ï¸', type: 'level' },
            { level: 4, name: 'Ø´ÙˆØ§Ù„ÛŒÙ‡', icon: 'ğŸ›¡ï¸', type: 'level' },
            { level: 5, name: 'Ù‚Ù‡Ø±Ù…Ø§Ù†', icon: 'ğŸ¦¸â€â™‚ï¸', type: 'level' },
            { level: 6, name: 'Ø§Ø³ØªØ§Ø¯', icon: 'ğŸ“', type: 'level' },
            { level: 7, name: 'ÙØ±Ù…Ø§Ù†Ø¯Ù‡', icon: 'ğŸ–ï¸', type: 'level' },
            { level: 8, name: 'Ø³Ù„Ø·Ø§Ù†', icon: 'ğŸ‘‘', type: 'level' },
            { level: 9, name: 'Ø§Ú˜Ø¯Ù‡Ø§', icon: 'ğŸ‰', type: 'level' },
            { type: 'totalTasks', value: 10, name: 'Ø¯Ù‡ ÙˆØ¸ÛŒÙÙ‡', icon: 'âœ…', description: 'Earned by completing 10 tasks.' },
            { type: 'totalTasks', value: 50, name: 'Ù¾Ù†Ø¬Ø§Ù‡ ÙˆØ¸ÛŒÙÙ‡', icon: 'ğŸ’¯', description: 'Earned by completing 50 tasks.' },
            { type: 'importantTasks', value: 5, name: 'Ù¾Ù†Ø¬ ÙˆØ¸ÛŒÙÙ‡ Ù…Ù‡Ù…', icon: 'ğŸš¨', description: 'Earned by completing 5 important tasks.' },
            { type: 'importantTasks', value: 10, name: 'Ø¯Ù‡ ÙˆØ¸ÛŒÙÙ‡ Ù…Ù‡Ù…', icon: 'ğŸ›‘', description: 'Earned by completing 10 important tasks.' },
            { type: 'streak', value: 3, name: 'Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø³Ù‡ Ø±ÙˆØ²Ù‡', icon: 'ğŸ”¥', description: 'Earned by completing at least one task for 3 consecutive days.' },
            { type: 'streak', value: 7, name: 'Ø²Ù†Ø¬ÛŒØ±Ù‡ Ù‡ÙØª Ø±ÙˆØ²Ù‡', icon: 'âœ¨ğŸ”¥', description: 'Earned by completing at least one task for 7 consecutive days.' },
            { type: 'streak', value: 14, name: 'Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø¯Ùˆ Ù‡ÙØªÙ‡â€ŒØ§ÛŒ', icon: 'ğŸ—“ï¸ğŸ”¥', description: 'Earned by completing at least one task for 14 consecutive days.' },
            { type: 'streak', value: 30, name: 'Ø²Ù†Ø¬ÛŒØ±Ù‡ Ù…Ø§Ù‡Ø§Ù†Ù‡', icon: 'ğŸ—“ï¸ğŸ—“ï¸ğŸ”¥', description: 'Earned by completing at least one task for 30 consecutive days.' },
            { type: 'totalTasks', value: 100, name: 'ØµØ¯ ÙˆØ¸ÛŒÙÙ‡', icon: 'ğŸ’¯âœ…', description: 'Earned by completing 100 tasks.' },
            { type: 'totalTasks', value: 250, name: 'Ø¯ÙˆÛŒØ³Øª Ùˆ Ù¾Ù†Ø¬Ø§Ù‡ ÙˆØ¸ÛŒÙÙ‡', icon: 'ğŸŒŸğŸ’¯', description: 'Earned by completing 250 tasks.' },
            { type: 'totalTasks', value: 500, name: 'Ù¾Ø§Ù†ØµØ¯ ÙˆØ¸ÛŒÙÙ‡', icon: 'ğŸ†ğŸ’¯', description: 'Earned by collecting 500 Points.' },
            { type: 'importantTasks', value: 20, name: 'Ø¨ÛŒØ³Øª ÙˆØ¸ÛŒÙÙ‡ Ù…Ù‡Ù…', icon: 'ğŸ›‘ğŸ›‘', description: 'Earned by completing 20 important tasks.' },
            { type: 'customTasks', value: 1, name: 'Ø§ÙˆÙ„ÛŒÙ† ÙˆØ¸ÛŒÙÙ‡ Ø³ÙØ§Ø±Ø´ÛŒ', icon: 'ğŸ’¡', description: 'Earned by completing the first custom-point task.' },
            { type: 'customTasks', value: 5, name: 'Ù¾Ù†Ø¬ ÙˆØ¸ÛŒÙÙ‡ Ø³ÙØ§Ø±Ø´ÛŒ', icon: 'âš™ï¸âœ…', description: 'Earned by completing 5 custom-point tasks.' },
            { type: 'customTasks', value: 10, name: 'Ø¯Ù‡ ÙˆØ¸ÛŒÙÙ‡ Ø³ÙØ§Ø±Ø´ÛŒ', icon: 'âš™ï¸ğŸ’¯', description: 'Earned by completing 10 custom-point tasks.' },
            { type: 'points', value: 500, name: 'Ù¾Ø§Ù†ØµØ¯ Ù¾ÙˆÛŒÙ†Øª', icon: 'ğŸ’°', description: 'Earned by collecting 500 Points.' },
            { type: 'points', value: 1000, name: 'Ù‡Ø²Ø§Ø± Ù¾ÙˆÛŒÙ†Øª', icon: 'ğŸ’ğŸ’°', description: 'Earned by collecting 1000 Points.' },
            { level: 10, name: 'Ø§ÙØ³Ø§Ù†Ù‡', icon: 'âœ¨', type: 'level' },
            { level: 11, name: 'Ø¬Ø§ÙˆØ¯Ø§Ù†', icon: 'â™¾ï¸', type: 'level' },
            { level: 12, name: 'Ø®Ø¯Ø§ÛŒÚ¯Ø§Ù†', icon: 'âš¡', type: 'level' },
            { level: 13, name: 'Ú©ÛŒÙ‡Ø§Ù†â€ŒÙ†ÙˆØ±Ø¯', icon: 'ğŸŒŒ', type: 'level' },
            { level: 14, name: 'Ø§Ø¨Ø±Ù‚Ù‡Ø±Ù…Ø§Ù†', icon: 'ğŸŒŸ', type: 'level' },
            { level: 15, name: 'Ø³ÛŒÚ¯Ù…Ø§', icon: 'ğŸ—¿', type: 'level' },
        ];

        // DOM elements
        const themeToggleBtn = document.getElementById('themeToggleBtn');
        const themeIcon = document.getElementById('themeIcon');
        const menuBtn = document.getElementById('menuBtn');
        const menuDropdown = document.getElementById('menuDropdown');
        const profileMenuItem = document.getElementById('profileMenuItem');
        const helpMenuItem = document.getElementById('helpMenuItem');
        const aboutMenuItem = document.getElementById('aboutMenuItem');
        const backupMenuItem = document.getElementById('backupMenuItem');
        const donateMenuItem = document.getElementById('donateMenuItem');
        const resetMenuItem = document.getElementById('resetMenuItem');

        const welcomeModal = document.getElementById('welcomeModal');
        const welcomeModalContent = document.getElementById('welcomeModalContent');
        const userNameInput = document.getElementById('userNameInput');
        const startBtn = document.getElementById('startBtn');

        const profileModal = document.getElementById('profileModal');
        const profileModalContent = document.getElementById('profileModalContent');
        const closeProfileModalBtn = document.getElementById('closeProfileModalBtn');

        const helpModal = document.getElementById('helpModal');
        const helpModalContent = document.getElementById('helpModalContent');
        const helpModalBody = document.getElementById('helpModalBody');
        const aboutModal = document.getElementById('aboutModal');
        const aboutModalContent = document.getElementById('aboutModalContent');
        const aboutModalBody = document.getElementById('aboutModalBody');
        const backupModal = document.getElementById('backupModal');
        const backupModalContent = document.getElementById('backupModalContent');
        const resetConfirmModal = document.getElementById('resetConfirmModal');
        const resetConfirmModalContent = document.getElementById('resetConfirmModalContent');
        const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');
        const closeAboutModalBtn = document.getElementById('closeAboutModalBtn');
        const closeBackupModalBtn = document.getElementById('closeBackupModalBtn');
        const confirmResetBtn = document.getElementById('confirmResetBtn');
        const cancelResetBtn = document.getElementById('cancelResetBtn');
        const closeResetModalBtn = document.getElementById('closeResetModalBtn');
        const importFileInput = document.getElementById('importFileInput');
        const exportDataBtn = document.getElementById('exportDataBtn');
        const importDataBtn = document.getElementById('importDataBtn');
        const selectedFileNameSpan = document.getElementById('selectedFileName');

        const detailModal = document.getElementById('detailModal');
        const detailModalContent = document.getElementById('detailModalContent');
        const detailModalTitle = document.getElementById('detailModalTitle');
        const detailModalBody = document.getElementById('detailModalBody');
        const closeDetailModalBtn = document.getElementById('closeDetailModalBtn');

        const taskInput = document.getElementById('taskInput');
        const importanceSelect = document.getElementById('importanceSelect');
        const customPointsInput = document.getElementById('customPointsInput');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const activeTaskList = document.getElementById('activeTaskList');
        const completedTasksContainer = document.getElementById('completedTasksContainer');
        const toggleCompletedTasksBtn = document.getElementById('toggleCompletedTasksBtn');
        const toggleIcon = document.getElementById('toggleIcon');
        const zPointSpan = document.getElementById('zPoint');
        const levelSpan = document.getElementById('level');
        const currentLevelDisplay = document.getElementById('currentLevelDisplay');
        const dailyStreakSpan = document.getElementById('dailyStreak');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const noAchievementsMessage = document.getElementById('noAchievementsMessage');
        const achievementsList = document.getElementById('achievementsList');
        const addTaskSection = document.getElementById('addTaskSection');
        const addTaskTitle = document.getElementById('addTaskTitle');

        // Pagination DOM elements
        const activeTasksPagination = document.getElementById('activeTasksPagination');
        const completedTasksPagination = document.getElementById('completedTasksPagination');
        const completedTasksSection = document.getElementById('completedTasksSection'); // Wrapper for completed tasks content

        const confettiContainer = document.getElementById('confettiContainer');

        // Variables for drag and drop
        let draggedTaskId = null;
        let draggedElement = null; // Reference to the actual element being dragged
        let ghostElement = null; // A ghost element for touch drag feedback
        let initialTouchOffsetX = 0; // Initial touch X offset from element's left edge
        let initialTouchOffsetY = 0; // Initial touch Y offset from element's top edge


        // Touch-related variables (for Drag & Drop and Tap)
        let touchStartX = 0;
        let touchStartY = 0;
        let touchCurrentX = 0;
        let touchCurrentY = 0;
        let longPressTimer = null; // For activating Drag & Drop
        let isDragging = false; // Flag to indicate official start of Drag & Drop operation
        let isGestureStarted = false; // True if a touch sequence has begun on a task item
        let isLongPressDetected = false; // True if long press threshold has been met for drag

        const DRAG_LONG_PRESS_TIME = 1500; // 1.5 seconds to activate Drag & Drop
        const TAP_THRESHOLD = 20; // Max pixels moved for a touch to still be considered a tap (increased for better touch recognition)

        // DOM elements for Undo Message Box
        const undoMessageBox = document.getElementById('undoMessageBox');
        const undoMessageText = document.getElementById('undoMessageText');
        const undoCountdown = document.getElementById('undoCountdown');

        // Message queues for sequential display (separate for top-right and bottom-center)
        const topRightMessageQueue = [];
        const bottomCenterMessageQueue = [];
        let isTopRightDisplaying = false;
        let isBottomCenterDisplaying = false;
        let currentTopRightTimeout = null;
        let currentBottomCenterTimeout = null;
        let currentCountdownInterval = null; // Holds the interval for the current countdown (if it's an undo message)


        // Dynamic Modal elements
        const editTaskModal = document.getElementById('editTaskModal');
        const editTaskModalContent = document.getElementById('editTaskModalContent'); // Correctly selected
        const editTaskNameInput = document.getElementById('editTaskNameInput');
        const editTaskImportanceSelect = document.getElementById('editTaskImportanceSelect');
        const editTaskCustomPointsInput = document.getElementById('editTaskCustomPointsInput');
        const saveEditedTaskBtn = document.getElementById('saveEditedTaskBtn');
        const cancelEditTaskBtn = document.getElementById('cancelEditTaskBtn');

        const changeOrderModal = document.getElementById('changeOrderModal');
        const changeOrderModalContent = document.getElementById('changeOrderModalContent'); // Added ID here
        const changeOrderInput = document.getElementById('changeOrderInput');
        const saveChangedOrderBtn = document.getElementById('saveChangedOrderBtn');
        const cancelChangeOrderBtn = document.getElementById('cancelChangeOrderBtn');

        let currentTaskBeingEditedId = null; // To keep track of which task is being edited/reordered


        // Helper function to convert Persian numerals to English numerals
        function convertPersianNumbersToEnglish(inputString) {
            if (typeof inputString !== 'string') {
                return inputString; // Return as is if not a string
            }
            const persianNumbers = ['Û°', 'Û±', 'Û²', 'Û³', 'Û´', 'Ûµ', 'Û¶', 'Û·', 'Û¸', 'Û¹'];
            const englishNumbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

            let convertedString = '';
            for (let i = 0; i < inputString.length; i++) {
                const char = inputString[i];
                const index = persianNumbers.indexOf(char);
                if (index !== -1) {
                    convertedString += englishNumbers[index];
                } else {
                    convertedString += char;
                }
            }
            return convertedString;
        }

        // Event listener for importance selection to show/hide custom points input
        importanceSelect.addEventListener('change', () => {
            if (importanceSelect.value === 'custom') {
                customPointsInput.classList.remove('hidden');
                customPointsInput.focus(); // Auto-focus when custom is selected
            } else {
                customPointsInput.classList.add('hidden');
            }
        });

        // Function to show a custom message box instead of alert()
        // Options can include: position ('top-right', 'bottom-center'), duration (ms), isUndo (boolean), taskId (for undo)
        function showMessageBox(message, type = 'info', options = {}) {
            const { position = 'top-right', duration = 3000, isUndo = false, taskData = null } = options;
            const messageObject = { message, type, position, duration, isUndo, taskData };

            if (position === 'top-right') {
                topRightMessageQueue.push(messageObject);
                processTopRightQueue();
            } else if (position === 'bottom-center') {
                bottomCenterMessageQueue.push(messageObject);
                processBottomCenterQueue();
            }
        }

        // Function to process the top-right message queue
        function processTopRightQueue() {
            if (topRightMessageQueue.length === 0 || isTopRightDisplaying) {
                return;
            }

            isTopRightDisplaying = true;
            const { message, type, duration } = topRightMessageQueue.shift();

            const messageBox = document.createElement('div');
            let bgColorClass = '';
            if (type === 'info') {
                bgColorClass = 'bg-blue-500 dark:bg-blue-700';
            } else if (type === 'success') {
                bgColorClass = 'bg-green-500 dark:bg-green-700';
            } else if (type === 'error') {
                bgColorClass = 'bg-red-500 dark:bg-red-700';
            }
            messageBox.className = `fixed p-4 rounded-lg shadow-lg text-white z-50 transition-all duration-300 transform opacity-0 top-4 right-4 translate-x-full ${bgColorClass}`;
            messageBox.textContent = message;
            document.body.appendChild(messageBox);

            setTimeout(() => {
                messageBox.classList.remove('translate-x-full', 'opacity-0');
                messageBox.classList.add('translate-x-0', 'opacity-100');
            }, 100);

            currentTopRightTimeout = setTimeout(() => {
                messageBox.classList.remove('translate-x-0', 'opacity-100');
                messageBox.classList.add('translate-x-full', 'opacity-0');
                messageBox.addEventListener('transitionend', () => {
                    messageBox.remove();
                    isTopRightDisplaying = false;
                    processTopRightQueue(); // Process next message
                }, { once: true });
            }, duration);
        }

        // Function to process the bottom-center message queue (for undo messages)
        function processBottomCenterQueue() {
            if (bottomCenterMessageQueue.length === 0 || isBottomCenterDisplaying) {
                return;
            }

            isBottomCenterDisplaying = true;
            const { message, duration, isUndo, taskData } = bottomCenterMessageQueue.shift();

            // Only the undoMessageBox uses bottom-center position and undo logic
            if (isUndo) {
                undoMessageText.textContent = message;
                undoMessageBox.classList.remove('hidden'); // Ensure it's not hidden
                undoMessageBox._currentUndoTaskData = taskData; // Store the specific task data for this message
                
                let timeLeft = duration / 1000;
                undoCountdown.textContent = `(${timeLeft}s)`;
                clearInterval(currentCountdownInterval); // Clear previous interval
                currentCountdownInterval = setInterval(() => {
                    timeLeft--;
                    undoCountdown.textContent = `(${timeLeft}s)`;
                    if (timeLeft <= 0) {
                        clearInterval(currentCountdownInterval);
                        hideBottomCenterMessage(); // Hide the undo message
                    }
                }, 1000);

                undoMessageBox.onclick = () => {
                    if (undoMessageBox._currentUndoTaskData) {
                        undoLastDeletion(undoMessageBox._currentUndoTaskData);
                    }
                    hideBottomCenterMessage(); // Hide the undo message immediately on click
                };

                // Entry animation
                setTimeout(() => {
                    undoMessageBox.classList.remove('scale-0', 'opacity-0');
                    undoMessageBox.classList.add('scale-100', 'opacity-100');
                }, 100);

                currentBottomCenterTimeout = setTimeout(() => {
                    hideBottomCenterMessage();
                }, duration);
            }

            function hideBottomCenterMessage() {
                clearTimeout(currentBottomCenterTimeout);
                clearInterval(currentCountdownInterval);
                undoMessageBox.classList.remove('scale-100', 'opacity-100');
                undoMessageBox.classList.add('scale-0', 'opacity-0');
                undoMessageBox.addEventListener('transitionend', () => {
                    undoMessageBox.classList.add('hidden'); // Hide completely after animation
                    undoMessageBox.onclick = null; // Remove click handler
                    undoMessageBox._currentUndoTaskData = null; // Clear the stored task data
                    isBottomCenterDisplaying = false;
                    processBottomCenterQueue(); // Process next message
                }, { once: true });
            }
        }


        // Function to show points gain feedback
        function showPointsGainFeedback(pointsGained, taskElement) {
            if (!taskElement) return;

            const feedback = document.createElement('div');
            feedback.textContent = `+${pointsGained}`;
            feedback.classList.add('points-gain-feedback');

            // Position feedback element relative to task item
            const rect = taskElement.getBoundingClientRect();
            feedback.style.top = `${rect.top + window.scrollY + rect.height / 2 - 10}px`;
            feedback.style.left = `${rect.left + window.scrollX + rect.width / 2 - 20}px`;
            feedback.style.fontSize = '1.2rem'; // Slightly increased font size

            document.body.appendChild(feedback);

            feedback.addEventListener('animationend', () => {
                feedback.remove();
            });
        }

        // Function to trigger confetti effect
        function triggerConfetti() {
            const colors = ['#f0f', '#0ff', '#ff0', '#f00', '#0f0', '#00f'];
            for (let i = 0; i < 50; i++) { // Generate 50 confetti pieces
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = `${Math.random() * 0.5}s`; // Staggered animation
                confettiContainer.appendChild(confetti);
            }
            // Clean up confetti after animation
            setTimeout(() => {
                confettiContainer.innerHTML = '';
            }, 3000);
        }

        // Function to apply theme based on current level
        function applyLevelTheme(currentLevel) {
            const isDarkMode = document.documentElement.classList.contains('dark');
            const themeIndex = Math.min(currentLevel - 1, levelThemes.length - 1); // Ensure index is within bounds
            const theme = levelThemes[themeIndex];
            const currentThemeData = isDarkMode ? theme.dark : theme.light;

            // Set CSS variables
            document.documentElement.style.setProperty('--theme-primary', currentThemeData.primary);
            document.documentElement.style.setProperty('--theme-secondary', currentThemeData.secondary);
            document.documentElement.style.setProperty('--theme-accent-bg', currentThemeData.accentBg);
            document.documentElement.style.setProperty('--theme-accent-text', currentThemeData.accentText);
            document.documentElement.style.setProperty('--theme-progress-from', currentThemeData.primary);
            document.documentElement.style.setProperty('--theme-progress-to', currentThemeData.secondary);
            document.documentElement.style.setProperty('--drag-border-color', currentThemeData.primary);
            document.documentElement.style.setProperty('--drag-border-color-rgb', hexToRgb(currentThemeData.primary)); // Added for rgba() usage
            document.documentElement.style.setProperty('--theme-input-border', currentThemeData.inputBorder);
            document.documentElement.style.setProperty('--theme-input-focus-ring', currentThemeData.inputFocusRing);

            // Update elements that use these variables
            // Add Task Button
            addTaskBtn.style.backgroundColor = currentThemeData.primary;
            addTaskBtn.onmouseover = () => addTaskBtn.style.backgroundColor = currentThemeData.secondary;
            addTaskBtn.onmouseout = () => addTaskBtn.style.backgroundColor = currentThemeData.primary;

            // Background and text of Add Task section
            addTaskSection.style.backgroundColor = currentThemeData.accentBg;
            addTaskTitle.style.color = currentThemeData.accentText;

            // Update progress bar gradient
            progressBar.style.backgroundImage = `linear-gradient(to right, ${currentThemeData.primary}, ${currentThemeData.secondary})`;
        }

        // Helper function to convert hex color code to RGB format
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return `${r}, ${g}, ${b}`;
        }

        // Function to update gamification display
        function updateGamificationDisplay() {
            zPointSpan.textContent = zPoint;
            
            // Calculate current level based on points thresholds
            let newLevel = 1;
            for (let i = 0; i < levelPointsThresholds.length; i++) {
                if (zPoint >= levelPointsThresholds[i].points) {
                    newLevel = i + 1;
                } else {
                    break; // Points are not enough for this level, so previous level is current
                }
            }

            if (newLevel > level) {
                showMessageBox(`ØªØ¨Ø±ÛŒÚ©! Ø¨Ù‡ Ø³Ø·Ø­ ${newLevel} Ø±Ø³ÛŒØ¯ÛŒØ¯!`, 'success'); // Changed message to Persian
                triggerConfetti();
            }
            level = newLevel; // Update global level variable
            levelSpan.textContent = level;

            dailyStreakSpan.textContent = dailyStreak; // Update daily streak display

            // Progress bar logic up to level 15
            if (level <= levelPointsThresholds.length) {
                const currentLevelThreshold = levelPointsThresholds[level - 1].points;
                // Ensure nextLevelThreshold is correctly calculated, especially for the last level
                const nextLevelThreshold = (level < levelPointsThresholds.length) ? levelPointsThresholds[level].points : zPoint;
                
                let pointsIntoCurrentLevel = zPoint - currentLevelThreshold;
                let pointsNeededForNextLevel = nextLevelThreshold - currentLevelThreshold;

                let progressPercentage = 0;
                if (pointsNeededForNextLevel > 0) {
                    progressPercentage = Math.min(100, (pointsIntoCurrentLevel / pointsNeededForNextLevel) * 100);
                } else if (level === levelPointsThresholds.length) { // Max level reached
                    progressPercentage = 100;
                }

                progressBar.style.width = `${progressPercentage}%`;
                if (level < levelPointsThresholds.length) {
                    progressText.textContent = `${Math.round(progressPercentage)}% Ù¾ÛŒØ´Ø±ÙØª Ø¨Ù‡ Ø³Ø·Ø­ ${level + 1}`; // Changed message to Persian
                } else {
                    progressText.textContent = `Ø´Ù…Ø§ Ø¨Ù‡ Ø­Ø¯Ø§Ú©Ø«Ø± Ø³Ø·Ø­ (${level}) Ø±Ø³ÛŒØ¯Ù‡â€ŒØ§ÛŒØ¯!`; // Changed message to Persian
                }
            } else {
                // After max level, progress bar remains full and only points accumulate
                progressBar.style.width = `100%`;
                progressText.textContent = `Ø´Ù…Ø§ Ø¨Ù‡ Ø­Ø¯Ø§Ú©Ø«Ø± Ø³Ø·Ø­ (${levelPointsThresholds.length}) Ø±Ø³ÛŒØ¯Ù‡â€ŒØ§ÛŒØ¯!`; // Changed message to Persian
            }
            
            renderAchievements(); // Call renderAchievements here
            applyLevelTheme(level); // Apply theme for current level
        }

        // Function to save tasks, points, level, streak, and last completion date to Local Storage
        function saveToLocalStorage() {
            localStorage.setItem('tasks', JSON.stringify(tasks));
            localStorage.setItem('zPoint', zPoint);
            localStorage.setItem('level', level);
            localStorage.setItem('dailyStreak', dailyStreak);
            localStorage.setItem('highestDailyStreak', highestDailyStreak); // Save highest streak
            localStorage.setItem('lastCompletionDate', lastCompletionDate);
            localStorage.setItem('totalCustomTasksCompleted', totalCustomTasksCompleted);
            localStorage.setItem('userName', userName);
        }

        // Function to load tasks, points, level, streak, and last completion date from Local Storage
        function loadFromLocalStorage() {
            const storedTasks = localStorage.getItem('tasks');
            const storedZPoint = localStorage.getItem('zPoint');
            const storedLevel = localStorage.getItem('level');
            const storedDailyStreak = localStorage.getItem('dailyStreak');
            const storedHighestDailyStreak = localStorage.getItem('highestDailyStreak'); // Load highest streak
            const storedLastCompletionDate = localStorage.getItem('lastCompletionDate');
            const storedTotalCustomTasksCompleted = localStorage.getItem('totalCustomTasksCompleted');
            const storedUserName = localStorage.getItem('userName');

            if (storedTasks) {
                try {
                    tasks = JSON.parse(storedTasks);
                } catch (e) {
                    console.error("Error parsing stored tasks from Local Storage:", e);
                    tasks = []; // Reset tasks if parsing fails
                }
            }
            if (storedZPoint) {
                zPoint = parseInt(storedZPoint, 10);
                if (isNaN(zPoint)) zPoint = 0; // Ensure it's a number
            }
            if (storedLevel) {
                level = parseInt(storedLevel, 10);
                if (isNaN(level)) level = 1; // Ensure it's a number
            }
            if (storedDailyStreak) {
                dailyStreak = parseInt(storedDailyStreak, 10);
                if (isNaN(dailyStreak)) dailyStreak = 0; // Ensure it's a number
            }
            if (storedHighestDailyStreak) { // Parse highest streak
                highestDailyStreak = parseInt(storedHighestDailyStreak, 10);
                if (isNaN(highestDailyStreak)) highestDailyStreak = 0;
            }
            if (storedTotalCustomTasksCompleted) {
                totalCustomTasksCompleted = parseInt(storedTotalCustomTasksCompleted, 10);
                if (isNaN(totalCustomTasksCompleted)) totalCustomTasksCompleted = 0; // Ensure it's a number
            }
            if (storedUserName) {
                userName = storedUserName;
            }
            // Handle 'null' string from localStorage
            if (storedLastCompletionDate && storedLastCompletionDate !== 'null') {
                lastCompletionDate = storedLastCompletionDate;
            } else {
                lastCompletionDate = null; // Explicitly set to null if not found or was 'null' string
            }

            // Check and update daily streak on load
            const today = new Date().toDateString();

            if (lastCompletionDate && lastCompletionDate !== today) {
                const lastDate = new Date(lastCompletionDate);
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);

                // Compare only the date parts for streak
                if (lastDate.toDateString() !== yesterday.toDateString()) { // If not yesterday, reset streak
                    dailyStreak = 0;
                    showMessageBox('Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø´Ù…Ø§ Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø´Ø¯.', 'info'); // Changed message to Persian
                }
                // If it was yesterday, streak has already incremented (on task completion) and no change is needed.
            } else if (!lastCompletionDate) { // If no completion date exists
                dailyStreak = 0;
            }
            highestDailyStreak = Math.max(highestDailyStreak, dailyStreak); // Ensure highest is updated on load too
            saveToLocalStorage(); // Save updated streak if reset
            renderTasks(); // Render tasks immediately after loading
        }

        // Function to create HTML element for a task
        function createTaskElement(task) {
            const taskItem = document.createElement('div');
            // Apply dark mode classes based on task status and importance
            taskItem.className = `task-item flex items-center justify-between p-3 mb-2 sm:p-4 sm:mb-3 rounded-lg shadow-sm transition-all duration-300 ease-in-out
                                ${task.completed ? 'bg-green-100 dark:bg-green-800 border-l-4 border-green-500 dark:border-green-600 line-through text-gray-500 dark:text-gray-400' :
                                task.isPinned ? 'bg-yellow-50 dark:bg-yellow-900 border-l-4 border-yellow-500 dark:border-yellow-600' : // Pinned style
                                task.importance === 'important' ? 'bg-red-50 dark:bg-red-900 border-l-4 border-red-500 dark:border-red-600' :
                                task.importance === 'custom' ? 'bg-purple-50 dark:bg-purple-900 border-l-4 border-purple-500 dark:border-purple-600' :
                                'bg-gray-50 dark:bg-gray-700 border-l-4 border-gray-300 dark:border-gray-600'}`;
            taskItem.dataset.id = task.id;
            taskItem.setAttribute('draggable', !task.completed); // Make draggable only if not completed

            // Determine importance display text
            let importanceText = '';
            let importanceClasses = '';
            if (task.importance === 'important') {
                importanceText = 'Ù…Ù‡Ù…';
                importanceClasses = 'bg-red-200 dark:bg-red-700 text-red-800 dark:text-red-200';
            } else if (task.importance === 'normal') {
                importanceText = 'Ø¹Ø§Ø¯ÛŒ';
                importanceClasses = 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-200';
            } else if (task.importance === 'custom') {
                importanceText = `${task.customPoints} Ù¾ÙˆÛŒÙ†Øª`; // Display custom points as "35 Ù¾ÙˆÛŒÙ†Øª"
                importanceClasses = 'bg-purple-200 dark:bg-purple-700 text-purple-800 dark:text-purple-200';
            }

            taskItem.innerHTML = `
                <div class="flex items-center flex-grow">
                    <input type="checkbox" data-id="${task.id}" ${task.completed ? 'checked' : ''}
                        class="form-checkbox h-5 w-5 text-blue-600 dark:text-blue-400 rounded focus:ring-blue-500 dark:focus:ring-blue-300 ml-2">
                    <div class="task-name-wrapper ml-3 text-base sm:text-lg font-medium ${task.completed ? 'text-gray-500 dark:text-gray-400 line-through' : 'text-gray-800 dark:text-gray-100'}">
                        ${task.isPinned ? `<span class="ml-2 text-yellow-500" title="ÙˆØ¸ÛŒÙÙ‡ Ù¾ÛŒÙ† Ø´Ø¯Ù‡">ğŸ“Œ</span>` : ''}
                        <span class="task-name">${task.name}</span>
                    </div>
                </div>
                <div class="flex items-center space-x-2 space-x-reverse mr-2">
                    <button data-id="${task.id}" data-action="menu"
                        class="three-dot-menu-btn bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 p-2 rounded-full shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400">
                        <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2z"></path>
                        </svg>
                    </button>
                    <span class="task-importance-display text-sm px-2 py-1 rounded-full ${importanceClasses}">
                        ${importanceText}
                    </span>
                </div>
            `;
            return taskItem;
        }

        // Function to render tasks
        function renderTasks() {
            activeTaskList.innerHTML = ''; // Clear existing active tasks
            completedTasksContainer.innerHTML = ''; // Clear existing completed tasks

            // Separate active and completed tasks
            let activeTasks = tasks.filter(task => !task.completed);
            const completedTasks = tasks.filter(task => task.completed);

            // Sort active tasks: pinned first, then maintain their relative order (manual order)
            activeTasks.sort((a, b) => {
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;
                return 0; // Maintain existing order for unpinned tasks
            });

            // Calculate total pages for active tasks
            const activeTotalPages = Math.ceil(activeTasks.length / TASKS_PER_PAGE);
            // Ensure current page is valid and adjust if tasks are removed
            if (activeCurrentPage > activeTotalPages && activeTotalPages > 0) {
                activeCurrentPage = activeTotalPages;
            } else if (activeTotalPages === 0) {
                activeCurrentPage = 1;
            }
            activeCurrentPage = Math.min(Math.max(1, activeCurrentPage), Math.max(1, activeTotalPages));

            // Render active tasks for current page
            const activeStartIndex = (activeCurrentPage - 1) * TASKS_PER_PAGE;
            const activeEndIndex = activeStartIndex + TASKS_PER_PAGE;
            const activeTasksToRender = activeTasks.slice(activeStartIndex, activeEndIndex);

            if (activeTasksToRender.length === 0 && activeTasks.length === 0) {
                const noActiveItem = document.createElement('div');
                noActiveItem.id = 'dynamicNoActiveMessage';
                noActiveItem.className = 'text-gray-500 dark:text-gray-400 text-center py-4';
                noActiveItem.textContent = 'Ø§ÙˆÙ„ÛŒÙ† ÙˆØ¸ÛŒÙÙ‡ ÙØ¹Ø§Ù„ Ø®ÙˆØ¯ Ø±Ø§ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯!';
                activeTaskList.appendChild(noActiveItem);
            } else {
                activeTasksToRender.forEach(task => {
                    activeTaskList.appendChild(createTaskElement(task));
                });
            }

            // Render pagination controls for active tasks
            renderPaginationControls(activeTasksPagination, activeTasks.length, activeCurrentPage, 'active');

            // Calculate total pages for completed tasks
            const completedTotalPages = Math.ceil(completedTasks.length / TASKS_PER_PAGE);
            // Ensure current page is valid and adjust if tasks are removed
            if (completedCurrentPage > completedTotalPages && completedTotalPages > 0) {
                completedCurrentPage = completedTotalPages;
            } else if (completedTotalPages === 0) {
                completedCurrentPage = 1;
            }
            completedCurrentPage = Math.min(Math.max(1, completedCurrentPage), Math.max(1, completedTotalPages));

            // Render completed tasks for current page
            const completedStartIndex = (completedCurrentPage - 1) * TASKS_PER_PAGE;
            const completedEndIndex = completedStartIndex + TASKS_PER_PAGE;
            const completedTasksToRender = completedTasks.slice(completedStartIndex, completedEndIndex);

            if (completedTasksToRender.length === 0 && completedTasks.length === 0) {
                const noCompletedItem = document.createElement('div');
                noCompletedItem.id = 'dynamicNoCompletedMessage';
                noCompletedItem.className = 'text-gray-500 dark:text-gray-400 text-center py-4';
                noCompletedItem.textContent = 'Ù‡Ù†ÙˆØ² ÙˆØ¸ÛŒÙÙ‡ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡â€ŒØ§ÛŒ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯.';
                completedTasksContainer.appendChild(noCompletedItem);
            } else {
                completedTasksToRender.forEach(task => {
                    completedTasksContainer.appendChild(createTaskElement(task));
                });
            }

            // Render pagination controls for completed tasks
            renderPaginationControls(completedTasksPagination, completedTasks.length, completedCurrentPage, 'completed');

            updateGamificationDisplay();
        }

        /**
         * Renders pagination controls for a given task list.
         * @param {HTMLElement} containerElement The DOM element to render controls into.
         * @param {number} totalItems Total number of items in the list.
         * @param {number} currentPage Current page number.
         * @param {'active'|'completed'} listType Type of list ('active' or 'completed').
         */
        function renderPaginationControls(containerElement, totalItems, currentPage, listType) {
            const totalPages = Math.ceil(totalItems / TASKS_PER_PAGE);

            // Hide pagination if only one page or fewer tasks than TASKS_PER_PAGE
            if (totalPages <= 1) {
                containerElement.classList.add('hidden');
                containerElement.innerHTML = ''; // Clear content when hidden
                return;
            } else {
                // Only show pagination if the corresponding section is visible
                // For active tasks, always show if > 1 page. For completed, show only if section is visible.
                if (listType === 'completed' && completedTasksSection.classList.contains('hidden')) {
                    containerElement.classList.add('hidden');
                    containerElement.innerHTML = ''; // Clear content when hidden
                    return;
                }
                containerElement.classList.remove('hidden');
            }

            containerElement.innerHTML = ''; // Clear existing controls

            // Previous button
            const prevBtn = document.createElement('button');
            prevBtn.className = `p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400 ${currentPage === 1 ? 'opacity-50 cursor-not-allowed' : ''}`;
            prevBtn.innerHTML = `<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>`;
            prevBtn.disabled = currentPage === 1;
            prevBtn.title = "ØµÙØ­Ù‡ Ù‚Ø¨Ù„ÛŒ";
            prevBtn.addEventListener('click', () => {
                if (listType === 'active') {
                    activeCurrentPage = Math.max(1, activeCurrentPage - 1);
                } else {
                    completedCurrentPage = Math.max(1, completedCurrentPage - 1);
                }
                renderTasks();
            });
            containerElement.appendChild(prevBtn);

            // Page number display (editable)
            const pageNumberSpan = document.createElement('span');
            pageNumberSpan.className = 'px-3 py-1 rounded-full bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 font-semibold cursor-pointer min-w-[3rem] text-center';
            pageNumberSpan.textContent = currentPage;
            pageNumberSpan.title = `ØµÙØ­Ù‡ ${currentPage} Ø§Ø² ${totalPages}. Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ Ø¯ÙˆØ¨Ø§Ø± Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯.`;
            pageNumberSpan.dataset.listType = listType; // Store list type for event handling

            // Double click to edit page number
            pageNumberSpan.addEventListener('dblclick', () => {
                const input = document.createElement('input');
                input.type = 'number';
                input.className = 'w-12 text-center bg-blue-50 dark:bg-blue-900 text-blue-800 dark:text-blue-100 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-400';
                input.value = currentPage;
                input.min = 1;
                input.max = totalPages;
                input.dataset.originalValue = currentPage; // Store original value

                pageNumberSpan.replaceWith(input);
                input.focus();
                input.select(); // Auto-select the text

                const handleInputBlur = () => {
                    let newPage = parseInt(convertPersianNumbersToEnglish(input.value), 10); // Convert before parsing
                    if (isNaN(newPage) || newPage < 1 || newPage > totalPages) {
                        newPage = parseInt(input.dataset.originalValue, 10); // Revert to original value if invalid
                        showMessageBox(`Ø´Ù…Ø§Ø±Ù‡ ØµÙØ­Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. Ù…Ù‚Ø¯Ø§Ø± Ø¨Ø§ÛŒØ¯ Ø¨ÛŒÙ† Û± ØªØ§ ${totalPages} Ø¨Ø§Ø´Ø¯. Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØµÙØ­Ù‡ ${newPage}.`, 'error');
                    }
                    if (listType === 'active') {
                        activeCurrentPage = newPage;
                    } else {
                        completedCurrentPage = newPage;
                    }
                    renderTasks();
                    input.removeEventListener('blur', handleInputBlur);
                    input.removeEventListener('keydown', handleInputKeydown);
                };

                const handleInputKeydown = (e) => {
                    if (e.key === 'Enter') {
                        input.blur(); // Trigger blur for input processing
                    }
                };

                input.addEventListener('blur', handleInputBlur);
                input.addEventListener('keydown', handleInputKeydown);
            });
            containerElement.appendChild(pageNumberSpan); // Append the span (or input if active)

            // Next button
            const nextBtn = document.createElement('button');
            nextBtn.className = `p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400 ${currentPage === totalPages ? 'opacity-50 cursor-not-allowed' : ''}`;
            nextBtn.innerHTML = `<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>`;
            nextBtn.disabled = currentPage === totalPages;
            prevBtn.title = "ØµÙØ­Ù‡ Ø¨Ø¹Ø¯ÛŒ";
            nextBtn.addEventListener('click', () => {
                if (listType === 'active') {
                    activeCurrentPage = Math.min(totalPages, activeCurrentPage + 1);
                } else {
                    completedCurrentPage = Math.min(totalPages, completedCurrentPage + 1);
                }
                renderTasks();
            });
            containerElement.appendChild(nextBtn);
        }

        // Function to render achievements
        function renderAchievements() {
            achievementsList.innerHTML = ''; // Clear existing achievements
            const unlockedAchievements = achievementsData.filter(achievement => {
                if (achievement.type === 'level') {
                    const levelInfo = levelPointsThresholds.find(l => l.name === achievement.name);
                    return levelInfo && zPoint >= levelInfo.points;
                } else if (achievement.type === 'streak') {
                    return dailyStreak >= achievement.value;
                } else if (achievement.type === 'totalTasks') {
                    return tasks.filter(t => t.completed).length >= achievement.value;
                } else if (achievement.type === 'importantTasks') {
                    return tasks.filter(t => t.completed && t.importance === 'important').length >= achievement.value;
                } else if (achievement.type === 'customTasks') {
                    return totalCustomTasksCompleted >= achievement.value;
                } else if (achievement.type === 'points') {
                    return zPoint >= achievement.value;
                }
                return false;
            });

            if (unlockedAchievements.length === 0) {
                noAchievementsMessage.style.display = 'block';
            } else {
                noAchievementsMessage.style.display = 'none';
                unlockedAchievements.forEach(achievement => {
                    const achievementItem = document.createElement('div');
                    // Apply dark mode classes for achievement items
                    achievementItem.className = `flex items-center bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-full px-4 py-2 shadow-sm text-gray-700 dark:text-gray-200 text-sm clickable-item`;
                    
                    // Remove descriptions from main page display
                    achievementItem.innerHTML = `
                        <span class="text-xl mr-2">${achievement.icon}</span>
                        <span>${achievement.name}</span>
                    `;
                    
                    // Add click listener to show details
                    achievementItem.addEventListener('click', () => showDetailModal(achievement.type, achievement.type === 'level' ? achievement.level : achievement.name));
                    
                    achievementsList.appendChild(achievementItem);
                });
            }
        }

        // Add task
        addTaskBtn.addEventListener('click', () => {
            const taskName = taskInput.value.trim();
            const importance = importanceSelect.value;
            let customPoints = 0;

            if (taskName.length === 0) {
                showMessageBox('Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… ÙˆØ¸ÛŒÙÙ‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.', 'info');
                return;
            }

            if (taskName.length > 15) {
                showMessageBox('Ù…Ù‚Ø¯Ø§Ø± ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² Û±Ûµ Ú©Ø§Ø±Ú©ØªØ± Ø¨Ø§Ø´Ø¯.', 'error'); // Updated error message
                return;
            }

            if (importance === 'custom') {
                const convertedPoints = convertPersianNumbersToEnglish(customPointsInput.value);
                customPoints = parseInt(convertedPoints, 10);
                if (isNaN(customPoints) || customPoints <= 0 || customPoints > MAX_CUSTOM_POINTS) {
                    showMessageBox(`Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ù…Ù‚Ø¯Ø§Ø± Ù…Ø¹ØªØ¨Ø± Ø¨Ø±Ø§ÛŒ Ù¾ÙˆÛŒÙ†Øª Ø³ÙØ§Ø±Ø´ÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ø­Ø¯Ø§Ú©Ø«Ø± ${MAX_CUSTOM_POINTS}).`, 'info');
                    return;
                }
            }

            const newTask = {
                id: Date.now().toString(), // Unique ID for task
                name: taskName,
                completed: false,
                importance: importance,
                customPoints: importance === 'custom' ? customPoints : undefined, // Store custom points if importance is custom
                isPinned: false // New property for pinning
            };
            tasks.push(newTask);
            taskInput.value = ''; // Clear input
            customPointsInput.value = ''; // Clear custom points input
            importanceSelect.value = 'normal'; // Reset importance selection
            customPointsInput.classList.add('hidden'); // Hide custom points input
            saveToLocalStorage(); // Save after adding
            renderTasks(); // Re-render tasks after adding
            showMessageBox('ÙˆØ¸ÛŒÙÙ‡ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯!', 'success');
        });

        // Toggle completed tasks section visibility
        toggleCompletedTasksBtn.addEventListener('click', () => {
            completedTasksSection.classList.toggle('hidden');
            toggleIcon.classList.toggle('rotate-180'); // Rotate arrow icon
            // Re-render pagination controls to update visibility based on section state
            renderPaginationControls(completedTasksPagination, tasks.filter(t => t.completed).length, completedCurrentPage, 'completed');
        });

        // Manage task actions (toggle completion status, delete, edit, save, cancel)
        // Main handler for clicks on task items
        // This function is called by touchend for taps and directly by menu actions
        function handleTaskClick(e) {
            const taskItemElement = e.target.closest('.task-item');
            if (!taskItemElement) return;

            const taskId = taskItemElement.dataset.id;
            const target = e.target;

            // Check if the click was on an interactive child element (checkbox, menu button)
            const isCheckbox = (target.tagName === 'INPUT' && target.type === 'checkbox');
            const isMenuButton = target.closest('.three-dot-menu-btn');
            const action = target.closest('button')?.dataset.action; // Get action from menu button

            if (isCheckbox) {
                // If checkbox is clicked, toggle completion status
                toggleTaskCompletion(taskId, taskItemElement);
            } else if (isMenuButton) {
                // If menu button is clicked, show the action menu
                const task = tasks.find(t => t.id === taskId);
                if (task) {
                    showTaskActionsMenu(taskId, isMenuButton, task.completed);
                }
            } else if (action === 'pin-task' || action === 'unpin-task') {
                pinTask(taskId);
            }
            else {
                // If the task card itself (and not an interactive child) was clicked, toggle completion status
                toggleTaskCompletion(taskId, taskItemElement);
            }
        }

        // Attach event listener to activeTaskList and completedTasksContainer for delegation
        activeTaskList.addEventListener('click', handleTaskClick);
        completedTasksContainer.addEventListener('click', handleTaskClick);


        function toggleTaskCompletion(taskId, taskItemElement) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                const task = tasks[taskIndex];
                let pointsGained = 0;

                if (!task.completed) { // User wants to complete the task
                    task.completed = true;
                    task.isPinned = false; // Unpin task when completed
                    if (task.importance === 'important') {
                        pointsGained = pointsPerImportantTask;
                    } else if (task.importance === 'normal') {
                        pointsGained = pointsPerNormalTask;
                    } else if (task.importance === 'custom' && task.customPoints) {
                        pointsGained = task.customPoints;
                        totalCustomTasksCompleted++; // Increment custom tasks counter
                    }
                    zPoint += pointsGained;
                    showMessageBox(`ÙˆØ¸ÛŒÙÙ‡ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯! +${pointsGained} Ù¾ÙˆÛŒÙ†Øª`, 'success');
                    showPointsGainFeedback(pointsGained, taskItemElement); // Show animation for all completed tasks

                    // Daily streak logic (only on completion)
                    const today = new Date().toDateString();

                    if (!lastCompletionDate) {
                        dailyStreak = 1;
                        showMessageBox('Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø´Ù…Ø§ Ø¢ØºØ§Ø² Ø´Ø¯!', 'info');
                    } else {
                        const lastDate = new Date(lastCompletionDate);
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);

                        if (lastDate.toDateString() === yesterday.toDateString()) {
                            dailyStreak++;
                            showMessageBox(`Ø²Ù†Ø¬ÛŒØ±Ù‡: ${dailyStreak} Ø±ÙˆØ² Ù…ØªÙˆØ§Ù„ÛŒ!`, 'info');
                        } else if (lastDate.toDateString() !== today) {
                            dailyStreak = 1; // Reset if not consecutive and not completed today already
                            showMessageBox('Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø´Ù…Ø§ Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ùˆ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø¢ØºØ§Ø² Ø´Ø¯.', 'info');
                        }
                    }
                    lastCompletionDate = today;
                    highestDailyStreak = Math.max(highestDailyStreak, dailyStreak); // Update highest streak

                    // Re-sort tasks so completed ones are at the end
                    tasks.sort((a, b) => (a.completed === b.completed) ? 0 : a.completed ? 1 : -1);

                } else { // User clicked on a completed task, implying they want to create a new active instance and remove the original completed one
                    // Create a new task based on the completed one
                    const newActiveTask = {
                        id: Date.now().toString(), // New unique ID
                        name: task.name,
                        completed: false, // This new instance is active
                        importance: task.importance,
                        customPoints: task.customPoints,
                        isPinned: false // New tasks are not pinned by default
                    };

                    tasks.push(newActiveTask); // Add the new active task to the end of the tasks array

                    // Now, delete the original completed task from the array
                    tasks.splice(taskIndex, 1); // Remove the original completed task

                    // No points deduction for the original task, as it remains completed.
                    // No change to daily streak for this operation.

                    // Changed message as per user request
                    showMessageBox(`ÙˆØ¸ÛŒÙÙ‡ Ø¨Ø§Ø²Ù†Ø´Ø§Ù†ÛŒ Ø´Ø¯!`, 'success');
                }
                saveToLocalStorage();
                renderTasks();
            }
        }

        // Function to toggle pin status of a task
        function pinTask(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                const task = tasks[taskIndex];
                task.isPinned = !task.isPinned; // Toggle pin status
                saveToLocalStorage();
                renderTasks();
                showMessageBox(`ÙˆØ¸ÛŒÙÙ‡ "${task.name}" ${task.isPinned ? 'Ù¾ÛŒÙ† Ø´Ø¯!' : 'Ø§Ø² Ù¾ÛŒÙ† Ø®Ø§Ø±Ø¬ Ø´Ø¯.'}`, 'info');
            }
        }


        // Function to show the three-dot menu pop-up
        function showTaskActionsMenu(taskId, buttonElement, isCompletedTask) {
            // Close any existing menu
            document.querySelectorAll('.task-action-menu').forEach(menu => menu.remove());

            const menu = document.createElement('div');
            menu.className = 'task-action-menu';
            menu.style.position = 'absolute';
            menu.style.zIndex = '100';
            menu.style.visibility = 'hidden'; // Hide initially to get dimensions

            document.body.appendChild(menu); // Append to get actual width

            const task = tasks.find(t => t.id === taskId);
            let menuHtml = ``;
            if (isCompletedTask) {
                menuHtml = `
                    <button data-action="copy-task">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"></path></svg>
                        Ú©Ù¾ÛŒ
                    </button>
                    <button data-action="delete-task">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        Ø­Ø°Ù
                    </button>
                `;
            } else {
                menuHtml = `
                    <button data-action="edit-task">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                        ÙˆÛŒØ±Ø§ÛŒØ´
                    </button>
                    <button data-action="change-order">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"></path></svg>
                        ØªØºÛŒÛŒØ± Ú†ÛŒØ¯Ù…Ø§Ù†
                    </button>
                    <button data-action="${task.isPinned ? 'unpin-task' : 'pin-task'}">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            ${task.isPinned ?
                                '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14m-5 0l4 4m-4-4l-4 4m-4-4l4-4m-4-4l4 4"></path>' : // Unpin icon (example: broken pin)
                                '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.828 0L6.343 16.657a4 4 0 115.656-5.656l1.414 1.414a1.998 1.998 0 002.828 0l1.414-1.414a4 4 0 115.656 5.656z"></path>' // Pin icon (example: standard pin)
                            }
                        </svg>
                        ${task.isPinned ? 'Ø¨Ø±Ø¯Ø§Ø´ØªÙ† Ù¾ÛŒÙ†' : 'Ù¾ÛŒÙ† Ú©Ø±Ø¯Ù†'}
                    </button>
                    <button data-action="delete-task">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        Ø­Ø°Ù
                    </button>
                `;
            }
            menu.innerHTML = menuHtml;

            // Dynamic positioning
            const rect = buttonElement.getBoundingClientRect();
            const padding = 5; // Small padding from screen edges

            // Calculate initial top and left based on button position
            let menuTop = rect.bottom + window.scrollY + 5;
            let menuLeft = rect.left + window.scrollX;

            // Adjust if menu goes off screen to the right (RTL context, so right edge is more important)
            if (menuLeft + menu.offsetWidth > window.innerWidth - padding) {
                menuLeft = window.innerWidth - menu.offsetWidth - padding;
            }
            // Adjust if menu goes off screen to the left
            if (menuLeft < padding) {
                menuLeft = padding;
            }

            // Adjust if menu goes off screen to the bottom
            if (menuTop + menu.offsetHeight > window.innerHeight + window.scrollY - padding) {
                menuTop = rect.top + window.scrollY - menu.offsetHeight - 5;
                if (menuTop < padding + window.scrollY) { // If still off-screen top, place at top with padding
                    menuTop = padding + window.scrollY;
                }
            }

            menu.style.top = `${menuTop}px`;
            menu.style.left = `${menuLeft}px`;
            menu.style.visibility = 'visible'; // Make visible

            // Event listener for menu actions
            menu.addEventListener('click', (e) => {
                const action = e.target.closest('button')?.dataset.action;
                if (action) {
                    menu.remove(); // Close menu after action
                    document.removeEventListener('click', closeMenu); // Remove global listener
                    if (action === 'edit-task') {
                        showEditTaskModal(taskId);
                    } else if (action === 'change-order') {
                        showChangeOrderModal(taskId);
                    } else if (action === 'delete-task') {
                        deleteTask(taskId);
                    } else if (action === 'copy-task') {
                        copyTask(taskId);
                    } else if (action === 'pin-task' || action === 'unpin-task') {
                        pinTask(taskId);
                    }
                }
            });

            // Close menu when clicking outside
            const closeMenu = (e) => {
                // Check if the click was outside the menu and outside the button that opened it
                // Also check if the click target is an interactive element (input, select, button, checkbox)
                // If it's an interactive element, allow its default action to proceed, but still close the menu.
                const isInteractiveElement = e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.type === 'checkbox';

                if (!menu.contains(e.target) && !buttonElement.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            // Add a slight delay to allow the menu to render before attaching the global click listener
            // This prevents the initial click that opens the menu from immediately closing it.
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 50);
        }

        // Function to show the Edit Task Modal
        function showEditTaskModal(taskId) {
            currentTaskBeingEditedId = taskId;
            const task = tasks.find(t => t.id === taskId);
            if (!task) {
                showMessageBox('Ø®Ø·Ø§: ÙˆØ¸ÛŒÙÙ‡ Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ ÛŒØ§ÙØª Ù†Ø´Ø¯.', 'error');
                return;
            }

            editTaskNameInput.value = task.name;
            editTaskNameInput.setAttribute('maxlength', '15'); // Set maxlength here
            editTaskImportanceSelect.value = task.importance;
            if (task.importance === 'custom') {
                editTaskCustomPointsInput.classList.remove('hidden');
                editTaskCustomPointsInput.value = task.customPoints || '';
                editTaskCustomPointsInput.focus(); // Auto-focus when custom is selected
            } else {
                editTaskCustomPointsInput.classList.add('hidden');
                editTaskCustomPointsInput.value = ''; // Clear value when hidden
            }

            editTaskImportanceSelect.onchange = () => {
                if (editTaskImportanceSelect.value === 'custom') {
                    editTaskCustomPointsInput.classList.remove('hidden');
                    editTaskCustomPointsInput.focus(); // Auto-focus when custom is selected
                } else {
                    editTaskCustomPointsInput.classList.add('hidden');
                    editTaskCustomPointsInput.value = ''; // Clear value when hidden
                }
            };
            
            editTaskModal.classList.remove('hidden'); // Ensure modal is not hidden before showing
            void editTaskModal.offsetWidth; // Force reflow
            editTaskModal.classList.add('show');
            editTaskNameInput.focus();
        }

        // Save Edited Task
        saveEditedTaskBtn.addEventListener('click', () => {
            const taskId = currentTaskBeingEditedId;
            const newTaskName = editTaskNameInput.value.trim();
            const newImportance = editTaskImportanceSelect.value;
            let newCustomPoints = undefined;

            if (newTaskName.length === 0) {
                showMessageBox('Ù†Ø§Ù… ÙˆØ¸ÛŒÙÙ‡ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø®Ø§Ù„ÛŒ Ø¨Ø§Ø´Ø¯.', 'info');
                return;
            }

            if (newTaskName.length > 15) {
                showMessageBox('Ù…Ù‚Ø¯Ø§Ø± ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² Û±Ûµ Ú©Ø§Ø±Ú©ØªØ± Ø¨Ø§Ø´Ø¯.', 'error'); // Updated error message
                return;
            }

            if (newImportance === 'custom') {
                const convertedPoints = convertPersianNumbersToEnglish(editTaskCustomPointsInput.value); // FIXED: Added conversion
                newCustomPoints = parseInt(convertedPoints, 10);
                if (isNaN(newCustomPoints) || newCustomPoints <= 0 || newCustomPoints > MAX_CUSTOM_POINTS) {
                    showMessageBox(`Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ù…Ù‚Ø¯Ø§Ø± Ù…Ø¹ØªØ¨Ø± Ø¨Ø±Ø§ÛŒ Ù¾ÙˆÛŒÙ†Øª Ø³ÙØ§Ø±Ø´ÛŒ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ (Ø­Ø¯Ø§Ú©Ø«Ø± ${MAX_CUSTOM_POINTS}).`, 'info');
                    return;
                }
            }

            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                tasks[taskIndex].name = newTaskName;
                tasks[taskIndex].importance = newImportance;
                tasks[taskIndex].customPoints = newCustomPoints;
                saveToLocalStorage();
                renderTasks();
                showMessageBox('ÙˆØ¸ÛŒÙÙ‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙˆÛŒØ±Ø§ÛŒØ´ Ø´Ø¯!', 'success');
                editTaskModal.classList.remove('show');
                setTimeout(() => { // Add timeout to hide after transition
                    editTaskModal.classList.add('hidden');
                }, 50); // Changed to 50ms
            } else {
                showMessageBox('Ø®Ø·Ø§: ÙˆØ¸ÛŒÙÙ‡ Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ ÛŒØ§ÙØª Ù†Ø´Ø¯.', 'error');
            }
        });

        // Cancel Edit Task
        cancelEditTaskBtn.addEventListener('click', () => {
            editTaskModal.classList.remove('show');
            setTimeout(() => { // Add timeout to hide after transition
                editTaskModal.classList.add('hidden');
            }, 50); // Changed to 50ms
            showMessageBox('ÙˆÛŒØ±Ø§ÛŒØ´ ÙˆØ¸ÛŒÙÙ‡ Ù„ØºÙˆ Ø´Ø¯.', 'info');
        });

        // Function to show the Change Order Modal
        function showChangeOrderModal(taskId) {
            currentTaskBeingEditedId = taskId;
            const activeTasks = tasks.filter(t => !t.completed);
            const taskIndex = activeTasks.findIndex(t => t.id === taskId);
            
            if (taskIndex === -1) {
                showMessageBox('Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† ØªØ±ØªÛŒØ¨ ÙˆØ¸Ø§ÛŒÙ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡ ÛŒØ§ ÙˆØ¸ÛŒÙÙ‡ ÛŒØ§ÙØª Ù†Ø´Ø¯Ù‡ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ø§Ø¯.', 'error');
                return;
            }

            changeOrderInput.value = taskIndex + 1; // 1-based index
            changeOrderModal.classList.remove('hidden'); // Ensure modal is not hidden before showing
            void changeOrderModal.offsetWidth; // Force reflow
            changeOrderModal.classList.add('show');
            changeOrderInput.focus();
            changeOrderInput.select(); // Auto-select the text
        }

        // Save Changed Order
        saveChangedOrderBtn.addEventListener('click', () => {
            const taskId = currentTaskBeingEditedId;
            const newPosition = parseInt(convertPersianNumbersToEnglish(changeOrderInput.value), 10);

            const taskIndexInTasks = tasks.findIndex(t => t.id === taskId);
            if (taskIndexInTasks === -1) {
                showMessageBox('Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ØªØ±ØªÛŒØ¨ ÙˆØ¸ÛŒÙÙ‡. ÙˆØ¸ÛŒÙÙ‡ ÛŒØ§ÙØª Ù†Ø´Ø¯.', 'error');
                return;
            }

            const taskToMove = tasks[taskIndexInTasks];

            // Only allow reordering of active tasks
            if (taskToMove.completed) {
                showMessageBox('Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† ØªØ±ØªÛŒØ¨ ÙˆØ¸Ø§ÛŒÙ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡ Ø±Ø§ ØªØºÛŒÛŒØ± Ø¯Ø§Ø¯.', 'error');
                return;
            }

            const activeTasks = tasks.filter(t => !t.completed);
            const taskInActiveTasksIndex = activeTasks.findIndex(t => t.id === taskId);

            if (isNaN(newPosition) || newPosition < 1 || newPosition > activeTasks.length) {
                showMessageBox(`Ù„Ø·ÙØ§Ù‹ ÛŒÚ© Ù…ÙˆÙ‚Ø¹ÛŒØª Ù…Ø¹ØªØ¨Ø± Ø¨ÛŒÙ† 1 Ùˆ ${activeTasks.length} ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.`, 'info');
                return;
            }

            if (taskInActiveTasksIndex > -1) {
                // Remove the task from its current position in the active tasks array
                const [movedTask] = activeTasks.splice(taskInActiveTasksIndex, 1);
                
                // Insert the task at the new desired position in the active tasks array
                activeTasks.splice(newPosition - 1, 0, movedTask);

                // If the task was pinned, unpin it when manually reordered
                if (movedTask.isPinned) {
                    movedTask.isPinned = false;
                    showMessageBox('ÙˆØ¸ÛŒÙÙ‡ Ø§Ø² Ù¾ÛŒÙ† Ø®Ø§Ø±Ø¬ Ø´Ø¯ Ø²ÛŒØ±Ø§ ØªØ±ØªÛŒØ¨ Ø¢Ù† Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø³ØªÛŒ ØªØºÛŒÛŒØ± ÛŒØ§ÙØª.', 'info');
                }

                // Reconstruct the main tasks array to reflect the new order
                const completedTasks = tasks.filter(t => t.completed);
                tasks = [...activeTasks, ...completedTasks]; // Active tasks first, then completed

                saveToLocalStorage();
                renderTasks();
                showMessageBox('ÙˆØ¸ÛŒÙÙ‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù…Ø±ØªØ¨ Ø´Ø¯!', 'success');
                changeOrderModal.classList.remove('show');
                setTimeout(() => { // Add timeout to hide after transition
                    changeOrderModal.classList.add('hidden');
                }, 50); // Changed to 50ms
            } else {
                showMessageBox('Ø®Ø·Ø§ Ø¯Ø± ØªØºÛŒÛŒØ± ØªØ±ØªÛŒØ¨ ÙˆØ¸ÛŒÙÙ‡. ÙˆØ¸ÛŒÙÙ‡ ÛŒØ§ÙØª Ù†Ø´Ø¯ ÛŒØ§ Ù‚Ø¨Ù„Ø§Ù‹ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡ Ø§Ø³Øª.', 'error');
            }
        });

        // Cancel Change Order
        cancelChangeOrderBtn.addEventListener('click', () => {
            changeOrderModal.classList.remove('show');
            setTimeout(() => { // Add timeout to hide after transition
                changeOrderModal.classList.add('hidden');
            }, 50); // Changed to 50ms
            showMessageBox('ØªØºÛŒÛŒØ± ØªØ±ØªÛŒØ¨ Ù„ØºÙˆ Ø´Ø¯.', 'info');
        });

        // Delete Task function (called from menu)
        function deleteTask(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                const taskItemElement = document.querySelector(`.task-item[data-id="${taskId}"]`);
                const taskToDelete = tasks[taskIndex];
                taskToDelete.isPinned = false; // Unpin task when deleted

                // Create a copy of the task with its original index for undo
                const deletedTaskCopy = { ...taskToDelete, originalIndex: taskIndex };

                tasks.splice(taskIndex, 1); // Remove task
                saveToLocalStorage();

                // Delete animation
                if (taskItemElement) {
                    taskItemElement.style.transform = `translateX(-100vw)`;
                    taskItemElement.style.opacity = '0';
                    taskItemElement.addEventListener('transitionend', () => {
                        renderTasks(); // Re-render after animation
                        // Use showMessageBox for undo message
                        showMessageBox(`ÙˆØ¸ÛŒÙÙ‡ "${deletedTaskCopy.name}" Ø­Ø°Ù Ø´Ø¯. Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ø¶Ø±Ø¨Ù‡ Ø¨Ø²Ù†ÛŒØ¯.`, 'info', {
                            position: 'bottom-center',
                            isUndo: true,
                            duration: 5000,
                            taskData: deletedTaskCopy // Pass the specific task data for undo
                        });
                    }, { once: true });
                } else {
                    // If element not found, still delete from data and re-render
                    renderTasks();
                    showMessageBox(`ÙˆØ¸ÛŒÙÙ‡ "${deletedTaskCopy.name}" Ø­Ø°Ù Ø´Ø¯. Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù† Ø¶Ø±Ø¨Ù‡ Ø¨Ø²Ù†ÛŒØ¯.`, 'info', {
                        position: 'bottom-center',
                        isUndo: true,
                        duration: 5000,
                        taskData: deletedTaskCopy // Pass the specific task data for undo
                    });
                }
            } else {
                showMessageBox('Ø®Ø·Ø§: ÙˆØ¸ÛŒÙÙ‡ Ø¨Ø±Ø§ÛŒ Ø­Ø°Ù ÛŒØ§ÙØª Ù†Ø´Ø¯.', 'error');
            }
        }

        // Copy Task function (for completed tasks)
        function copyTask(taskId) {
            const originalTask = tasks.find(t => t.id === taskId);
            if (originalTask) {
                const newTask = {
                    id: Date.now().toString(), // New unique ID
                    name: originalTask.name,
                    completed: false, // Always active
                    importance: originalTask.importance,
                    customPoints: originalTask.customPoints, // Keep original custom points
                    isPinned: false // New task is never pinned by default
                };
                tasks.push(newTask); // Add to the end of the list
                saveToLocalStorage();
                renderTasks();
                showMessageBox(`ÙˆØ¸ÛŒÙÙ‡ "${newTask.name}" Ø¨Ù‡ ÙˆØ¸Ø§ÛŒÙ ÙØ¹Ø§Ù„ Ú©Ù¾ÛŒ Ø´Ø¯!`, 'success');
            } else {
                showMessageBox('Ø®Ø·Ø§: ÙˆØ¸ÛŒÙÙ‡ Ø§ØµÙ„ÛŒ Ø¨Ø±Ø§ÛŒ Ú©Ù¾ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯.', 'error');
            }
        }

        // --- Drag and Drop Logic (Mouse Events) ---
        activeTaskList.addEventListener('dragstart', (e) => {
            const taskItem = e.target.closest('.task-item');
            // Ensure only active tasks are draggable and prevent dragging completed tasks
            if (taskItem && !taskItem.classList.contains('bg-green-100')) { 
                draggedTaskId = taskItem.dataset.id;
                draggedElement = taskItem;
                e.dataTransfer.setData('text/plain', draggedTaskId);
                e.dataTransfer.effectAllowed = 'move';
                setTimeout(() => {
                    taskItem.classList.add('opacity-0'); // Hide original element during drag
                }, 0);
            } else {
                e.preventDefault(); // Prevent drag if not an active task
            }
        });

        activeTaskList.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow dropping
            e.dataTransfer.dropEffect = 'move';
            const targetItem = e.target.closest('.task-item');

            // Clear all existing drop-target highlights
            document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));

            // Only highlight if dropping on an active task and not the dragged task itself
            if (targetItem && targetItem.dataset.id !== draggedTaskId && !targetItem.classList.contains('bg-green-100')) {
                const boundingBox = targetItem.getBoundingClientRect();
                const offset = e.clientY - boundingBox.top;

                if (offset < boundingBox.height / 2) {
                    targetItem.classList.add('drop-target'); // Indicate dropping above
                } else {
                    // Highlight the next active element if dropping below, or the target itself if it's the last
                    let nextActiveTask = null;
                    let current = targetItem.nextElementSibling;
                    while (current) {
                        if (current.classList.contains('task-item') && !current.classList.contains('bg-green-100')) {
                            nextActiveTask = current;
                            break;
                        }
                        current = current.nextElementSibling;
                    }

                    if (nextActiveTask) {
                        nextActiveTask.classList.add('drop-target');
                    } else {
                        targetItem.classList.add('drop-target'); // If no other active item below, highlight target itself
                    }
                }
            }
        });

        activeTaskList.addEventListener('dragleave', (e) => {
            // Remove drop-target from all elements when dragging leaves
            document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
        });

        activeTaskList.addEventListener('drop', (e) => {
            e.preventDefault();
            const dropTargetItem = e.target.closest('.task-item');
            
            // Clean up visual feedback
            document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
            if (draggedElement) {
                draggedElement.classList.remove('opacity-0'); // Show original element again
            }

            if (!dropTargetItem || !draggedTaskId) {
                showMessageBox('Ù‡Ø¯Ù Ø±Ù‡Ø§ Ú©Ø±Ø¯Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª ÛŒØ§ ÙˆØ¸ÛŒÙÙ‡â€ŒØ§ÛŒ Ø¯Ø± Ø­Ø§Ù„ Ú©Ø´ÛŒØ¯Ù† Ù†ÛŒØ³Øª.', 'error');
                resetDragState();
                return;
            }

            const droppedOnTaskId = dropTargetItem.dataset.id;
            const draggedTaskIndex = tasks.findIndex(t => t.id === draggedTaskId);
            const droppedOnTaskIndex = tasks.findIndex(t => t.id === droppedOnTaskId);

            if (draggedTaskIndex === -1 || droppedOnTaskIndex === -1 || draggedTaskId === droppedOnTaskId) {
                // Invalid drag or drop onto self
                showMessageBox('Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù† ÙˆØ¸ÛŒÙÙ‡ Ø±Ø§ Ø§ÛŒÙ†Ø¬Ø§ Ø±Ù‡Ø§ Ú©Ø±Ø¯.', 'error');
                resetDragState();
                return;
            }

            // Ensure we only reorder active tasks
            if (tasks[draggedTaskIndex].completed || tasks[droppedOnTaskIndex].completed) {
                showMessageBox('ÙÙ‚Ø· ÙˆØ¸Ø§ÛŒÙ ÙØ¹Ø§Ù„ Ø±Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù† Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ù…Ø±ØªØ¨ Ú©Ø±Ø¯.', 'info');
                resetDragState();
                return;
            }

            // Get active tasks to perform reordering within that subset
            const activeTasks = tasks.filter(task => !task.completed);
            const draggedActiveIndex = activeTasks.findIndex(t => t.id === draggedTaskId);
            const droppedActiveIndex = activeTasks.findIndex(t => t.id === droppedOnTaskId);

            if (draggedActiveIndex === -1 || droppedActiveIndex === -1) {
                 // This should ideally not happen if the above checks are correct, but as a safeguard
                showMessageBox('Ø®Ø·Ø§ Ø¯Ø± ÛŒØ§ÙØªÙ† ÙˆØ¸Ø§ÛŒÙ ÙØ¹Ø§Ù„ Ø¨Ø±Ø§ÛŒ Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ù…Ø¬Ø¯Ø¯.', 'error');
                resetDragState();
                return;
            }

            const [draggedTask] = activeTasks.splice(draggedActiveIndex, 1);
            let newActiveIndex = droppedActiveIndex;

            // Adjust index based on drop position (above or below)
            const boundingBox = dropTargetItem.getBoundingClientRect();
            const offset = e.clientY - boundingBox.top;
            if (offset > boundingBox.height / 2) {
                newActiveIndex++; // Dropped below target
            }

            activeTasks.splice(newActiveIndex, 0, draggedTask);

            // Reconstruct the main tasks array
            const completedTasks = tasks.filter(t => t.completed);
            tasks = [...activeTasks, ...completedTasks];

            saveToLocalStorage();
            renderTasks(); // Re-render to show new order
            showMessageBox('ÙˆØ¸ÛŒÙÙ‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù…Ø±ØªØ¨ Ø´Ø¯!', 'success');
            resetDragState();
        });

        activeTaskList.addEventListener('dragend', (e) => {
            // Clean up dragging classes regardless of drop success
            if (draggedElement) {
                draggedElement.classList.remove('opacity-0');
            }
            document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
            resetDragState();
        });

        function resetDragState() {
            draggedTaskId = null;
            draggedElement = null;
        }

        // --- Drag and Drop Logic (Touch Events) ---
        activeTaskList.addEventListener('touchstart', (e) => {
            const taskItem = e.target.closest('.task-item');
            if (!taskItem) return;

            const targetTagName = e.target.tagName;
            const isInteractiveChild = (targetTagName === 'INPUT' && (e.target.type === 'checkbox' || e.target.type === 'number' || e.target.type === 'text')) ||
                                       targetTagName === 'BUTTON' ||
                                       targetTagName === 'SELECT' ||
                                       e.target.closest('.three-dot-menu-btn');

            if (isInteractiveChild) {
                resetTouchStates(); // Ensure states are clean even if not starting drag
                return; // Let native behavior handle it (e.g., checkbox click, menu button click)
            }

            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchCurrentX = touchStartX;
                touchCurrentY = touchStartY;

                const boundingBox = taskItem.getBoundingClientRect();
                initialTouchOffsetX = e.touches[0].clientX - boundingBox.left;
                initialTouchOffsetY = e.touches[0].clientY - boundingBox.top;

                resetTouchStates(); // Ensure all states are clean before starting a new gesture
                isGestureStarted = true;

                // Only start long press timer if it's an active task (draggable)
                if (!taskItem.classList.contains('bg-green-100')) {
                    longPressTimer = setTimeout(() => {
                        isLongPressDetected = true;
                        isDragging = true;
                        draggedTaskId = taskItem.dataset.id;
                        draggedElement = taskItem;

                        // Create ghost element and hide original
                        ghostElement = taskItem.cloneNode(true);
                        ghostElement.style.position = 'fixed';
                        ghostElement.style.width = boundingBox.width + 'px';
                        ghostElement.style.height = boundingBox.height + 'px';
                        ghostElement.style.pointerEvents = 'none';
                        ghostElement.style.opacity = '0.7';
                        ghostElement.style.zIndex = '1000';
                        ghostElement.classList.add('dragging');
                        document.body.appendChild(ghostElement);

                        ghostElement.style.left = (touchStartX - initialTouchOffsetX) + 'px';
                        ghostElement.style.top = (touchStartY - initialTouchOffsetY) + 'px';
                        ghostElement.style.transform = 'none'; // Clear any previous transforms

                        taskItem.classList.add('opacity-0'); // Hide the original element
                        // Prevent default touch behavior (like scrolling or tap) once dragging is confirmed
                        e.preventDefault(); // Prevent scrolling immediately on long press activation
                    }, DRAG_LONG_PRESS_TIME);
                }
            }
        }, { passive: false }); // Use passive: false to allow e.preventDefault() in touchstart/touchmove

        activeTaskList.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            touchCurrentX = touch.clientX;
            touchCurrentY = touch.clientY;

            const deltaX = touchCurrentX - touchStartX;
            const deltaY = touchCurrentY - touchStartY;

            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);

            // If a gesture has started and significant movement before long press, clear long-press timer
            if (isGestureStarted && !isLongPressDetected && (absDeltaX > TAP_THRESHOLD || absDeltaY > TAP_THRESHOLD)) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
                isGestureStarted = false; // It's a scroll, not a tap or drag attempt
                // Allow native scrolling, don't prevent default here
                return; 
            }

            // If dragging has officially started (long press detected)
            if (isDragging) {
                e.preventDefault(); // Prevent scrolling and other default behaviors
                if (ghostElement) {
                    ghostElement.style.left = (touchCurrentX - initialTouchOffsetX) + 'px';
                    ghostElement.style.top = (touchCurrentY - initialTouchOffsetY) + 'px';

                    // Logic for drop-target highlighting
                    // Temporarily hide ghost to get element under it
                    ghostElement.style.display = 'none';
                    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                    ghostElement.style.display = 'block';

                    document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
                    let closestTaskItem = elementUnderTouch ? elementUnderTouch.closest('.task-item') : null;

                    if (closestTaskItem && closestTaskItem.dataset.id !== draggedTaskId && !closestTaskItem.classList.contains('bg-green-100')) {
                        const boundingBox = closestTaskItem.getBoundingClientRect();
                        const offset = touch.clientY - boundingBox.top;

                        if (offset < boundingBox.height / 2) {
                            closestTaskItem.classList.add('drop-target');
                        } else {
                            let nextActiveTask = null;
                            let current = closestTaskItem.nextElementSibling;
                            while (current) {
                                if (current.classList.contains('task-item') && !current.classList.contains('bg-green-100')) {
                                    nextActiveTask = current;
                                    break;
                                }
                                current = current.nextElementSibling;
                            }
                            if (nextActiveTask) {
                                nextActiveTask.classList.add('drop-target');
                            } else {
                                closestTaskItem.classList.add('drop-target');
                            }
                        }
                    }
                }
            }
        }, { passive: false }); // Use passive: false to allow e.preventDefault()

        activeTaskList.addEventListener('touchend', (e) => {
            clearTimeout(longPressTimer);
            longPressTimer = null;

            if (draggedElement) {
                draggedElement.classList.remove('opacity-0'); // Show original element again
            }
            if (ghostElement) {
                ghostElement.remove(); // Remove ghost element
            }
            document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target')); // Clear drop target highlight

            const absDeltaX = Math.abs(touchCurrentX - touchStartX);
            const absDeltaY = Math.abs(touchCurrentY - touchStartY);

            if (isDragging) { // If a drag operation was in progress
                const elementAtEnd = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                const dropTargetItem = elementAtEnd ? elementAtEnd.closest('.task-item') : null;

                const originalDraggedTaskIndex = tasks.findIndex(t => t.id === draggedTaskId);
                const draggedTask = tasks[originalDraggedTaskIndex];

                if (!dropTargetItem || draggedTask.completed) {
                    // If dropped outside a valid target or on a completed task, revert
                    renderTasks(); // Re-render to revert visual changes
                    showMessageBox('Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ ÙˆØ¸ÛŒÙÙ‡ Ù„ØºÙˆ Ø´Ø¯.', 'info');
                } else if (dropTargetItem.dataset.id === draggedTaskId) {
                    // Dropped on itself, no change
                    renderTasks();
                } else {
                    // Replicate the mouse drop logic for touch
                    const activeTasks = tasks.filter(task => !task.completed);
                    const draggedActiveIndex = activeTasks.findIndex(t => t.id === draggedTaskId);
                    const droppedActiveIndex = activeTasks.findIndex(t => t.id === dropTargetItem.dataset.id);

                    if (draggedActiveIndex === -1 || droppedActiveIndex === -1) {
                        showMessageBox('Ø®Ø·Ø§ Ø¯Ø± ÛŒØ§ÙØªÙ† ÙˆØ¸Ø§ÛŒÙ ÙØ¹Ø§Ù„ Ø¨Ø±Ø§ÛŒ Ù…Ø±ØªØ¨â€ŒØ³Ø§Ø²ÛŒ Ù…Ø¬Ø¯Ø¯ (Ù„Ù…Ø³).', 'error');
                        renderTasks();
                        resetTouchStates();
                        return;
                    }

                    const [movedTask] = activeTasks.splice(draggedActiveIndex, 1);
                    let newActiveIndex = droppedActiveIndex;

                    const boundingBox = dropTargetItem.getBoundingClientRect();
                    const offset = e.changedTouches[0].clientY - boundingBox.top;
                    if (offset > boundingBox.height / 2) {
                        newActiveIndex++; // Dropped below target
                    }
                    activeTasks.splice(newActiveIndex, 0, movedTask);

                    // If the task was pinned, unpin it when manually reordered by drag/drop
                    if (movedTask.isPinned) {
                        movedTask.isPinned = false;
                        showMessageBox('ÙˆØ¸ÛŒÙÙ‡ Ø§Ø² Ù¾ÛŒÙ† Ø®Ø§Ø±Ø¬ Ø´Ø¯ Ø²ÛŒØ±Ø§ ØªØ±ØªÛŒØ¨ Ø¢Ù† Ø¨Ù‡ ØµÙˆØ±Øª Ø¯Ø³ØªÛŒ ØªØºÛŒÛŒØ± ÛŒØ§ÙØª.', 'info');
                    }

                    // Reconstruct the main tasks array
                    const completedTasks = tasks.filter(t => t.completed);
                    tasks = [...activeTasks, ...completedTasks];

                    saveToLocalStorage();
                    renderTasks();
                    showMessageBox('ÙˆØ¸ÛŒÙÙ‡ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ù…Ø±ØªØ¨ Ø´Ø¯!', 'success');
                }
            } else if (isGestureStarted && absDeltaX < TAP_THRESHOLD && absDeltaY < TAP_THRESHOLD) {
                // This was a pure tap (not a drag or swipe, and minimal movement)
                handleTaskClick(e); // Simulate click for tap
            }

            // Reset all flags and element transforms
            resetTouchStates();
            // Ensure task item position is reset visually if it was moved by touchstart/touchmove
            const taskItem = e.target.closest('.task-item');
            if (taskItem) {
                taskItem.style.transform = 'translateX(0)';
            }
        });

        // For completed tasks, only allow tap to toggle completion
        completedTasksContainer.addEventListener('touchstart', (e) => {
            const taskItem = e.target.closest('.task-item');
            if (!taskItem) return;

            const targetTagName = e.target.tagName;
            const isInteractiveChild = (targetTagName === 'INPUT' && (e.target.type === 'checkbox' || e.target.type === 'number' || e.target.type === 'text')) ||
                                       targetTagName === 'BUTTON' ||
                                       targetTagName === 'SELECT' ||
                                       e.target.closest('.three-dot-menu-btn');

            if (isInteractiveChild) {
                resetTouchStates(); // Ensure states are clean even if not starting drag
                return; // Let native behavior handle it
            }

            // No e.preventDefault() here to allow scrolling for completed tasks
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchCurrentX = touchStartX;
            touchCurrentY = touchStartY;
            isGestureStarted = true;
        });

        completedTasksContainer.addEventListener('touchmove', (e) => {
            touchCurrentX = e.touches[0].clientX;
            touchCurrentY = e.touches[0].clientY;
            const absDeltaX = Math.abs(touchCurrentX - touchStartX);
            const absDeltaY = Math.abs(touchCurrentY - touchStartY);

            // If significant movement, it's not a tap
            if (absDeltaX > TAP_THRESHOLD || absDeltaY > TAP_THRESHOLD) {
                isGestureStarted = false; // Not a tap
            }
        });

        completedTasksContainer.addEventListener('touchend', (e) => {
            const taskItem = e.target.closest('.task-item');
            if (!taskItem) {
                resetTouchStates(); // If touch ends outside a task item, reset
                return;
            }

            const absDeltaX = Math.abs(touchCurrentX - touchStartX);
            const absDeltaY = Math.abs(touchCurrentY - touchStartY);

            if (isGestureStarted && absDeltaX < TAP_THRESHOLD && absDeltaY < TAP_THRESHOLD) {
                handleTaskClick(e); // Simulate click for tap
            }
            resetTouchStates(); // Reset for next gesture
        });

        // Helper function to reset all touch-related states
        function resetTouchStates() {
            isDragging = false;
            isGestureStarted = false;
            isLongPressDetected = false;
            draggedTaskId = null;
            draggedElement = null;
            if (ghostElement) {
                ghostElement.remove();
                ghostElement = null;
            }
            touchStartX = 0;
            touchStartY = 0;
            touchCurrentX = 0;
            touchCurrentY = 0;
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }

        // Function to undo a specific deletion
        function undoLastDeletion(taskToRestore) {
            if (taskToRestore) {
                // Find the correct position to re-insert the task
                // If originalIndex is valid and within bounds, try to insert there.
                // Otherwise, add to the end of the active tasks.
                let insertIndex = tasks.length; // Default to end
                if (taskToRestore.originalIndex !== undefined && taskToRestore.originalIndex <= tasks.length) {
                    insertIndex = taskToRestore.originalIndex;
                }

                // Ensure the task is not already present (e.g., if undo was clicked twice quickly)
                if (!tasks.some(t => t.id === taskToRestore.id)) {
                    tasks.splice(insertIndex, 0, taskToRestore);
                    saveToLocalStorage();
                    renderTasks();
                    showMessageBox(`ÙˆØ¸ÛŒÙÙ‡ "${taskToRestore.name}" Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†Ø¯Ù‡ Ø´Ø¯.`, 'info');
                } else {
                    console.warn(`Task with ID ${taskToRestore.id} already exists, not re-adding.`);
                }
            }
        }


        // --- Theme Change Logic ---
        function applyTheme(theme) {
            const htmlElement = document.documentElement;
            if (theme === 'dark') {
                htmlElement.classList.add('dark');
                // Moon icon for dark mode
                themeIcon.innerHTML = `<path d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>`;
            } else {
                htmlElement.classList.remove('dark');
                // Sun icon for light mode
                themeIcon.innerHTML = `<path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.325 6.675l-.707-.707M6.318 6.318l-.707-.707m12.728 0l-.707.707M6.318 17.682l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>`;
            }
            // Re-apply level theme after overall light/dark mode change
            applyLevelTheme(level);
        }

        // Initialize theme on load and listen for system theme changes
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                applyTheme(savedTheme);
            } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                applyTheme('dark');
            } else {
                applyTheme('light');
            }

            // Listen for changes in system's preferred color scheme
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                const newSystemTheme = e.matches ? 'dark' : 'light';
                // Always apply system theme if no specific theme is saved by the user
                applyTheme(newSystemTheme);
            });
        }

        // --- Menu and Modal Logic ---
        menuBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent click from propagating to window and closing dropdown
            menuDropdown.classList.toggle('hidden');
        });

        // Close dropdown when clicking outside
        window.addEventListener('click', (e) => {
            // Check if the click target is within the menu button or the dropdown itself
            const isClickInsideMenu = menuBtn.contains(e.target) || menuDropdown.contains(e.target);
            // Check if the click target is an interactive element outside the menu/button (e.g., a checkbox, another button)
            const isInteractiveElement = e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.type === 'checkbox';

            // Close the menu if the click is outside the menu and its button,
            // AND if the click is not on another interactive element which should be allowed to function.
            // If it's an interactive element, we still want the menu to close, but the element's action to proceed.
            if (!isClickInsideMenu) {
                menuDropdown.classList.add('hidden');
            }
        });


        profileMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Show profile modal with animation
            profileModal.classList.remove('hidden');
            void profileModalContent.offsetWidth; // Force reflow
            profileModalContent.classList.remove('opacity-0', 'scale-95');
            profileModalContent.classList.add('opacity-100', 'scale-100');

            const totalTasks = tasks.length;
            const completedTasksCount = tasks.filter(t => t.completed).length;

            let achievementsHtml = '';
            const unlockedAchievements = achievementsData.filter(achievement => {
                if (achievement.type === 'level') {
                    const levelInfo = levelPointsThresholds.find(l => l.name === achievement.name);
                    return levelInfo && zPoint >= levelInfo.points;
                } else if (achievement.type === 'streak') {
                    return dailyStreak >= achievement.value;
                } else if (achievement.type === 'totalTasks') {
                    return completedTasksCount >= achievement.value;
                } else if (achievement.type === 'importantTasks') {
                    return tasks.filter(t => t.completed && t.importance === 'important').length >= achievement.value;
                } else if (achievement.type === 'customTasks') {
                    return totalCustomTasksCompleted >= achievement.value;
                } else if (achievement.type === 'points') {
                    return zPoint >= achievement.value;
                }
                return false;
            });

            if (unlockedAchievements.length > 0) {
                achievementsHtml = `
                    <h4 class="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2 mt-4">Ø¯Ø³ØªØ§ÙˆØ±Ø¯Ù‡Ø§:</h4>
                    <div class="flex flex-wrap gap-2">
                        ${unlockedAchievements.map(ach => `
                            <span class="flex items-center bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-1 rounded-full text-sm clickable-item" data-type="${ach.type}" data-id="${ach.type === 'level' ? ach.level : ach.name}">
                                <span class="text-xl mr-2">${ach.icon}</span><span>${ach.name}</span>
                            </span>
                        `).join('')}
                    </div>
                `;
            } else {
                achievementsHtml = `<p class="text-gray-500 dark:text-gray-400 mt-4">Ù‡Ù†ÙˆØ² Ø¯Ø³ØªØ§ÙˆØ±Ø¯ÛŒ Ú©Ø³Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.</p>`;
            }

            // Redesigned profile modal body
            profileModalBody.innerHTML = `
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-4">
                    <div class="p-3 rounded-lg shadow-sm bg-blue-50 dark:bg-blue-900 text-blue-800 dark:text-blue-200 flex items-center justify-between">
                        <span class="font-semibold">Ù†Ø§Ù… Ú©Ø§Ø±Ø¨Ø±ÛŒ:</span>
                        <span>${userName || 'Ù†Ø§Ø´Ù†Ø§Ø³'}</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-green-50 dark:bg-green-900 text-green-800 dark:text-green-200 flex items-center justify-between">
                        <span class="font-semibold">Ú©Ù„ ÙˆØ¸Ø§ÛŒÙ:</span>
                        <span>${totalTasks}</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-teal-50 dark:bg-teal-900 text-teal-800 dark:text-teal-200 flex items-center justify-between">
                        <span class="font-semibold">ÙˆØ¸Ø§ÛŒÙ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡:</span>
                        <span>${completedTasksCount}</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-yellow-50 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 flex items-center justify-between">
                        <span class="font-semibold">ØªØ¹Ø¯Ø§Ø¯ Ù¾ÙˆÛŒÙ†Øª:</span>
                        <span>${zPoint}</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-purple-50 dark:bg-purple-900 text-purple-800 dark:text-purple-200 flex items-center justify-between">
                        <span class="font-semibold">Ø³Ø·Ø­:</span>
                        <span>${level}</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-orange-50 dark:bg-orange-900 text-orange-800 dark:text-orange-200 flex items-center justify-between">
                        <span class="font-semibold">Ø²Ù†Ø¬ÛŒØ±Ù‡:</span>
                        <span>${dailyStreak} Ø±ÙˆØ²</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-pink-50 dark:bg-pink-900 text-pink-800 dark:text-pink-200 flex items-center justify-between">
                        <span class="font-semibold">Ø¨ÛŒØ´ØªØ±ÛŒÙ† Ø²Ù†Ø¬ÛŒØ±Ù‡:</span>
                        <span>${highestDailyStreak} Ø±ÙˆØ²</span>
                    </div>
                </div>
                ${achievementsHtml}
            `;

            // Add event listener to newly created clickable items in profile modal
            profileModalBody.querySelectorAll('.clickable-item').forEach(item => {
                item.addEventListener('click', (event) => {
                    const type = event.currentTarget.dataset.type;
                    const id = event.currentTarget.dataset.id;
                    const name = event.currentTarget.dataset.id; // Corrected to use data-id for name
                    if (type === 'level') {
                        showDetailModal('level', id);
                    } else {
                        showDetailModal(type, name);
                    }
                });
            });
        });

        closeProfileModalBtn.addEventListener('click', () => {
            profileModalContent.classList.remove('opacity-100', 'scale-100');
            profileModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                profileModal.classList.add('hidden');
            }, 50); // Changed to 50ms
        });

        helpMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Show help modal with animation
            helpModal.classList.remove('hidden');
            void helpModalContent.offsetWidth; // Force reflow
            helpModalContent.classList.remove('opacity-0', 'scale-95');
            helpModalContent.classList.add('opacity-100', 'scale-100');

            // Dynamically update help modal content with current point values
            helpModalBody.innerHTML = `
                <h3 class="text-xl sm:text-2xl font-bold mb-2 text-blue-600 dark:text-blue-400">Ø¨Ù‡ Ø²ÛŒ ØªØ³Ú© Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯!</h3>
                <p class="mb-3 text-gray-700 dark:text-gray-300">Ø§ÛŒÙ† Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø¨Ù‡ Ø´Ù…Ø§ Ú©Ù…Ú© Ù…ÛŒâ€ŒÚ©Ù†Ø¯ ØªØ§ ÙˆØ¸Ø§ÛŒÙ Ø®ÙˆØ¯ Ø±Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ù†ÛŒØ¯ØŒ Ù¾ÙˆÛŒÙ†Øª Ú©Ø³Ø¨ Ú©Ù†ÛŒØ¯ØŒ Ø³Ø·Ø­ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ø±ØªÙ‚Ø§ Ø¯Ù‡ÛŒØ¯ Ùˆ Ø§Ø² Ø·Ø±ÛŒÙ‚ Ú¯ÛŒÙ…ÛŒÙÛŒÚ©ÛŒØ´Ù† Ø¨Ù‡ Ù†Ù‚Ø§Ø· Ø¹Ø·Ù Ù…Ø®ØªÙ„ÙÛŒ Ø¯Ø³Øª ÛŒØ§Ø¨ÛŒØ¯.</p>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-blue-600 dark:text-blue-400">Ù†Ø­ÙˆÙ‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø¨Ø±Ù†Ø§Ù…Ù‡</h3>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">Ø§ÙØ²ÙˆØ¯Ù† ÙˆØ¸ÛŒÙÙ‡:</strong> Ù†Ø§Ù… ÙˆØ¸ÛŒÙÙ‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ø±Ø¯Ù‡ Ùˆ Ø§Ù‡Ù…ÛŒØª Ø¢Ù† (Ù…Ù‡Ù…/Ø¹Ø§Ø¯ÛŒ/Ø³ÙØ§Ø±Ø´ÛŒ) Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯. ÙˆØ¸Ø§ÛŒÙ Ù…Ù‡Ù… Ùˆ Ø³ÙØ§Ø±Ø´ÛŒ Ù¾ÙˆÛŒÙ†Øª Ø¨ÛŒØ´ØªØ±ÛŒ Ø¨Ù‡ Ø´Ù…Ø§ Ù…ÛŒâ€ŒØ¯Ù‡Ù†Ø¯.</p>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">ØªØºÛŒÛŒØ± ØªØ±ØªÛŒØ¨ ÙˆØ¸Ø§ÛŒÙ:</strong> Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ÙˆØ¸Ø§ÛŒÙ ÙØ¹Ø§Ù„ Ø±Ø§ Ø¨Ø§ Ú©Ø´ÛŒØ¯Ù† Ùˆ Ø±Ù‡Ø§ Ú©Ø±Ø¯Ù† Ù…Ø±ØªØ¨ Ú©Ù†ÛŒØ¯.</p>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">ØªÚ©Ù…ÛŒÙ„ ÙˆØ¸ÛŒÙÙ‡:</strong> Ø¨Ø±Ø§ÛŒ ØªÚ©Ù…ÛŒÙ„ ÛŒÚ© ÙˆØ¸ÛŒÙÙ‡ØŒ Ú©Ø§Ø¯Ø± Ú©Ù†Ø§Ø± Ø¢Ù† Ø±Ø§ Ø¹Ù„Ø§Ù…Øª Ø¨Ø²Ù†ÛŒØ¯. Ø§ÛŒÙ† Ø¨Ù‡ Ø´Ù…Ø§ Ù¾ÙˆÛŒÙ†Øª Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ùˆ ÙˆØ¸ÛŒÙÙ‡ Ø±Ø§ Ø¨Ù‡ Ø¨Ø®Ø´ "ÙˆØ¸Ø§ÛŒÙ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡" Ù…Ù†ØªÙ‚Ù„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯.</p>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">ÙˆÛŒØ±Ø§ÛŒØ´ ÙˆØ¸ÛŒÙÙ‡:</strong> Ø¨Ø±Ø§ÛŒ ÙˆÛŒØ±Ø§ÛŒØ´ Ù†Ø§Ù… Ùˆ Ø§Ù‡Ù…ÛŒØª ÛŒÚ© ÙˆØ¸ÛŒÙÙ‡ØŒ Ø±ÙˆÛŒ Ø¢ÛŒÚ©ÙˆÙ† Ø³Ù‡ Ù†Ù‚Ø·Ù‡ Ú©Ù†Ø§Ø± Ø¢Ù† Ú©Ù„ÛŒÚ© Ú©Ø±Ø¯Ù‡ Ùˆ "ÙˆÛŒØ±Ø§ÛŒØ´" Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ ÛŒØ§ Ø±ÙˆÛŒ Ø®ÙˆØ¯ ÙˆØ¸ÛŒÙÙ‡ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯.</p>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">Ø­Ø°Ù ÙˆØ¸ÛŒÙÙ‡:</strong> Ø¨Ø±Ø§ÛŒ Ø­Ø°Ù ÛŒÚ© ÙˆØ¸ÛŒÙÙ‡ØŒ Ø±ÙˆÛŒ Ø¢ÛŒÚ©ÙˆÙ† Ø³Ù‡ Ù†Ù‚Ø·Ù‡ Ú©Ù†Ø§Ø± Ø¢Ù† Ú©Ù„ÛŒÚ© Ú©Ø±Ø¯Ù‡ Ùˆ "Ø­Ø°Ù" Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.</p>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">ØªØºÛŒÛŒØ± ØªØ±ØªÛŒØ¨ Ø¯Ø³ØªÛŒ:</strong> Ø¨Ø±Ø§ÛŒ ØªØºÛŒÛŒØ± Ø¯Ø³ØªÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª ÛŒÚ© ÙˆØ¸ÛŒÙÙ‡ØŒ Ø±ÙˆÛŒ Ø¢ÛŒÚ©ÙˆÙ† Ø³Ù‡ Ù†Ù‚Ø·Ù‡ Ú©Ù†Ø§Ø± Ø¢Ù† Ú©Ù„ÛŒÚ© Ú©Ø±Ø¯Ù‡ Ùˆ "ØªØºÛŒÛŒØ± ØªØ±ØªÛŒØ¨" Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.</p>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">ÙˆØ¸Ø§ÛŒÙ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡:</strong> Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯ ØªØ§ ÙˆØ¸Ø§ÛŒÙ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡ Ø®ÙˆØ¯ Ø±Ø§ Ù†Ù…Ø§ÛŒØ´ ÛŒØ§ Ù¾Ù†Ù‡Ø§Ù† Ú©Ù†ÛŒØ¯.</p>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-blue-600 dark:text-blue-400">Ø³ÛŒØ³ØªÙ… Ú¯ÛŒÙ…ÛŒÙÛŒÚ©ÛŒØ´Ù†</h3>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">Ù¾ÙˆÛŒÙ†Øª:</strong>
                    Ù¾ÙˆÛŒÙ†Øªâ€ŒÙ‡Ø§ ØµØ±ÙØ§Ù‹ Ù†Ù…Ø§Ø¯ÛŒÙ† Ù‡Ø³ØªÙ†Ø¯ Ùˆ Ø¨Ø±Ø§ÛŒ Ø§Ù†Ø¯Ø§Ø²Ù‡â€ŒÚ¯ÛŒØ±ÛŒ Ù¾ÛŒØ´Ø±ÙØª Ùˆ ÙØ¹Ø§Ù„ÛŒØª Ø´Ù…Ø§ Ø¯Ø± Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.
                    <ul>
                        <li>ÙˆØ¸Ø§ÛŒÙ Ø¹Ø§Ø¯ÛŒ: ${pointsPerNormalTask} Ù¾ÙˆÛŒÙ†Øª</li>
                        <li>ÙˆØ¸Ø§ÛŒÙ Ù…Ù‡Ù…: ${pointsPerImportantTask} Ù¾ÙˆÛŒÙ†Øª</li>
                        <li>ÙˆØ¸Ø§ÛŒÙ Ø³ÙØ§Ø±Ø´ÛŒ: ØªØ§ ${MAX_CUSTOM_POINTS} Ù¾ÙˆÛŒÙ†Øª</li>
                    </ul>
                </p>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø±ÙˆØ²Ø§Ù†Ù‡:</strong> ØªÚ©Ù…ÛŒÙ„ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© ÙˆØ¸ÛŒÙÙ‡ Ø¯Ø± Ø±ÙˆØ²Ù‡Ø§ÛŒ Ù…ØªÙˆØ§Ù„ÛŒØŒ Ø²Ù†Ø¬ÛŒØ±Ù‡ Ø±ÙˆØ²Ø§Ù†Ù‡ Ø´Ù…Ø§ Ø±Ø§ Ø§ÙØ²Ø§ÛŒØ´ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ùˆ Ø¨Ù‡ Ø´Ù…Ø§ Ø§Ù…Ú©Ø§Ù† Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ø¯Ø³ØªØ§ÙˆØ±Ø¯Ù‡Ø§ÛŒ ÙˆÛŒÚ˜Ù‡â€ŒØ§ÛŒ Ú©Ø³Ø¨ Ú©Ù†ÛŒØ¯.</p>
                
                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-blue-600 dark:text-blue-400">Ø³Ø·ÙˆØ­ Ùˆ ØªÙ…â€ŒÙ‡Ø§ÛŒ Ø±Ù†Ú¯ÛŒ</h3>
                <p class="mb-2 text-gray-700 dark:text-gray-300">Ø¨Ø§ Ú©Ø³Ø¨ Ù¾ÙˆÛŒÙ†ØªØŒ Ø¨Ù‡ Ø³Ø·ÙˆØ­ Ø¨Ø§Ù„Ø§ØªØ± ØµØ¹ÙˆØ¯ Ø®ÙˆØ§Ù‡ÛŒØ¯ Ú©Ø±Ø¯. Ù‡Ø± Ø³Ø·Ø­ Ø¯Ø§Ø±Ø§ÛŒ ÛŒÚ© ØªÙ… Ø±Ù†Ú¯ÛŒ Ù…Ù†Ø­ØµØ± Ø¨Ù‡ ÙØ±Ø¯ Ø§Ø³Øª Ú©Ù‡ Ø¨Ø§ Ù¾ÛŒØ´Ø±ÙØª Ø´Ù…Ø§ ØªØºÛŒÛŒØ± Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ø¨Ø±Ø§ÛŒ Ø¬Ø²Ø¦ÛŒØ§Øª Ø¨ÛŒØ´ØªØ± Ø±ÙˆÛŒ ÛŒÚ© Ø³Ø·Ø­ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯:</p>
                <div class="flex flex-wrap gap-2 mb-3">
                    ${levelPointsThresholds.map((levelInfo, index) => {
                        return `
                            <span class="bg-blue-100 dark:bg-blue-700 text-blue-800 dark:text-blue-200 px-3 py-1 rounded-full text-sm flex items-center clickable-item" data-type="level" data-id="${index + 1}">
                                Ø³Ø·Ø­ ${index + 1}: ${levelInfo.name}
                            </span>
                        `;
                    }).join('')}
                </div>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-blue-600 dark:text-blue-400">Ø¯Ø³ØªØ§ÙˆØ±Ø¯Ù‡Ø§</h3>
                <p class="mb-2 text-gray-700 dark:text-gray-300">Ø¨Ø§ Ù¾ÛŒØ´Ø±ÙØª Ø¯Ø± Ø¨Ø§Ø²ÛŒØŒ Ø¯Ø³ØªØ§ÙˆØ±Ø¯Ù‡Ø§ÛŒ Ù…Ø®ØªÙ„ÙÛŒ Ú©Ø³Ø¨ Ø®ÙˆØ§Ù‡ÛŒØ¯ Ú©Ø±Ø¯. Ø¨Ø±Ø§ÛŒ Ø¬Ø²Ø¦ÛŒØ§Øª Ø¨ÛŒØ´ØªØ± Ø±ÙˆÛŒ ÛŒÚ© Ø¯Ø³ØªØ§ÙˆØ±Ø¯ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯:</p>
                <div class="flex flex-wrap gap-2 mb-3">
                    ${achievementsData.map(ach => {
                        // Only list non-level achievements here
                        if (ach.type !== 'level') {
                            return `<span class="bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-1 rounded-full text-sm flex items-center clickable-item" data-type="achievement" data-name="${ach.name}">${ach.icon} <span class="mr-1">${ach.name}</span></span>`;
                        }
                        return '';
                    }).join('')}
                </div>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-blue-600 dark:text-blue-400">Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ Ùˆ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§</h3>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">Ø§Ù…Ù†ÛŒØª Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§:</strong> ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø´Ù…Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø§Ù…Ù† Ø¯Ø± Ø­Ø§ÙØ¸Ù‡ Ù…Ø­Ù„ÛŒ Ù…Ø±ÙˆØ±Ú¯Ø± Ø´Ù…Ø§ Ø°Ø®ÛŒØ±Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ Ùˆ Ù‡ÛŒÚ† Ø§Ø·Ù„Ø§Ø¹Ø§ØªÛŒ Ø¨Ù‡ Ù‡ÛŒÚ† Ø³Ø±ÙˆØ±ÛŒ Ø§Ø±Ø³Ø§Ù„ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯.</p>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">Ù¾Ø´ØªÛŒØ¨Ø§Ù†â€ŒÚ¯ÛŒØ±ÛŒ (Ø®Ø±ÙˆØ¬ÛŒ Ú¯Ø±ÙØªÙ†):</strong> Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¨Ø§ Ú©Ù„ÛŒÚ© Ø¨Ø± Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ "Ø°Ø®ÛŒØ±Ù‡ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§"ØŒ ÛŒÚ© ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù† JSON Ø§Ø² ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø®ÙˆØ¯ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ú©Ù†ÛŒØ¯. Ø§ÛŒÙ† ÙØ§ÛŒÙ„ Ø±Ø§ Ø¯Ø± Ù…Ú©Ø§Ù†ÛŒ Ø§Ù…Ù† Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ Ú©Ù†ÛŒØ¯.</p>
                <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ (ÙˆØ±ÙˆØ¯ÛŒ Ú¯Ø±ÙØªÙ†):</strong> Ø¨Ø±Ø§ÛŒ Ø¨Ø§Ø²ÛŒØ§Ø¨ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ØŒ Ø¨Ù‡ Ø³Ø§Ø¯Ú¯ÛŒ ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù† JSON Ø±Ø§ Ú©Ù‡ Ù‚Ø¨Ù„Ø§Ù‹ Ø¯Ø§Ù†Ù„ÙˆØ¯ Ú©Ø±Ø¯Ù‡â€ŒØ§ÛŒØ¯ Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø¨Ø®Ø´ "Ø§Ù†ØªØ®Ø§Ø¨ ÙØ§ÛŒÙ„" Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯ØŒ Ø³Ù¾Ø³ Ø±ÙˆÛŒ Ø¯Ú©Ù…Ù‡ "Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø§Ø² ÙØ§ÛŒÙ„" Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯. Ø§ÛŒÙ† Ú©Ø§Ø± Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ ÙØ¹Ù„ÛŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø´Ù…Ø§ Ø±Ø§ Ø¨Ø§ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯ Ø¯Ø± ÙØ§ÛŒÙ„ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ù…ÛŒâ€ŒÚ©Ù†Ø¯.</p>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-blue-600 dark:text-blue-400">Ø¯ÙˆÙ†ÛŒØª</h3>
                <p class="mb-2 text-gray-700 dark:text-gray-300">Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª. Ø§Ø² Ø¹Ù„Ø§Ù‚Ù‡ Ø´Ù…Ø§ Ø³Ù¾Ø§Ø³Ú¯Ø²Ø§Ø±ÛŒÙ…!</p>

                <p class="mt-4 text-center text-gray-700 dark:text-gray-300">Ù‡Ø¯Ù Ø§ÛŒÙ† Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø§Ù†Ú¯ÛŒØ²Ù‡ Ø¯Ø§Ø¯Ù† Ø¨Ù‡ Ø´Ù…Ø§ Ùˆ Ú©Ù…Ú© Ø¨Ù‡ Ø³Ø§Ø²Ù…Ø§Ù†Ø¯Ù‡ÛŒ Ø¨Ù‡ØªØ± ÙˆØ¸Ø§ÛŒÙ Ø´Ù…Ø§Ø³Øª. Ù…ÙˆÙÙ‚ Ø¨Ø§Ø´ÛŒØ¯!</p>
            `;
            // Add event listener to newly created clickable items in help modal
            helpModalBody.querySelectorAll('.clickable-item').forEach(item => {
                item.addEventListener('click', (event) => {
                    const type = event.currentTarget.dataset.type;
                    const id = event.currentTarget.dataset.id;
                    const name = event.currentTarget.dataset.name;
                    if (type === 'level') {
                        showDetailModal('level', id);
                    } else {
                        showDetailModal(type, name);
                    }
                });
            });
        });

        closeHelpModalBtn.addEventListener('click', () => {
            helpModalContent.classList.remove('opacity-100', 'scale-95');
            helpModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                helpModal.classList.add('hidden');
            }, 50); // Changed to 50ms
        });

        aboutMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Show about modal with animation
            aboutModal.classList.remove('hidden');
            void aboutModalContent.offsetWidth; // Force reflow
            aboutModalContent.classList.remove('opacity-0', 'scale-95');
            aboutModalContent.classList.add('opacity-100', 'scale-100');

            aboutModalBody.innerHTML = `
                <p class="mb-3">Ø§ÛŒÙ† Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø¨Ø±Ø§ÛŒ Ú©Ù…Ú© Ø¨Ù‡ Ù…Ø¯ÛŒØ±ÛŒØª ÙˆØ¸Ø§ÛŒÙ Ùˆ Ø§ÙØ²Ø§ÛŒØ´ Ø§Ù†Ú¯ÛŒØ²Ù‡ Ø·Ø±Ø§Ø­ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª.</p>
                <p class="mb-3">Ø§ÛŒÙ† Ù¾Ø±ÙˆÚ˜Ù‡ Ø¨Ù‡ ØµÙˆØ±Øª Ø§Ø®ØªØµØ§ØµÛŒ ØªÙˆØ³Ø· <strong class="text-blue-600 dark:text-blue-400"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">Ø³Ø§ÛŒØª Ø¹Ù…Ùˆ Ù„Ø¦Ùˆ</a></strong> Ø·Ø±Ø§Ø­ÛŒ Ø´Ø¯Ù‡ Ø§Ø³ØªØŒ Ø§ÛŒÙ† Ø¢ÙˆÙ„ÛŒÙ† Ùˆ Ø¢Ø®Ø±ÛŒÙ† Ù†Ø³Ø®Ù‡ Ø§Ø² Ø§Ø² Ø§ÛŒÙ† Ù¾Ø±ÙˆÚ˜Ù‡ Ø§Ø³Øª.</p>
                <p class="mb-3">ØªÙ…Ø§Ù…ÛŒ Ø­Ù‚ÙˆÙ‚ Ù…ØªØ¹Ù„Ù‚ Ø¨Ù‡ <strong class="text-blue-600 dark:text-blue-400"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">Ø¹Ù…Ùˆ Ù„Ø¦Ùˆ</a></strong> Ø§Ø³Øª.</p>
                <p class="mb-3">ØªØ§Ø±ÛŒØ®: Û´ Ø®Ø±Ø¯Ø§Ø¯ Û±Û´Û°Û´</p>
            `;
        });

        closeAboutModalBtn.addEventListener('click', () => {
            aboutModalContent.classList.remove('opacity-100', 'scale-95');
            aboutModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                aboutModal.classList.add('hidden');
            }, 50); // Changed to 50ms
        });

        backupMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Show backup modal with animation
            backupModal.classList.remove('hidden');
            void backupModalContent.offsetWidth; // Force reflow
            backupModalContent.classList.remove('opacity-0', 'scale-95');
            backupModalContent.classList.add('opacity-100', 'scale-100');

            importFileInput.value = ''; // Clear file input on open
            selectedFileNameSpan.textContent = 'ÙØ§ÛŒÙ„ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.';
        });

        // Add listener to close backup modal button
        closeBackupModalBtn.addEventListener('click', () => {
            backupModalContent.classList.remove('opacity-100', 'scale-95');
            backupModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                backupModal.classList.add('hidden');
            }, 50); // Changed to 50ms
        });

        donateMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            // const donateLink = "YOUR_DONATION_LINK_HERE"; // TODO: Replace with actual donation link
            // window.open(donateLink, '_blank');
            showMessageBox('Ø§ÛŒÙ† Ø¨Ø®Ø´ Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± ØºÛŒØ±ÙØ¹Ø§Ù„ Ø§Ø³Øª. Ø§Ø² Ø¹Ù„Ø§Ù‚Ù‡ Ø´Ù…Ø§ Ø³Ù¾Ø§Ø³Ú¯Ø²Ø§Ø±ÛŒÙ…!', 'info');
            menuDropdown.classList.add('hidden'); // Hide dropdown after selection
        });

        resetMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // Hide dropdown

            // Show reset confirmation modal with animation
            resetConfirmModal.classList.remove('hidden');
            void resetConfirmModalContent.offsetWidth; // Force reflow
            resetConfirmModalContent.classList.remove('opacity-0', 'scale-95');
            resetConfirmModalContent.classList.add('opacity-100', 'scale-100');
        });

        confirmResetBtn.addEventListener('click', () => {
            localStorage.clear(); // Clear all data from local storage
            location.reload(); // Reload page to reset application
        });

        cancelResetBtn.addEventListener('click', () => {
            resetConfirmModalContent.classList.remove('opacity-100', 'scale-95');
            resetConfirmModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                resetConfirmModal.classList.add('hidden');
            }, 50); // Changed to 50ms
        });

        closeResetModalBtn.addEventListener('click', () => {
            resetConfirmModalContent.classList.remove('opacity-100', 'scale-95');
            resetConfirmModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                resetConfirmModal.classList.add('hidden');
            }, 50); // Changed to 50ms
        });

        // Welcome modal logic
        startBtn.addEventListener('click', () => {
            const inputName = userNameInput.value.trim();
            if (inputName.length === 0) {
                showMessageBox('Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.', 'info');
                return;
            }
            if (inputName.length > 15) {
                showMessageBox('Ù…Ù‚Ø¯Ø§Ø± ÙˆØ±ÙˆØ¯ÛŒ Ù†Ø¨Ø§ÛŒØ¯ Ø¨ÛŒØ´ØªØ± Ø§Ø² Û±Ûµ Ú©Ø§Ø±Ú©ØªØ± Ø¨Ø§Ø´Ø¯.', 'error'); // Added validation for length
                return;
            }

            userName = inputName;
            saveToLocalStorage();
            welcomeModalContent.classList.remove('opacity-100', 'scale-100');
            welcomeModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                welcomeModal.classList.add('hidden');
            }, 50); // Changed to 50ms
            showMessageBox(`Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯ØŒ ${userName}!`, 'success');
        });

        // Export data (download as file)
        exportDataBtn.addEventListener('click', () => {
            const dataToSave = {
                tasks: tasks,
                zPoint: zPoint,
                level: level,
                dailyStreak: dailyStreak,
                highestDailyStreak: highestDailyStreak, // Include highest streak in export
                lastCompletionDate: lastCompletionDate,
                totalCustomTasksCompleted: totalCustomTasksCompleted,
                userName: userName
            };
            const jsonString = JSON.stringify(dataToSave, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            const date = new Date();
            const dateString = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
            a.download = `tasks_backup_${dateString}_zitask.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // Clean up URL object
            showMessageBox('ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¯Ø§Ù†Ù„ÙˆØ¯ Ø´Ø¯!', 'success');
        });

        // Update selected file name display
        importFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                selectedFileNameSpan.textContent = e.target.files[0].name;
            } else {
                selectedFileNameSpan.textContent = 'ÙØ§ÛŒÙ„ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.';
            }
        });

        // Import data (load from file)
        importDataBtn.addEventListener('click', () => {
            const file = importFileInput.files[0];
            if (!file) {
                showMessageBox('Ù„Ø·ÙØ§Ù‹ ÛŒÚ© ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù† Ø¨Ø±Ø§ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.', 'info');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const dataString = e.target.result;
                    const importedData = JSON.parse(dataString);

                    // Basic validation of imported data structure
                    if (
                        typeof importedData.tasks === 'object' && Array.isArray(importedData.tasks) &&
                        typeof importedData.zPoint === 'number' &&
                        typeof importedData.level === 'number' &&
                        typeof importedData.dailyStreak === 'number' &&
                        (typeof importedData.highestDailyStreak === 'number' || typeof importedData.highestDailyStreak === 'undefined') && // Validate highest streak
                        (typeof importedData.lastCompletionDate === 'string' || importedData.lastCompletionDate === null) &&
                        typeof importedData.totalCustomTasksCompleted === 'number' &&
                        (typeof importedData.userName === 'string' || importedData.userName === null || importedData.userName === undefined)
                    ) {
                        tasks = importedData.tasks;
                        zPoint = importedData.zPoint;
                        level = importedData.level;
                        dailyStreak = importedData.dailyStreak;
                        highestDailyStreak = importedData.highestDailyStreak || 0; // Set highest streak, default to 0 if undefined
                        lastCompletionDate = importedData.lastCompletionDate;
                        totalCustomTasksCompleted = importedData.totalCustomTasksCompleted;
                        userName = importedData.userName || null; // Ensure userName is set or null

                        // Ensure imported tasks have the new 'isPinned' property
                        tasks.forEach(task => {
                            if (typeof task.isPinned === 'undefined') {
                                task.isPinned = false;
                            }
                        });

                        saveToLocalStorage(); // Save imported data to local storage
                        renderTasks(); // Re-render UI with new data
                        
                        // Hide backup modal with animation
                        backupModalContent.classList.remove('opacity-100', 'scale-95');
                        backupModalContent.classList.add('opacity-0', 'scale-95');
                        setTimeout(() => {
                            backupModal.classList.add('hidden');
                        }, 50); // Changed to 50ms
                        showMessageBox('Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯Ù†Ø¯!', 'success');
                    } else {
                        showMessageBox('ÙØ±Ù…Øª Ø¯Ø§Ø¯Ù‡ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡ Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ ÛŒÚ© ÙØ§ÛŒÙ„ Ù¾Ø´ØªÛŒØ¨Ø§Ù† Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.', 'error');
                    }
                } catch (error) {
                    console.error("Error parsing imported data:", error);
                    showMessageBox('Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ ÙØ§ÛŒÙ„ ÙˆØ§Ø±Ø¯ Ø´Ø¯Ù‡. Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø­Ø§ØµÙ„ Ú©Ù†ÛŒØ¯ Ú©Ù‡ ÙØ§ÛŒÙ„ JSON ØµØ­ÛŒØ­ Ø§Ø³Øª.', 'error');
                }
            };
            reader.onerror = (e) => {
                console.error("Error reading file:", e);
                showMessageBox('Ø®Ø·Ø§ Ø¯Ø± Ø®ÙˆØ§Ù†Ø¯Ù† ÙØ§ÛŒÙ„. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ø§Ù…ØªØ­Ø§Ù† Ú©Ù†ÛŒØ¯.', 'error');
            };
            reader.readAsText(file);
        });

        // --- Level/Achievement Detail Modal Logic ---
        function showDetailModal(type, identifier) {
            detailModal.classList.remove('hidden');
            void detailModalContent.offsetWidth; // Force reflow
            // Add animation classes for modal entry
            detailModalContent.classList.remove('opacity-0', 'scale-95');
            detailModalContent.classList.add('opacity-100', 'scale-100');

            let contentHtml = '';
            let titleText = ''; 

            if (type === 'level') {
                const levelNum = parseInt(identifier, 10);
                const levelInfo = levelPointsThresholds[levelNum - 1];
                const themeData = levelThemes[levelNum - 1]; // Get theme data for level

                titleText = levelInfo.name;

                contentHtml = `
                    <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">ØªÙˆØ¶ÛŒØ­Ø§Øª:</strong> Ø¨Ø±Ø§ÛŒ Ø±Ø³ÛŒØ¯Ù† Ø¨Ù‡ Ø§ÛŒÙ† Ø³Ø·Ø­ØŒ Ø´Ù…Ø§ Ø¨Ù‡ ${levelInfo.points} Ù¾ÙˆÛŒÙ†Øª Ù†ÛŒØ§Ø² Ø¯Ø§Ø±ÛŒØ¯. ØªÙ… Ø±Ù†Ú¯ÛŒ Ú©Ù„ÛŒ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø³Ø·Ø­ ${themeData.description} Ø§Ø³Øª.</p>
                `;
            } else { // This else block now covers all non-level types like 'totalTasks', 'importantTasks', etc.
                const achievement = achievementsData.find(ach => ach.name === identifier);
                
                if (achievement) {
                    titleText = achievement.name;
                    contentHtml = `
                        <p class="mb-2"><strong class="text-purple-600 dark:text-purple-400">ØªÙˆØ¶ÛŒØ­Ø§Øª:</strong> ${achievement.description || 'ØªÙˆØ¶ÛŒØ­Ø§Øª Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª.'}</p>
                    `;
                } else {
                    titleText = `Ø®Ø·Ø§`;
                    contentHtml = `<p class="text-red-500">Ø¯Ø³ØªØ§ÙˆØ±Ø¯ ÛŒØ§ÙØª Ù†Ø´Ø¯.</p>`;
                }
            }

            detailModalTitle.textContent = titleText;
            detailModalBody.innerHTML = contentHtml;
        }

        closeDetailModalBtn.addEventListener('click', () => {
            detailModalContent.classList.remove('opacity-100', 'scale-95');
            detailModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                detailModal.classList.add('hidden');
            }, 50); // Changed to 50ms
        });

        // Add click listener to show current level on main page
        currentLevelDisplay.addEventListener('click', () => showDetailModal('level', level));


        // --- Enter Key Logic ---
        // Helper function to find the next focusable element within a container
        function getNextFocusableElement(currentElement, container) {
            const focusableElements = Array.from(container.querySelectorAll('input:not([type="hidden"]), select, button:not([disabled])'));
            const currentIndex = focusableElements.indexOf(currentElement);
            
            // Filter out elements that are currently hidden by CSS (e.g., customPointsInput)
            const visibleFocusableElements = focusableElements.filter(el => {
                const style = window.getComputedStyle(el);
                return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
            });

            const currentVisibleIndex = visibleFocusableElements.indexOf(currentElement);

            if (currentVisibleIndex > -1 && currentVisibleIndex < visibleFocusableElements.length - 1) {
                return visibleFocusableElements[currentVisibleIndex + 1];
            }
            return null; // No next focusable element
        }

        // Global keydown listener for Enter key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const activeElement = document.activeElement;

                // 1. Welcome Modal
                if (welcomeModal.classList.contains('show') || !welcomeModal.classList.contains('hidden')) { // Check if welcome modal is active
                    if (activeElement === userNameInput) {
                        e.preventDefault(); // Prevent default Enter behavior (e.g., new line in textarea)
                        startBtn.click();
                        return;
                    }
                }

                // 2. Add Task Section
                if (addTaskSection.contains(activeElement)) {
                    e.preventDefault();
                    const nextElement = getNextFocusableElement(activeElement, addTaskSection);
                    if (nextElement) {
                        nextElement.focus();
                    } else {
                        addTaskBtn.click();
                    }
                    return;
                }

                // 3. Edit Task Modal
                if (editTaskModal.classList.contains('show') || !editTaskModal.classList.contains('hidden')) {
                    if (editTaskModalContent.contains(activeElement)) { // Now editTaskModalContent is correctly defined
                        e.preventDefault();
                        const nextElement = getNextFocusableElement(activeElement, editTaskModalContent);
                        if (nextElement) {
                            nextElement.focus();
                        } else {
                            saveEditedTaskBtn.click();
                        }
                        return;
                    }
                }

                // 4. Change Order Modal
                if (changeOrderModal.classList.contains('show') || !changeOrderModal.classList.contains('hidden')) {
                    if (activeElement === changeOrderInput) {
                        e.preventDefault();
                        saveChangedOrderBtn.click();
                        return;
                    }
                }
            }
        });


        // Load data from Local Storage and initialize theme on window load
        window.onload = () => {
            loadFromLocalStorage();
            initializeTheme();

            // Show welcome modal if user name is not set
            if (!userName) {
                welcomeModal.classList.remove('hidden');
                void welcomeModalContent.offsetWidth; // Force reflow
                welcomeModalContent.classList.remove('opacity-0', 'scale-95'); // Ensure animation starts
                welcomeModalContent.classList.add('opacity-100', 'scale-100');
                userNameInput.focus();
            }
        };
    </script>
</body>
</html>
