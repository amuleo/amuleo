<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>زی تسک | پلتفرم آنلاین انجام وظایف</title>
    <meta name="description" content="زی تسک: پلتفرم مدیریت وظایف گیمیفای شده برای افزایش انگیزه و بهره‌وری. وظایف خود را مدیریت کنید، زی پوینت کسب کنید و به سطوح بالاتر برسید.">
    <meta name="keywords" content="مدیریت وظایف, گیمیفیکیشن, زی تسک, Z-Point, بهره‌وری, سازماندهی, برنامه ریزی, انگیزه, وظایف روزانه">
    <meta name="robots" content="noindex, nofollow">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/gh/rastikerdar/vazirmatn@33.003/misc/Farsi-Digits/Vazirmatn-FD-font-face.css" rel="stylesheet">
    <style>
        /* متغیرهای CSS برای تم‌بندی پویا */
        :root {
            /* رنگ‌های حالت روشن (مینیمال: خاکستری، مشکی، سفید) */
            --theme-primary: #4b5563; /* خاکستری-700 */
            --theme-secondary: #6b7280; /* خاکستری-600 */
            --theme-accent-bg: #f3f4f6; /* خاکستری-100 */
            --theme-accent-text: #1f2937; /* خاکستری-900 */
            --theme-progress-from: #4b5563; /* خاکستری-700 */
            --theme-progress-to: #6b7280; /* خاکستری-600 */
            --drag-border-color: #4b5563; /* خاکستری-700 */
            --drag-border-color-rgb: 75, 85, 99; /* نسخه RGB برای خاکستری-700 */
            --theme-input-border: #9ca3af; /* خاکستری-400 */
            --theme-input-focus-ring: #6b7280; /* خاکستری-600 */
        }

        .dark {
            /* رنگ‌های حالت تاریک (مینیمال: خاکستری، مشکی، سفید) */
            --theme-primary: #d1d5db; /* خاکستری-300 */
            --theme-secondary: #9ca3af; /* خاکستری-400 */
            --theme-accent-bg: #1f2937; /* خاکستری-900 */
            --theme-accent-text: #f9fafb; /* خاکستری-50 */
            --theme-progress-from: #d1d5db; /* خاکستری-300 */
            --theme-progress-to: #9ca3af; /* خاکستری-400 */
            --drag-border-color: #d1d5db; /* خاکستری-300 */
            --drag-border-color-rgb: 209, 213, 219; /* نسخه RGB برای خاکستری-300 */
            --theme-input-border: #4b5563; /* خاکستری-700 */
            --theme-input-focus-ring: #9ca3af; /* خاکستری-400 */
        }

        /* نوار اسکرول سفارشی برای مودال‌ها */
        .modal-scrollable-content::-webkit-scrollbar {
            width: 8px;
        }
        .modal-scrollable-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .modal-scrollable-content::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .modal-scrollable-content::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* نوار اسکرول حالت تاریک */
        .dark .modal-scrollable-content::-webkit-scrollbar-track {
            background: #333;
        }
        .dark .modal-scrollable-content::-webkit-scrollbar-thumb {
            background: #666;
        }
        .dark .modal-scrollable-content::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        /* استایل‌های بازخورد کشیدن و رها کردن */
        .dragging {
            opacity: 0.5;
            border: 2px dashed var(--drag-border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); /* سایه برجسته‌تر */
        }
        .drop-target {
            border: 2px solid var(--drag-border-color); /* حاشیه کامل */
            background-color: rgba(var(--drag-border-color-rgb), 0.1); /* پس‌زمینه شفاف */
            transition: all 0.2s ease-in-out; /* انیمیشن برای تغییرات */
        }

        /* فونت اصلی برای کل بدنه */
        body {
            font-family: 'Vazirmatn FD', sans-serif; /* فونت به Vazirmatn FD تغییر یافت */
            direction: rtl; /* اطمینان از جهت RTL برای کل بدنه */
            -webkit-user-select: none; /* سافاری */
            -moz-user-select: none;    /* فایرفاکس */
            -ms-user-select: none;     /* اینترنت اکسپلورر/اج */
            user-select: none;         /* استاندارد */
        }
        /* اجازه انتخاب برای ورودی‌ها و تکست‌آریاها */
        input, textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        /* اجبار Vazirmatn به استفاده از اعداد فارسی برای تمام اعداد */
        body, input[type="number"], input[type="text"], select {
            font-feature-settings: "ss02", "locl"; /* مجموعه استایلیستی 2 و فرم‌های محلی برای Vazirmatn */
            font-variant-numeric: traditional; /* استفاده از فرم‌های عددی سنتی */
            unicode-bidi: plaintext; /* کمک به جهت‌دهی مختلط در ورودی‌ها */
        }

        /* استایل‌های جعبه مودال */
        .modal-box {
            height: 75vh; /* ارتفاع پویا: 3/4 ارتفاع viewport */
            max-height: 400px; /* حداکثر ارتفاع برای محتوای مودال */
        }

        /* ناحیه محتوای قابل اسکرول داخلی */
        .modal-scrollable-content {
            flex-grow: 1; /* اجازه می‌دهد محتوا فضای موجود را اشغال کند */
            overflow-y: auto; /* فعال کردن اسکرول عمودی */
            padding-left: 1rem; /* تنظیم پدینگ برای نوار اسکرول */
            padding-right: 1rem;
        }

        /* انیمیشن کسب پوینت */
        .points-gain-feedback {
            position: absolute;
            font-weight: bold;
            color: #22C55E; /* رنگ سبز، ثابت می‌ماند */
            animation: fadeOutUp 1.5s forwards;
            pointer-events: none; /* اطمینان از عدم مسدود کردن کلیک‌ها */
            z-index: 20;
        }

        @keyframes fadeOutUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }

        /* افکت کنفتی */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f0f; /* رنگ پیش‌فرض */
            animation: confetti-fall 3s ease-out forwards;
            opacity: 0;
        }

        @keyframes confetti-fall {
            0% {
                opacity: 0;
                transform: translateY(-100px) rotate(0deg);
            }
            10% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(100vh) rotate(720deg);
            }
            /* تنظیم شده برای اطمینان از افتادن کنفتی از صفحه */
            100% {
                opacity: 0;
                transform: translateY(100vh) rotate(720deg);
            }
        }

        /* استایل‌های پویا برای ورودی‌ها و سلکتورها */
        input[type="text"], input[type="number"], select {
            border-color: var(--theme-input-border);
        }
        input[type="text"]:focus, input[type="number"]:focus, select:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--theme-input-focus-ring);
        }

        /* استایل‌های پویا برای ورودی‌ها و سلکتورها در حالت تاریک */
        .dark input[type="text"], .dark input[type="number"], .dark select {
            border-color: var(--theme-input-border); /* استفاده از رنگ حاشیه خاص حالت تاریک */
        }
        .dark input[type="text"]:focus, .dark input[type="number"]:focus, .dark select:focus {
            box-shadow: 0 0 0 2px var(--theme-input-focus-ring); /* استفاده از رنگ حلقه فوکوس خاص حالت تاریک */
        }
        .clickable-item {
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .clickable-item:hover {
            background-color: rgba(0, 0, 0, 0.05); /* هاور روشن برای حالت روشن */
        }
        .dark .clickable-item:hover {
            background-color: rgba(255, 255, 255, 0.05); /* هاور تیره برای حالت تاریک */
        }

        /* استایل برای عنوان وظیفه برای شکستن خط، نه اسکرول */
        .task-name-wrapper {
            white-space: normal; /* اجازه شکستن خط متن */
            word-break: break-word; /* شکستن کلمات طولانی */
            flex-grow: 1; /* اجازه می‌دهد فضای موجود را اشغال کند */
            min-width: 0; /* اجازه می‌دهد کوچکتر از اندازه محتوای خود شود */
        }

        .line-through .task-name {
            text-decoration: line-through;
        }

        /* استایل‌های پاپ‌آپ منوی سه نقطه */
        .task-action-menu {
            position: absolute;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 0.5rem;
            z-index: 50;
            min-width: 150px;
            transform-origin: top right;
            animation: scaleIn 0.15s ease-out forwards;
        }
        .dark .task-action-menu {
            background-color: #374151; /* خاکستری-700 */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .task-action-menu button {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            text-align: right;
            font-size: 0.875rem; /* text-sm */
            color: #374151; /* خاکستری-700 */
            transition: background-color 0.2s ease-in-out;
        }
        .dark .task-action-menu button {
            color: #d1d5db; /* خاکستری-300 */
        }
        .task-action-menu button:hover {
            background-color: #f3f4f6; /* خاکستری-100 */
        }
        .dark .task-action-menu button:hover {
            background-color: #4b5563; /* خاکستری-600 */
        }
        .task-action-menu button svg {
            margin-left: 0.5rem; /* ml-2 */
        }

        @keyframes scaleIn {
            0% { transform: scale(0.95); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* استایل‌های مودال‌های پویا (ویرایش/تغییر چیدمان) */
        .dynamic-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            z-index: 60; /* بالاتر از سایر مودال‌ها */
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            pointer-events: none;
        }
        .dynamic-modal.show {
            opacity: 1;
            pointer-events: auto;
        }
        .dynamic-modal-content {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            padding: 1.5rem;
            width: 100%;
            max-width: 400px;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
            opacity: 0;
            position: relative;
        }
        .dark .dynamic-modal-content {
            background-color: #374151; /* خاکستری-700 */
        }
        .dynamic-modal.show .dynamic-modal-content {
            transform: translateY(0);
            opacity: 1;
        }
        .dynamic-modal-content input, .dynamic-modal-content select {
            width: 100%;
            margin-bottom: 1rem;
        }
        .dynamic-modal-content button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: bold;
            transition: transform 0.1s ease-in-out;
        }
        .dynamic-modal-content button:hover {
            transform: scale(1.02);
        }
    </style>
</head>
<body class="p-4 flex items-center justify-center min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-100">
    <div class="container bg-white dark:bg-gray-800 shadow-xl rounded-xl p-4 sm:p-6 md:p-8 w-full max-w-4xl relative pt-16 md:pt-20">
        <div class="absolute top-4 right-4 md:top-6 md:right-6 z-10">
            <button id="menuBtn" class="p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400" aria-label="باز کردن منو">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2z"></path>
                </svg>
            </button>
            <div id="menuDropdown" class="absolute right-0 mt-2 w-48 bg-white dark:bg-gray-700 rounded-md shadow-lg py-1 hidden z-20">
                <a href="#" id="profileMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out">پروفایل</a>
                <a href="#" id="helpMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out">راهنما</a>
                <a href="#" id="aboutMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out">درباره</a>
                <a href="#" id="backupMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-300 ease-in-out">پشتیبان‌گیری</a>
                <a href="#" id="donateMenuItem" class="block px-4 py-2 text-sm text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-gray-600 transition duration-200 ease-in-out">حمایت مالی</a>
                <a href="#" id="resetMenuItem" class="block px-4 py-2 text-sm text-red-700 dark:text-red-200 hover:bg-red-100 dark:hover:bg-red-600 transition duration-200 ease-in-out">بازنشانی داده‌ها</a>
            </div>
        </div>

        <button id="themeToggleBtn" class="absolute top-4 left-4 md:top-6 md:left-6 p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-100 shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400" aria-label="تغییر تم">
            <svg id="themeIcon" class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.325 6.675l-.707-.707M6.318 6.318l-.707-.707m12.728 0l-.707.707M6.318 17.682l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>
            </svg>
        </button>

        <div class="flex flex-col md:flex-row justify-between items-center mb-6 border-b pb-4 border-gray-200 dark:border-gray-700 md:px-16">
            <h1 class="text-3xl sm:text-4xl md:text-6xl font-bold text-gray-800 dark:text-gray-100 mb-4 md:mb-0 text-center md:text-right w-full md:w-auto">زی تسک</h1>
            <div class="flex flex-col sm:flex-row items-center space-y-2 sm:space-y-0 sm:space-x-4 sm:space-x-reverse w-full md:w-auto justify-center md:justify-end">
                <div class="flex items-center bg-yellow-100 dark:bg-yellow-800 text-yellow-800 dark:text-yellow-200 px-3 py-1 rounded-full shadow-sm">
                    <span class="text-xl mr-2">💰</span>
                    <span class="text-base sm:text-lg font-semibold">پوینت: <span id="zPoint" class="text-yellow-800 dark:text-yellow-200">0</span></span>
                </div>
                <div class="flex items-center bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 px-3 py-1 rounded-full shadow-sm clickable-item" id="currentLevelDisplay">
                    <span class="text-xl mr-2">🏆</span>
                    <span class="text-base sm:text-lg font-semibold">سطح: <span id="level" class="text-blue-800 dark:text-blue-200">1</span></span>
                </div>
                <div class="flex items-center bg-purple-100 dark:bg-purple-800 text-purple-800 dark:text-purple-200 px-3 py-1 rounded-full shadow-sm">
                    <span class="text-xl mr-2">🔥</span>
                    <span class="text-base sm:text-lg font-semibold">زنجیره: <span id="dailyStreak" class="text-purple-800 dark:text-purple-200">0</span></span>
                </div>
            </div>
        </div>

        <div class="mb-6 px-2 md:px-0">
            <h2 class="text-lg sm:text-xl font-semibold text-gray-700 dark:text-gray-300 mb-2">پیشرفت شما به سطح بعدی:</h2>
            <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-4">
                <div id="progressBar" class="h-4 rounded-full transition-all duration-500 ease-out" style="width: 0%;"></div>
            </div>
            <p id="progressText" class="text-sm text-gray-500 dark:text-gray-400 mt-1 text-left">0%</p>
        </div>

        <div class="mb-6 px-2 md:px-0">
            <h2 class="text-lg sm:text-xl font-semibold text-gray-700 dark:text-gray-300 mb-2">دستاوردها:</h2>
            <div id="achievementsList" class="flex flex-wrap gap-3">
                <p id="noAchievementsMessage" class="text-gray-500 dark:text-gray-400">هنوز دستاوردی کسب نشده است.</p>
            </div>
        </div>

        <div class="mb-8 p-4 rounded-lg shadow-sm" id="addTaskSection">
            <h2 class="text-xl sm:text-2xl font-semibold mb-4" id="addTaskTitle">افزودن وظیفه جدید</h2>
            <div class="flex flex-col md:flex-row gap-4 items-stretch md:items-center">
                <input type="text" id="taskInput" placeholder="نام وظیفه را وارد کنید..." maxlength="15"
                       class="flex-grow p-3 border rounded-lg text-base sm:text-lg text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700 h-12">
                <select id="importanceSelect"
                        class="p-3 border rounded-lg text-base sm:text-lg text-gray-700 dark:text-gray-100 bg-white dark:bg-gray-700 appearance-none h-12 w-full md:w-40">
                    <option value="important">مهم</option>
                    <option value="normal" selected>عادی</option>
                    <option value="custom">سفارشی</option>
                </select>
                <input type="text" id="customPointsInput" placeholder="پوینت سفارشی (حداکثر 50)" inputmode="numeric"
                       class="p-3 border rounded-lg text-base sm:text-lg text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700 h-12 w-full md:w-32 hidden">
                <button id="addTaskBtn"
                        class="text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 text-lg w-full md:w-auto">
                    افزودن وظیفه
                </button>
            </div>
        </div>

        <div class="mb-6 px-2 md:px-0">
            <div class="flex flex-col sm:flex-row items-center justify-between mb-4">
                <h2 class="text-xl sm:text-2xl font-semibold text-gray-800 dark:text-gray-100 mb-2 sm:mb-0">وظایف فعال</h2>
                <div id="activeTasksPagination" class="flex items-center space-x-2 space-x-reverse hidden">
                    </div>
            </div>
            <div id="activeTaskList" class="task-list-container pr-2">
                </div>
        </div>

        <div class="mt-8 px-2 md:px-0">
            <button id="toggleCompletedTasksBtn" class="w-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out flex items-center justify-between focus:outline-none focus:ring-2 focus:ring-blue-400">
                <span>وظایف تکمیل شده</span>
                <svg id="toggleIcon" class="h-5 w-5 transform transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
            </button>
            <div id="completedTasksSection" class="hidden mt-4">
                <div class="flex flex-col sm:flex-row items-center justify-between mb-4 mt-4">
                    <h2 class="text-xl sm:text-2xl font-semibold text-gray-800 dark:text-gray-100 mb-2 sm:mb-0"></h2> <div id="completedTasksPagination" class="flex items-center space-x-2 space-x-reverse hidden">
                        </div>
                </div>
                <div id="completedTasksContainer" class="task-list-container pr-2">
                    </div>
            </div>
        </div>
    </div>

    <div id="welcomeModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm relative text-gray-800 dark:text-gray-100 transition-transform duration-300 transform scale-95 opacity-0" id="welcomeModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700 text-center">به زی تسک خوش آمدید!</h3>
            <p class="mb-4 text-center text-gray-700 dark:text-gray-300">لطفاً نام خود را وارد کنید تا شروع کنیم:</p>
            <input type="text" id="userNameInput" placeholder="نام شما..." maxlength="15"
                   class="w-full p-3 border border-blue-300 dark:border-blue-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 dark:focus:ring-blue-300 text-base sm:text-lg text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-500 bg-white dark:bg-gray-700 mb-4">
            <button id="startBtn"
                    class="w-full bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800 text-white font-bold py-3 px-6 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 text-lg">
                شروع کنید!
            </button>
        </div>
    </div>

    <div id="profileModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="profileModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">پروفایل کاربری</h3>
            <div id="profileModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
                </div>
            <button id="closeProfileModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="helpModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">راهنما</h3>
            <div id="helpModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
                </div>
            <button id="closeHelpModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="aboutModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="aboutModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">درباره ما</h3>
            <div id="aboutModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
                <p class="mb-3">این برنامه به منظور مدیریت وظایف و افزایش انگیزه طراحی شده است.</p>
                <p class="mb-3">این پروژه به صورت اختصاصی توسط <strong class="text-gray-600 dark:text-gray-300"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">سایت عمو لئو</a></strong> طراحی شده است. این نسخه، اولین و آخرین نسخه از این پروژه است.</p>
                <p class="mb-3">تمامی حقوق متعلق به <strong class="text-gray-600 dark:text-gray-300"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">عمو لئو</a></strong> است.</p>
                <p class="mb-3">تاریخ: ۴ خرداد ۱۴۰۴</p>
            </div>
            <button id="closeAboutModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="backupModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="backupModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">پشتیبان‌گیری و بازیابی داده‌ها</h3>
            <div class="modal-scrollable-content flex flex-col gap-4">
                <p class="text-sm text-gray-700 dark:text-gray-300">برای پشتیبان‌گیری، دکمه "ذخیره داده‌ها" را فشار دهید تا فایل پشتیبان دانلود شود. برای بازیابی، فایل پشتیبان را انتخاب کرده و "بارگذاری از فایل" را فشار دهید.</p>
                
                <button id="exportDataBtn" class="bg-blue-600 hover:bg-blue-700 dark:bg-blue-700 dark:hover:bg-blue-800 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400">
                    ذخیره داده‌ها (دانلود فایل)
                </button>

                <div class="flex items-center gap-2 mt-2">
                    <label for="importFileInput" class="bg-violet-500 hover:bg-violet-600 dark:bg-violet-700 dark:hover:bg-violet-800 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out cursor-pointer focus:outline-none focus:ring-2 focus:ring-violet-400">
                        انتخاب فایل
                    </label>
                    <span id="selectedFileName" class="text-sm text-gray-600 dark:text-gray-300 truncate max-w-[calc(100%-120px)]">فایلی انتخاب نشده است.</span>
                    <input type="file" id="importFileInput" accept=".json" class="hidden">
                </div>
                
                <button id="importDataBtn" class="bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-400">
                    بارگذاری از فایل
                </button>
            </div>
            <button id="closeBackupModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="resetConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm relative text-gray-800 dark:text-gray-100 transition-transform duration-300 transform scale-95 opacity-0" id="resetConfirmModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">تأیید بازنشانی داده‌ها</h3>
            <p class="mb-6 text-sm">آیا مطمئن هستید که می‌خواهید تمامی داده‌های برنامه را حذف کنید؟ این عمل غیرقابل بازگشت است.</p>
            <div class="flex justify-end space-x-4 space-x-reverse">
                <button id="confirmResetBtn" class="bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-red-400">
                    تأیید بازنشانی
                </button>
                <button id="cancelResetBtn" class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100 font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-gray-400">
                    لغو
                </button>
            </div>
            <button id="closeResetModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="detailModal" class="fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-75 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md relative text-gray-800 dark:text-gray-100 flex flex-col modal-box transition-transform duration-300 transform scale-95 opacity-0" id="detailModalContent">
            <h3 class="text-xl sm:text-2xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700" id="detailModalTitle"></h3>
            <div id="detailModalBody" class="modal-scrollable-content text-justify text-sm leading-relaxed">
            </div>
            <button id="closeDetailModalBtn" class="absolute top-3 left-3 p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-500 dark:text-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-400">
                <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>
    </div>

    <div id="editTaskModal" class="dynamic-modal hidden">
        <div class="dynamic-modal-content text-gray-800 dark:text-gray-100" id="editTaskModalContent"> <h3 class="text-xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">ویرایش وظیفه</h3>
            <input type="text" id="editTaskNameInput" placeholder="نام وظیفه را وارد کنید..." maxlength="15"
                   class="p-3 border rounded-lg text-base text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700">
            <select id="editTaskImportanceSelect"
                    class="p-3 border rounded-lg text-base text-gray-700 dark:text-gray-100 bg-white dark:bg-gray-700 appearance-none">
                <option value="important">مهم</option>
                <option value="normal">عادی</option>
                <option value="custom">سفارشی</option>
            </select>
            <input type="text" id="editTaskCustomPointsInput" placeholder="پوینت سفارشی (حداکثر 50)" inputmode="numeric"
                   class="p-3 border rounded-lg text-base text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700 hidden">
            <div class="flex justify-end space-x-2 space-x-reverse">
                <button id="saveEditedTaskBtn" class="bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800 text-white">ذخیره</button>
                <button id="cancelEditTaskBtn" class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100">لغو</button>
            </div>
        </div>
    </div>

    <div id="changeOrderModal" class="dynamic-modal hidden">
        <div class="dynamic-modal-content text-gray-800 dark:text-gray-100" id="changeOrderModalContent">
            <h3 class="text-xl font-bold mb-4 border-b pb-2 border-gray-200 dark:border-gray-700">تغییر چیدمان وظیفه</h3>
            <p class="mb-2 text-sm text-gray-700 dark:text-gray-300">موقعیت جدید وظیفه را (به صورت عددی) وارد کنید:</p>
            <input type="text" id="changeOrderInput" placeholder="موقعیت جدید..." inputmode="numeric"
                   class="p-3 border rounded-lg text-base text-gray-700 dark:text-gray-100 placeholder-gray-400 dark:placeholder-gray-500 bg-white dark:bg-gray-700">
            <div class="flex justify-end space-x-2 space-x-reverse">
                <button id="saveChangedOrderBtn" class="bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800 text-white">ذخیره</button>
                <button id="cancelChangeOrderBtn" class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100">لغو</button>
            </div>
        </div>
    </div>

    <div id="confettiContainer" class="confetti-container"></div>

    <div id="undoMessageBox" class="fixed bottom-4 left-1/2 -translate-x-1/2 p-4 rounded-lg shadow-lg text-white bg-gray-800 dark:bg-gray-700 z-50 transition-all duration-300 transform scale-0 opacity-0 flex items-center justify-between min-w-[200px] max-w-sm cursor-pointer hidden">
        <span id="undoMessageText" class="flex-grow mr-2"></span>
        <span id="undoCountdown" class="font-bold text-sm"></span>
    </div>

    <script>
        // ساختار داده وظیفه
        let tasks = [];
        let zPoint = 0; // زی-پوینت
        let level = 1; // سطح فعلی
        let dailyStreak = 0; // شمارنده زنجیره روزانه
        let highestDailyStreak = 0; // بالاترین زنجیره ثبت شده
        let lastCompletionDate = null; // تاریخ آخرین تکمیل وظیفه
        let totalCustomTasksCompleted = 0; // شمارنده وظایف سفارشی تکمیل شده
        let userName = null; // نام کاربر

        const pointsPerNormalTask = 10; // پوینت برای وظایف عادی
        const pointsPerImportantTask = 25; // پوینت برای وظایف مهم
        const MAX_CUSTOM_POINTS = 50; // حداکثر پوینت برای وظایف سفارشی
        const TASKS_PER_PAGE = 7; // تعداد وظایف نمایش داده شده در هر صفحه

        // متغیرهای وضعیت صفحه‌بندی
        let activeCurrentPage = 1;
        let completedCurrentPage = 1;

        // تعریف پوینت‌های مورد نیاز برای رسیدن به هر سطح (سطح 1 صفر پوینت است)
        const levelPointsThresholds = [
            { name: 'نوب', points: 0 },
            { name: 'مبتدی', points: 30 },
            { name: 'جنگجو', points: 70 },
            { name: 'شوالیه', points: 120 },
            { name: 'هیرو', points: 180 },
            { name: 'استاد', points: 250 },
            { name: 'فرمانده', points: 330 },
            { name: 'سلطان', points: 420 },
            { name: 'کار درست', points: 520 },
            { name: 'خفن', points: 630 },
            { name: 'جاودان', points: 750 },
            { name: 'خدایگان', points: 900 },
            { name: 'کیهان‌نورد', points: 1080 },
            { name: 'بتمن', points: 1290 },
            { name: 'سیگما', points: 1500 }
        ];

        // داده‌های دستاوردها
        const achievementsData = [
            { level: 1, name: 'نوب', icon: '👶', type: 'level' },
            { level: 2, name: 'مبتدی', icon: '🌱', type: 'level' },
            { level: 3, name: 'جنگجو', icon: '⚔️', type: 'level' },
            { level: 4, name: 'شوالیه', icon: '🛡️', type: 'level' },
            { level: 5, name: 'هیرو', icon: '🦸‍♂️', type: 'level' },
            { level: 6, name: 'استاد', icon: '🎓', type: 'level' },
            { level: 7, name: 'فرمانده', icon: '🎖️', type: 'level' },
            { level: 8, name: 'سلطان', icon: '👑', type: 'level' },
            { level: 9, name: 'کار درست', icon: '🐉', type: 'level' },
            { type: 'totalTasks', value: 10, name: 'ده وظیفه', icon: '✅', description: 'با تکمیل ۱۰ وظیفه کسب می‌شود.' },
            { type: 'totalTasks', value: 50, name: 'پنجاه وظیفه', icon: '💯', description: 'با تکمیل ۵۰ وظیفه کسب می‌شود.' },
            { type: 'importantTasks', value: 5, name: 'پنج وظیفه مهم', icon: '🚨', description: 'با تکمیل ۵ وظیفه مهم کسب می‌شود.' },
            { type: 'importantTasks', value: 10, name: 'ده وظیفه مهم', icon: '🛑', description: 'با تکمیل ۱۰ وظیفه مهم کسب می‌شود.' },
            { type: 'streak', value: 3, name: 'زنجیره سه روزه', icon: '🔥', description: 'با تکمیل حداقل یک وظیفه برای ۳ روز متوالی کسب می‌شود.' },
            { type: 'streak', value: 7, name: 'زنجیره هفت روزه', icon: '✨🔥', description: 'با تکمیل حداقل یک وظیفه برای ۷ روز متوالی کسب می‌شود.' },
            { type: 'streak', value: 14, name: 'زنجیره دو هفته‌ای', icon: '🗓️🔥', description: 'با تکمیل حداقل یک وظیفه برای ۱۴ روز متوالی کسب می‌شود.' },
            { type: 'streak', value: 30, name: 'زنجیره ماهانه', icon: '🗓️🗓️🔥', description: 'با تکمیل حداقل یک وظیفه برای ۳۰ روز متوالی کسب می‌شود.' },
            { type: 'totalTasks', value: 100, name: 'صد وظیفه', icon: '💯✅', description: 'با تکمیل ۱۰۰ وظیفه کسب می‌شود.' },
            { type: 'totalTasks', value: 250, name: 'دویست و پنجاه وظیفه', icon: '🌟💯', description: 'با تکمیل ۲۵۰ وظیفه کسب می‌شود.' },
            { type: 'totalTasks', value: 500, name: 'پانصد وظیفه', icon: '🏆💯', description: 'با جمع‌آوری ۵۰۰ پوینت کسب می‌شود.' },
            { type: 'importantTasks', value: 20, name: 'بیست وظیفه مهم', icon: '🛑🛑', description: 'با تکمیل ۲۰ وظیفه مهم کسب می‌شود.' },
            { type: 'customTasks', value: 1, name: 'اولین وظیفه سفارشی', icon: '💡', description: 'با تکمیل اولین وظیفه با پوینت سفارشی کسب می‌شود.' },
            { type: 'customTasks', value: 5, name: 'پنج وظیفه سفارشی', icon: '⚙️✅', description: 'با تکمیل ۵ وظیفه با پوینت سفارشی کسب می‌شود.' },
            { type: 'customTasks', value: 10, name: 'ده وظیفه سفارشی', icon: '⚙️💯', description: 'با تکمیل ۱۰ وظیفه با پوینت سفارشی کسب می‌شود.' },
            { type: 'points', value: 500, name: 'پانصد پوینت', icon: '💰', description: 'با جمع‌آوری ۵۰۰ پوینت کسب می‌شود.' },
            { type: 'points', value: 1000, name: 'هزار پوینت', icon: '💎💰', description: 'با جمع‌آوری ۱۰۰۰ پوینت کسب می‌شود.' },
            { level: 10, name: 'خفن', icon: '✨', type: 'level' },
            { level: 11, name: 'جاودان', icon: '♾️', type: 'level' },
            { level: 12, name: 'خدایگان', icon: '⚡', type: 'level' },
            { level: 13, name: 'کیهان‌نورد', icon: '🌌', type: 'level' },
            { level: 14, name: 'بتمن', icon: '🌟', type: 'level' },
            { level: 15, name: 'سیگما', icon: '🗿', type: 'level' },
        ];

        // عناصر DOM
        const themeToggleBtn = document.getElementById('themeToggleBtn');
        const themeIcon = document.getElementById('themeIcon');
        const menuBtn = document.getElementById('menuBtn');
        const menuDropdown = document.getElementById('menuDropdown');
        const profileMenuItem = document.getElementById('profileMenuItem');
        const helpMenuItem = document.getElementById('helpMenuItem');
        const aboutMenuItem = document.getElementById('aboutMenuItem');
        const backupMenuItem = document.getElementById('backupMenuItem');
        const donateMenuItem = document.getElementById('donateMenuItem');
        const resetMenuItem = document.getElementById('resetMenuItem');

        const welcomeModal = document.getElementById('welcomeModal');
        const welcomeModalContent = document.getElementById('welcomeModalContent');
        const userNameInput = document.getElementById('userNameInput');
        const startBtn = document.getElementById('startBtn');

        const profileModal = document.getElementById('profileModal');
        const profileModalContent = document.getElementById('profileModalContent');
        const closeProfileModalBtn = document.getElementById('closeProfileModalBtn');

        const helpModal = document.getElementById('helpModal');
        const helpModalContent = document.getElementById('helpModalContent');
        const helpModalBody = document.getElementById('helpModalBody');
        const aboutModal = document.getElementById('aboutModal');
        const aboutModalContent = document.getElementById('aboutModalContent');
        const aboutModalBody = document.getElementById('aboutModalBody');
        const backupModal = document.getElementById('backupModal');
        const backupModalContent = document.getElementById('backupModalContent');
        const resetConfirmModal = document.getElementById('resetConfirmModal');
        const resetConfirmModalContent = document.getElementById('resetConfirmModalContent');
        const closeHelpModalBtn = document.getElementById('closeHelpModalBtn');
        const closeAboutModalBtn = document.getElementById('closeAboutModalBtn');
        const closeBackupModalBtn = document.getElementById('closeBackupModalBtn');
        const confirmResetBtn = document.getElementById('confirmResetBtn');
        const cancelResetBtn = document.getElementById('cancelResetBtn');
        const closeResetModalBtn = document.getElementById('closeResetModalBtn');
        const importFileInput = document.getElementById('importFileInput');
        const exportDataBtn = document.getElementById('exportDataBtn');
        const importDataBtn = document.getElementById('importDataBtn');
        const selectedFileNameSpan = document.getElementById('selectedFileName');

        const detailModal = document.getElementById('detailModal');
        const detailModalContent = document.getElementById('detailModalContent');
        const detailModalTitle = document.getElementById('detailModalTitle');
        const detailModalBody = document.getElementById('detailModalBody');
        const closeDetailModalBtn = document.getElementById('closeDetailModalBtn');

        const taskInput = document.getElementById('taskInput');
        const importanceSelect = document.getElementById('importanceSelect');
        const customPointsInput = document.getElementById('customPointsInput');
        const addTaskBtn = document.getElementById('addTaskBtn');
        const activeTaskList = document.getElementById('activeTaskList');
        const completedTasksContainer = document.getElementById('completedTasksContainer');
        const toggleCompletedTasksBtn = document.getElementById('toggleCompletedTasksBtn');
        const toggleIcon = document.getElementById('toggleIcon');
        const zPointSpan = document.getElementById('zPoint');
        const levelSpan = document.getElementById('level');
        const currentLevelDisplay = document.getElementById('currentLevelDisplay');
        const dailyStreakSpan = document.getElementById('dailyStreak');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const noAchievementsMessage = document.getElementById('noAchievementsMessage');
        const achievementsList = document.getElementById('achievementsList');
        const addTaskSection = document.getElementById('addTaskSection');
        const addTaskTitle = document.getElementById('addTaskTitle');

        // عناصر DOM صفحه‌بندی
        const activeTasksPagination = document.getElementById('activeTasksPagination');
        const completedTasksPagination = document.getElementById('completedTasksPagination');
        const completedTasksSection = document.getElementById('completedTasksSection'); // کانتینر برای محتوای وظایف تکمیل شده

        const confettiContainer = document.getElementById('confettiContainer');

        // متغیرها برای کشیدن و رها کردن
        let draggedTaskId = null;
        let draggedElement = null; // ارجاع به عنصر واقعی در حال کشیدن
        let ghostElement = null; // عنصر شبح برای بازخورد لمسی کشیدن
        let initialTouchOffsetX = 0; // آفست اولیه لمس X از لبه چپ عنصر
        let initialTouchOffsetY = 0; // آفست اولیه لمس Y از لبه بالای عنصر


        // متغیرهای مربوط به لمس (برای کشیدن و رها کردن و ضربه زدن)
        let touchStartX = 0;
        let touchStartY = 0;
        let touchCurrentX = 0;
        let touchCurrentY = 0;
        let longPressTimer = null; // برای فعال کردن کشیدن و رها کردن
        let isDragging = false; // پرچم برای نشان دادن شروع رسمی عملیات کشیدن و رها کردن
        let isGestureStarted = false; // اگر یک دنباله لمسی روی یک آیتم وظیفه شروع شده باشد، درست است
        let isLongPressDetected = false; // اگر آستانه نگه داشتن طولانی برای کشیدن برآورده شده باشد، درست است

        const DRAG_LONG_PRESS_TIME = 1500; // 1.5 ثانیه برای فعال کردن کشیدن و رها کردن
        const TAP_THRESHOLD = 20; // حداکثر پیکسل جابجا شده برای اینکه یک لمس همچنان ضربه در نظر گرفته شود

        // عناصر DOM برای جعبه پیام بازگردانی
        const undoMessageBox = document.getElementById('undoMessageBox');
        const undoMessageText = document.getElementById('undoMessageText');
        const undoCountdown = document.getElementById('undoCountdown');

        // صف‌های پیام برای نمایش متوالی (جداگانه برای بالا-راست و پایین-مرکز)
        const topRightMessageQueue = [];
        const bottomCenterMessageQueue = [];
        let isTopRightDisplaying = false;
        let isBottomCenterDisplaying = false;
        let currentTopRightTimeout = null;
        let currentBottomCenterTimeout = null;
        let currentCountdownInterval = null; // نگهدارنده اینتروال برای شمارش معکوس فعلی (اگر پیام بازگردانی باشد)


        // عناصر مودال پویا
        const editTaskModal = document.getElementById('editTaskModal');
        const editTaskModalContent = document.getElementById('editTaskModalContent'); // به درستی انتخاب شده
        const editTaskNameInput = document.getElementById('editTaskNameInput');
        const editTaskImportanceSelect = document.getElementById('editTaskImportanceSelect');
        const editTaskCustomPointsInput = document.getElementById('editTaskCustomPointsInput');
        const saveEditedTaskBtn = document.getElementById('saveEditedTaskBtn');
        const cancelEditTaskBtn = document.getElementById('cancelEditTaskBtn');

        const changeOrderModal = document.getElementById('changeOrderModal');
        const changeOrderModalContent = document.getElementById('changeOrderModalContent'); // ID اضافه شد
        const changeOrderInput = document.getElementById('changeOrderInput');
        const saveChangedOrderBtn = document.getElementById('saveChangedOrderBtn');
        const cancelChangeOrderBtn = document.getElementById('cancelChangeOrderBtn');

        let currentTaskBeingEditedId = null; // برای پیگیری وظیفه در حال ویرایش/تغییر چیدمان


        // تابع کمکی برای تبدیل اعداد فارسی به انگلیسی
        function convertPersianNumbersToEnglish(inputString) {
            if (typeof inputString !== 'string') {
                return inputString; // اگر رشته نیست، همانطور که هست برگردانده شود
            }
            const persianNumbers = ['۰', '۱', '۲', '۳', '۴', '۵', '۶', '۷', '۸', '۹'];
            const englishNumbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

            let convertedString = '';
            for (let i = 0; i < inputString.length; i++) {
                const char = inputString[i];
                const index = persianNumbers.indexOf(char);
                if (index !== -1) {
                    convertedString += englishNumbers[index];
                } else {
                    convertedString += char;
                }
            }
            return convertedString;
        }

        // تابع برای نمایش یک جعبه پیام سفارشی به جای alert()
        // گزینه‌ها می‌توانند شامل: position ('top-right', 'bottom-center'), duration (ms), isUndo (boolean), taskId (برای بازگردانی)
        function showMessageBox(message, type = 'info', options = {}) {
            const { position = 'top-right', duration = 3000, isUndo = false, taskData = null } = options;
            const messageObject = { message, type, position, duration, isUndo, taskData };

            if (position === 'top-right') {
                topRightMessageQueue.push(messageObject);
                processTopRightQueue();
            } else if (position === 'bottom-center') {
                bottomCenterMessageQueue.push(messageObject);
                processBottomCenterQueue();
            }
        }

        // تابع برای پردازش صف پیام بالا-راست
        function processTopRightQueue() {
            if (topRightMessageQueue.length === 0 || isTopRightDisplaying) {
                return;
            }

            isTopRightDisplaying = true;
            const { message, type, duration } = topRightMessageQueue.shift();

            const messageBox = document.createElement('div');
            let bgColorClass = '';
            if (type === 'info') {
                bgColorClass = 'bg-gray-500 dark:bg-gray-700';
            } else if (type === 'success') {
                bgColorClass = 'bg-green-500 dark:bg-green-700';
            } else if (type === 'error') {
                bgColorClass = 'bg-red-500 dark:bg-red-700';
            }
            messageBox.className = `fixed p-4 rounded-lg shadow-lg text-white z-50 transition-all duration-300 transform opacity-0 top-4 right-4 translate-x-full ${bgColorClass}`;
            messageBox.textContent = message;
            document.body.appendChild(messageBox);

            setTimeout(() => {
                messageBox.classList.remove('translate-x-full', 'opacity-0');
                messageBox.classList.add('translate-x-0', 'opacity-100');
            }, 100);

            currentTopRightTimeout = setTimeout(() => {
                messageBox.classList.remove('translate-x-0', 'opacity-100');
                messageBox.classList.add('translate-x-full', 'opacity-0');
                messageBox.addEventListener('transitionend', () => {
                    messageBox.remove();
                    isTopRightDisplaying = false;
                    processTopRightQueue(); // پردازش پیام بعدی
                }, { once: true });
            }, duration);
        }

        // تابع برای پردازش صف پیام پایین-مرکز (برای پیام‌های بازگردانی)
        function processBottomCenterQueue() {
            if (bottomCenterMessageQueue.length === 0 || isBottomCenterDisplaying) {
                return;
            }

            isBottomCenterDisplaying = true;
            const { message, duration, isUndo, taskData } = bottomCenterMessageQueue.shift();

            // فقط undoMessageBox از موقعیت پایین-مرکز و منطق بازگردانی استفاده می‌کند
            if (isUndo) {
                undoMessageText.textContent = message;
                undoMessageBox.classList.remove('hidden'); // اطمینان از عدم پنهان بودن
                undoMessageBox._currentUndoTaskData = taskData; // ذخیره داده‌های وظیفه خاص برای این پیام
                
                let timeLeft = duration / 1000;
                undoCountdown.textContent = `(${timeLeft}s)`;
                clearInterval(currentCountdownInterval); // پاک کردن اینتروال قبلی
                currentCountdownInterval = setInterval(() => {
                    timeLeft--;
                    undoCountdown.textContent = `(${timeLeft}s)`;
                    if (timeLeft <= 0) {
                        clearInterval(currentCountdownInterval);
                        hideBottomCenterMessage(); // پنهان کردن پیام بازگردانی
                    }
                }, 1000);

                undoMessageBox.onclick = () => {
                    if (undoMessageBox._currentUndoTaskData) {
                        undoLastDeletion(undoMessageBox._currentUndoTaskData);
                    }
                    hideBottomCenterMessage(); // پنهان کردن پیام بازگردانی بلافاصله پس از کلیک
                };

                // انیمیشن ورود
                setTimeout(() => {
                    undoMessageBox.classList.remove('scale-0', 'opacity-0');
                    undoMessageBox.classList.add('scale-100', 'opacity-100');
                }, 100);

                currentBottomCenterTimeout = setTimeout(() => {
                    hideBottomCenterMessage();
                }, duration);
            }

            function hideBottomCenterMessage() {
                clearTimeout(currentBottomCenterTimeout);
                clearInterval(currentCountdownInterval);
                undoMessageBox.classList.remove('scale-100', 'opacity-100');
                undoMessageBox.classList.add('scale-0', 'opacity-0');
                undoMessageBox.addEventListener('transitionend', () => {
                    undoMessageBox.classList.add('hidden'); // کاملاً پنهان کردن پس از انیمیشن
                    undoMessageBox.onclick = null; // حذف هندلر کلیک
                    undoMessageBox._currentUndoTaskData = null; // پاک کردن داده‌های وظیفه ذخیره شده
                    isBottomCenterDisplaying = false;
                    processBottomCenterQueue(); // پردازش پیام بعدی
                }, { once: true });
            }
        }


        // تابع برای نمایش بازخورد کسب پوینت
        function showPointsGainFeedback(pointsGained, taskElement) {
            if (!taskElement) return;

            const feedback = document.createElement('div');
            feedback.textContent = `${pointsGained} پوینت`;
            feedback.classList.add('points-gain-feedback');

            // موقعیت‌دهی عنصر بازخورد نسبت به آیتم وظیفه
            const rect = taskElement.getBoundingClientRect();
            feedback.style.top = `${rect.top + window.scrollY + rect.height / 2 - 10}px`;
            feedback.style.left = `${rect.left + window.scrollX + rect.width / 2 - 20}px`;
            feedback.style.fontSize = '1.2rem'; // اندازه فونت کمی افزایش یافت

            document.body.appendChild(feedback);

            feedback.addEventListener('animationend', () => {
                feedback.remove();
            });
        }

        // تابع برای فعال کردن افکت کنفتی
        function triggerConfetti() {
            const colors = ['#f0f', '#0ff', '#ff0', '#f00', '#0f0', '#00f'];
            for (let i = 0; i < 50; i++) { // تولید 50 قطعه کنفتی
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = `${Math.random() * 0.5}s`; // انیمیشن با تأخیر
                confettiContainer.appendChild(confetti);
            }
            // پاکسازی کنفتی پس از انیمیشن
            setTimeout(() => {
                confettiContainer.innerHTML = '';
            }, 3000);
        }

        // تابع برای اعمال تم بر اساس سطح فعلی (تغییر یافته برای تم مینیمال)
        function applyLevelTheme(currentLevel) {
            const isDarkMode = document.documentElement.classList.contains('dark');
            
            // تعریف پالت رنگی مینیمال
            const lightThemeColors = {
                primary: '#4b5563', // خاکستری-700
                secondary: '#6b7280', // خاکستری-600
                accentBg: '#f3f4f6', // خاکستری-100
                accentText: '#1f2937', // خاکستری-900
                inputBorder: '#9ca3af', // خاکستری-400
                inputFocusRing: '#6b7280' // خاکستری-600
            };
            const darkThemeColors = {
                primary: '#d1d5db', // خاکستری-300
                secondary: '#9ca3af', // خاکستری-400
                accentBg: '#1f2937', // خاکستری-900
                accentText: '#f9fafb', // خاکستری-50
                inputBorder: '#4b5563', // خاکستری-700
                inputFocusRing: '#9ca3af' // خاکستری-400
            };

            const currentThemeData = isDarkMode ? darkThemeColors : lightThemeColors;

            // تنظیم متغیرهای CSS
            document.documentElement.style.setProperty('--theme-primary', currentThemeData.primary);
            document.documentElement.style.setProperty('--theme-secondary', currentThemeData.secondary);
            document.documentElement.style.setProperty('--theme-accent-bg', currentThemeData.accentBg);
            document.documentElement.style.setProperty('--theme-accent-text', currentThemeData.accentText);
            document.documentElement.style.setProperty('--theme-progress-from', currentThemeData.primary);
            document.documentElement.style.setProperty('--theme-progress-to', currentThemeData.secondary);
            document.documentElement.style.setProperty('--drag-border-color', currentThemeData.primary);
            document.documentElement.style.setProperty('--drag-border-color-rgb', hexToRgb(currentThemeData.primary)); // اضافه شده برای استفاده در rgba()
            document.documentElement.style.setProperty('--theme-input-border', currentThemeData.inputBorder);
            document.documentElement.style.setProperty('--theme-input-focus-ring', currentThemeData.inputFocusRing);

            // به‌روزرسانی عناصری که از این متغیرها استفاده می‌کنند
            // دکمه افزودن وظیفه
            addTaskBtn.style.backgroundColor = currentThemeData.primary;
            addTaskBtn.onmouseover = () => addTaskBtn.style.backgroundColor = currentThemeData.secondary;
            addTaskBtn.onmouseout = () => addTaskBtn.style.backgroundColor = currentThemeData.primary;

            // پس‌زمینه و متن بخش افزودن وظیفه
            addTaskSection.style.backgroundColor = currentThemeData.accentBg;
            addTaskTitle.style.color = currentThemeData.accentText;

            // به‌روزرسانی گرادیان نوار پیشرفت
            progressBar.style.backgroundImage = `linear-gradient(to right, ${currentThemeData.primary}, ${currentThemeData.secondary})`;
        }

        // تابع کمکی برای تبدیل کد رنگ هگز به فرمت RGB
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return `${r}, ${g}, ${b}`;
        }

        // تابع برای به‌روزرسانی نمایش گیمیفیکیشن
        function updateGamificationDisplay() {
            zPointSpan.textContent = zPoint;
            
            // محاسبه سطح فعلی بر اساس آستانه پوینت‌ها
            let newLevel = 1;
            for (let i = 0; i < levelPointsThresholds.length; i++) {
                if (zPoint >= levelPointsThresholds[i].points) {
                    newLevel = i + 1;
                } else {
                    break; // پوینت‌ها برای این سطح کافی نیست، بنابراین سطح قبلی فعلی است
                }
            }

            if (newLevel > level) {
                showMessageBox(`تبریک! به سطح ${levelPointsThresholds[newLevel - 1].name} رسیدید!`, 'success');
                triggerConfetti();
            }
            level = newLevel; // به‌روزرسانی متغیر سطح جهانی
            levelSpan.textContent = level;

            dailyStreakSpan.textContent = dailyStreak; // به‌روزرسانی نمایش زنجیره روزانه

            // منطق نوار پیشرفت تا سطح 15
            if (level <= levelPointsThresholds.length) {
                const currentLevelThreshold = levelPointsThresholds[level - 1].points;
                // اطمینان از محاسبه صحیح nextLevelThreshold، به ویژه برای آخرین سطح
                const nextLevelThreshold = (level < levelPointsThresholds.length) ? levelPointsThresholds[level].points : zPoint;
                
                let pointsIntoCurrentLevel = zPoint - currentLevelThreshold;
                let pointsNeededForNextLevel = nextLevelThreshold - currentLevelThreshold;

                let progressPercentage = 0;
                if (pointsNeededForNextLevel > 0) {
                    progressPercentage = Math.min(100, (pointsIntoCurrentLevel / pointsNeededForNextLevel) * 100);
                } else if (level === levelPointsThresholds.length) { // حداکثر سطح رسید
                    progressPercentage = 100;
                }

                progressBar.style.width = `${progressPercentage}%`;
                if (level < levelPointsThresholds.length) {
                    progressText.textContent = `${Math.round(progressPercentage)}% پیشرفت به سطح ${levelPointsThresholds[level].name}`;
                } else {
                    progressText.textContent = `شما به حداکثر سطح (${levelPointsThresholds[levelPointsThresholds.length - 1].name}) رسیده‌اید!`;
                }
            } else {
                // پس از حداکثر سطح، نوار پیشرفت پر باقی می‌ماند و فقط پوینت‌ها جمع می‌شوند
                progressBar.style.width = `100%`;
                progressText.textContent = `شما به حداکثر سطح (${levelPointsThresholds[levelPointsThresholds.length - 1].name}) رسیده‌اید!`;
            }
            
            renderAchievements(); // فراخوانی renderAchievements در اینجا
            applyLevelTheme(level); // اعمال تم برای سطح فعلی
        }

        // تابع برای ذخیره وظایف، پوینت‌ها، سطح، زنجیره و تاریخ آخرین تکمیل در Local Storage
        function saveToLocalStorage() {
            localStorage.setItem('tasks', JSON.stringify(tasks));
            localStorage.setItem('zPoint', zPoint);
            localStorage.setItem('level', level);
            localStorage.setItem('dailyStreak', dailyStreak);
            localStorage.setItem('highestDailyStreak', highestDailyStreak); // ذخیره بالاترین زنجیره
            localStorage.setItem('lastCompletionDate', lastCompletionDate);
            localStorage.setItem('totalCustomTasksCompleted', totalCustomTasksCompleted);
            localStorage.setItem('userName', userName);
        }

        // تابع برای بارگذاری وظایف، پوینت‌ها، سطح، زنجیره و تاریخ آخرین تکمیل از Local Storage
        function loadFromLocalStorage() {
            const storedTasks = localStorage.getItem('tasks');
            const storedZPoint = localStorage.getItem('zPoint');
            const storedLevel = localStorage.getItem('level');
            const storedDailyStreak = localStorage.getItem('dailyStreak');
            const storedHighestDailyStreak = localStorage.getItem('highestDailyStreak'); // بارگذاری بالاترین زنجیره
            const storedLastCompletionDate = localStorage.getItem('lastCompletionDate');
            const storedTotalCustomTasksCompleted = localStorage.getItem('totalCustomTasksCompleted');
            const storedUserName = localStorage.getItem('userName');

            if (storedTasks) {
                try {
                    tasks = JSON.parse(storedTasks);
                } catch (e) {
                    console.error("خطا در تجزیه وظایف ذخیره شده از Local Storage:", e);
                    tasks = []; // بازنشانی وظایف در صورت شکست تجزیه
                }
            }
            if (storedZPoint) {
                zPoint = parseInt(storedZPoint, 10);
                if (isNaN(zPoint)) zPoint = 0; // اطمینان از عدد بودن
            }
            if (storedLevel) {
                level = parseInt(storedLevel, 10);
                if (isNaN(level)) level = 1; // اطمینان از عدد بودن
            }
            if (storedDailyStreak) {
                dailyStreak = parseInt(storedDailyStreak, 10);
                if (isNaN(dailyStreak)) dailyStreak = 0; // اطمینان از عدد بودن
            }
            if (storedHighestDailyStreak) { // تجزیه بالاترین زنجیره
                highestDailyStreak = parseInt(storedHighestDailyStreak, 10);
                if (isNaN(highestDailyStreak)) highestDailyStreak = 0;
            }
            if (storedTotalCustomTasksCompleted) {
                totalCustomTasksCompleted = parseInt(storedTotalCustomTasksCompleted, 10);
                if (isNaN(totalCustomTasksCompleted)) totalCustomTasksCompleted = 0; // اطمینان از عدد بودن
            }
            if (storedUserName) {
                userName = storedUserName;
            }
            // رسیدگی به رشته 'null' از localStorage
            if (storedLastCompletionDate && storedLastCompletionDate !== 'null') {
                lastCompletionDate = storedLastCompletionDate;
            } else {
                lastCompletionDate = null; // صراحتاً null تنظیم شود اگر یافت نشد یا رشته 'null' بود
            }

            // بررسی و به‌روزرسانی زنجیره روزانه در بارگذاری
            const today = new Date().toDateString();

            if (lastCompletionDate && lastCompletionDate !== today) {
                const lastDate = new Date(lastCompletionDate);
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);

                // مقایسه فقط بخش‌های تاریخ برای زنجیره
                if (lastDate.toDateString() === yesterday.toDateString()) {
                    dailyStreak++;
                    // showMessageBox(`زنجیره: ${dailyStreak} روز متوالی!`, 'info'); // این پیام در زمان بارگذاری حذف شد
                } else if (lastDate.toDateString() !== today) {
                    dailyStreak = 0; // بازنشانی اگر متوالی نباشد و امروز قبلاً تکمیل نشده باشد
                    showMessageBox('زنجیره روزانه شما بازنشانی شد.', 'info');
                }
            } else if (!lastCompletionDate) { // اگر تاریخ تکمیل وجود نداشته باشد
                dailyStreak = 0;
            }
            highestDailyStreak = Math.max(highestDailyStreak, dailyStreak); // اطمینان از به‌روزرسانی بالاترین در بارگذاری نیز
            saveToLocalStorage(); // ذخیره زنجیره به‌روز شده در صورت بازنشانی
            renderTasks(); // رندر وظایف بلافاصله پس از بارگذاری
        }

        // تابع برای ایجاد عنصر HTML برای یک وظیفه
        function createTaskElement(task) {
            const taskItem = document.createElement('div');
            // اعمال کلاس‌های حالت تاریک بر اساس وضعیت و اهمیت وظیفه
            taskItem.className = `task-item flex items-center justify-between p-3 mb-2 sm:p-4 sm:mb-3 rounded-lg shadow-sm transition-all duration-300 ease-in-out
                                ${task.completed ? 'bg-green-100 dark:bg-green-800 border-l-4 border-green-500 dark:border-green-600 line-through text-gray-500 dark:text-gray-400' :
                                task.isPinned ? 'bg-yellow-50 dark:bg-yellow-900 border-l-4 border-yellow-500 dark:border-yellow-600' : // استایل پین شده
                                task.importance === 'important' ? 'bg-red-50 dark:bg-red-900 border-l-4 border-red-500 dark:border-red-600' :
                                task.importance === 'custom' ? 'bg-purple-50 dark:bg-purple-900 border-l-4 border-purple-500 dark:border-purple-600' :
                                'bg-gray-50 dark:bg-gray-700 border-l-4 border-gray-300 dark:border-gray-600'}`;
            taskItem.dataset.id = task.id;
            taskItem.setAttribute('draggable', !task.completed); // فقط اگر تکمیل نشده باشد، قابل کشیدن باشد

            // تعیین متن نمایش اهمیت
            let importanceText = '';
            let importanceClasses = '';
            if (task.importance === 'important') {
                importanceText = 'مهم';
                importanceClasses = 'bg-red-200 dark:bg-red-700 text-red-800 dark:text-red-200';
            } else if (task.importance === 'normal') {
                importanceText = 'عادی';
                importanceClasses = 'bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-200';
            } else if (task.importance === 'custom') {
                importanceText = `${task.customPoints} پوینت`; // نمایش پوینت‌های سفارشی به صورت "35 پوینت"
                importanceClasses = 'bg-purple-200 dark:bg-purple-700 text-purple-800 dark:text-purple-200';
            }

            taskItem.innerHTML = `
                <div class="flex items-center flex-grow">
                    <input type="checkbox" data-id="${task.id}" ${task.completed ? 'checked' : ''}
                        class="form-checkbox h-5 w-5 text-blue-600 dark:text-blue-400 rounded focus:ring-blue-500 dark:focus:ring-blue-300 ml-2">
                    <div class="task-name-wrapper ml-3 text-base sm:text-lg font-medium ${task.completed ? 'text-gray-500 dark:text-gray-400 line-through' : 'text-gray-800 dark:text-gray-100'}">
                        ${task.isPinned ? `<span class="ml-2 text-yellow-500" title="وظیفه پین شده">📌</span>` : ''}
                        <span class="task-name">${task.name}</span>
                    </div>
                </div>
                <div class="flex items-center space-x-2 space-x-reverse mr-2">
                    <button data-id="${task.id}" data-action="menu"
                        class="three-dot-menu-btn bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 p-2 rounded-full shadow-md transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-400">
                        <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2zm0 7a1 1 0 100-2 1 1 0 000 2z"></path>
                        </svg>
                    </button>
                    <span class="task-importance-display text-sm px-2 py-1 rounded-full ${importanceClasses}">
                        ${importanceText}
                    </span>
                </div>
            `;
            return taskItem;
        }

        // تابع برای رندر وظایف
        function renderTasks() {
            activeTaskList.innerHTML = ''; // پاک کردن وظایف فعال موجود
            completedTasksContainer.innerHTML = ''; // پاک کردن وظایف تکمیل شده موجود

            // جداسازی وظایف فعال و تکمیل شده
            let activeTasks = tasks.filter(task => !task.completed);
            const completedTasks = tasks.filter(task => task.completed);

            // مرتب‌سازی وظایف فعال: پین شده‌ها اول، سپس حفظ ترتیب نسبی (ترتیب دستی)
            activeTasks.sort((a, b) => {
                if (a.isPinned && !b.isPinned) return -1;
                if (!a.isPinned && b.isPinned) return 1;
                return 0; // حفظ ترتیب موجود برای وظایف پین نشده
            });

            // محاسبه کل صفحات برای وظایف فعال
            const activeTotalPages = Math.ceil(activeTasks.length / TASKS_PER_PAGE);
            // اطمینان از معتبر بودن صفحه فعلی و تنظیم در صورت حذف وظایف
            if (activeCurrentPage > activeTotalPages && activeTotalPages > 0) {
                activeCurrentPage = activeTotalPages;
            } else if (activeTotalPages === 0) {
                activeCurrentPage = 1;
            }
            activeCurrentPage = Math.min(Math.max(1, activeCurrentPage), Math.max(1, activeTotalPages));

            // رندر وظایف فعال برای صفحه فعلی
            const activeStartIndex = (activeCurrentPage - 1) * TASKS_PER_PAGE;
            const activeEndIndex = activeStartIndex + TASKS_PER_PAGE;
            const activeTasksToRender = activeTasks.slice(activeStartIndex, activeEndIndex);

            if (activeTasksToRender.length === 0 && activeTasks.length === 0) {
                const noActiveItem = document.createElement('div');
                noActiveItem.id = 'dynamicNoActiveMessage';
                noActiveItem.className = 'text-gray-500 dark:text-gray-400 text-center py-4';
                noActiveItem.textContent = 'اولین وظیفه فعال خود را ایجاد کنید!';
                activeTaskList.appendChild(noActiveItem);
            } else {
                activeTasksToRender.forEach(task => {
                    activeTaskList.appendChild(createTaskElement(task));
                });
            }

            // رندر کنترل‌های صفحه‌بندی برای وظایف فعال
            renderPaginationControls(activeTasksPagination, activeTasks.length, activeCurrentPage, 'active');

            // محاسبه کل صفحات برای وظایف تکمیل شده
            const completedTotalPages = Math.ceil(completedTasks.length / TASKS_PER_PAGE);
            // اطمینان از معتبر بودن صفحه فعلی و تنظیم در صورت حذف وظایف
            if (completedCurrentPage > completedTotalPages && completedTotalPages > 0) {
                completedCurrentPage = completedTotalPages;
            } else if (completedTotalPages === 0) {
                completedCurrentPage = 1;
            }
            completedCurrentPage = Math.min(Math.max(1, completedCurrentPage), Math.max(1, completedTotalPages));

            // رندر وظایف تکمیل شده برای صفحه فعلی
            const completedStartIndex = (completedCurrentPage - 1) * TASKS_PER_PAGE;
            const completedEndIndex = completedStartIndex + TASKS_PER_PAGE;
            const completedTasksToRender = completedTasks.slice(completedStartIndex, completedEndIndex);

            if (completedTasksToRender.length === 0 && completedTasks.length === 0) {
                const noCompletedItem = document.createElement('div');
                noCompletedItem.id = 'dynamicNoCompletedMessage';
                noCompletedItem.className = 'text-gray-500 dark:text-gray-400 text-center py-4';
                noCompletedItem.textContent = 'هنوز وظیفه تکمیل شده‌ای وجود ندارد.';
                completedTasksContainer.appendChild(noCompletedItem);
            } else {
                completedTasksToRender.forEach(task => {
                    completedTasksContainer.appendChild(createTaskElement(task));
                });
            }

            // رندر کنترل‌های صفحه‌بندی برای وظایف تکمیل شده
            renderPaginationControls(completedTasksPagination, completedTasks.length, completedCurrentPage, 'completed');

            updateGamificationDisplay();
        }

        /**
         * کنترل‌های صفحه‌بندی را برای یک لیست وظیفه مشخص رندر می‌کند.
         * @param {HTMLElement} containerElement عنصر DOM برای رندر کنترل‌ها.
         * @param {number} totalItems تعداد کل آیتم‌ها در لیست.
         * @param {number} currentPage شماره صفحه فعلی.
         * @param {'active'|'completed'} listType نوع لیست ('active' یا 'completed').
         */
        function renderPaginationControls(containerElement, totalItems, currentPage, listType) {
            const totalPages = Math.ceil(totalItems / TASKS_PER_PAGE);

            // پنهان کردن صفحه‌بندی اگر فقط یک صفحه یا تعداد وظایف کمتر از TASKS_PER_PAGE باشد
            if (totalPages <= 1) {
                containerElement.classList.add('hidden');
                containerElement.innerHTML = ''; // پاک کردن محتوا در صورت پنهان بودن
                return;
            } else {
                // فقط در صورتی که بخش مربوطه قابل مشاهده باشد، صفحه‌بندی را نمایش دهید.
                // برای وظایف فعال، همیشه نمایش دهید اگر > 1 صفحه باشد. برای تکمیل شده، فقط اگر بخش قابل مشاهده باشد.
                if (listType === 'completed' && completedTasksSection.classList.contains('hidden')) {
                    containerElement.classList.add('hidden');
                    containerElement.innerHTML = ''; // پاک کردن محتوا در صورت پنهان بودن
                    return;
                }
                containerElement.classList.remove('hidden');
            }

            containerElement.innerHTML = ''; // پاک کردن کنترل‌های موجود

            // دکمه قبلی
            const prevBtn = document.createElement('button');
            prevBtn.className = `p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400 ${currentPage === 1 ? 'opacity-50 cursor-not-allowed' : ''}`;
            prevBtn.innerHTML = `<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>`;
            prevBtn.disabled = currentPage === 1;
            prevBtn.title = "صفحه قبلی";
            prevBtn.addEventListener('click', () => {
                if (listType === 'active') {
                    activeCurrentPage = Math.max(1, activeCurrentPage - 1);
                } else {
                    completedCurrentPage = Math.max(1, completedCurrentPage - 1);
                }
                renderTasks();
            });
            containerElement.appendChild(prevBtn);

            // نمایش شماره صفحه (قابل ویرایش)
            const pageNumberSpan = document.createElement('span');
            pageNumberSpan.className = 'px-3 py-1 rounded-full bg-blue-100 dark:bg-blue-800 text-blue-800 dark:text-blue-200 font-semibold cursor-pointer min-w-[3rem] text-center';
            pageNumberSpan.textContent = currentPage;
            pageNumberSpan.title = `صفحه ${currentPage} از ${totalPages}. برای ویرایش دوبار کلیک کنید.`;
            pageNumberSpan.dataset.listType = listType; // ذخیره نوع لیست برای مدیریت رویداد

            // دوبار کلیک برای ویرایش شماره صفحه
            pageNumberSpan.addEventListener('dblclick', () => {
                const input = document.createElement('input');
                input.type = 'text'; // نوع به "text" تغییر یافت
                input.inputmode = 'numeric'; // inputmode numeric اضافه شد
                input.className = 'w-12 text-center bg-blue-50 dark:bg-blue-900 text-blue-800 dark:text-blue-100 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-400';
                input.value = currentPage;
                input.min = 1;
                input.max = totalPages;
                input.dataset.originalValue = currentPage; // ذخیره مقدار اصلی

                pageNumberSpan.replaceWith(input);
                input.focus();
                input.select(); // انتخاب خودکار متن

                const handleInputBlur = () => {
                    let newPage = parseInt(convertPersianNumbersToEnglish(input.value), 10); // تبدیل قبل از تجزیه
                    if (isNaN(newPage) || newPage < 1 || newPage > totalPages) {
                        newPage = parseInt(input.dataset.originalValue, 10); // بازگشت به مقدار اصلی در صورت نامعتبر بودن
                        showMessageBox(`شماره صفحه نامعتبر است. مقدار باید بین 1 و ${totalPages} باشد. بازگشت به صفحه ${newPage}.`, 'error');
                    }
                    if (listType === 'active') {
                        activeCurrentPage = newPage;
                    } else {
                        completedCurrentPage = newPage;
                    }
                    renderTasks();
                    input.removeEventListener('blur', handleInputBlur);
                    input.removeEventListener('keydown', handleInputKeydown);
                };

                const handleInputKeydown = (e) => {
                    if (e.key === 'Enter') {
                        input.blur(); // فعال کردن blur برای پردازش ورودی
                    }
                };

                input.addEventListener('blur', handleInputBlur);
                input.addEventListener('keydown', handleInputKeydown);
            });
            containerElement.appendChild(pageNumberSpan); // اضافه کردن span (یا input در صورت فعال بودن)

            // دکمه بعدی
            const nextBtn = document.createElement('button');
            nextBtn.className = `p-2 rounded-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-100 shadow-md transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-400 ${currentPage === totalPages ? 'opacity-50 cursor-not-allowed' : ''}`;
            nextBtn.innerHTML = `<svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>`;
            nextBtn.disabled = currentPage === totalPages;
            prevBtn.title = "صفحه بعدی";
            nextBtn.addEventListener('click', () => {
                if (listType === 'active') {
                    activeCurrentPage = Math.min(totalPages, activeCurrentPage + 1);
                } else {
                    completedCurrentPage = Math.min(totalPages, completedCurrentPage + 1);
                }
                renderTasks();
            });
            containerElement.appendChild(nextBtn);
        }

        // تابع برای رندر دستاوردها
        function renderAchievements() {
            achievementsList.innerHTML = ''; // پاک کردن دستاوردهای موجود
            const unlockedAchievements = achievementsData.filter(achievement => {
                if (achievement.type === 'level') {
                    const levelInfo = levelPointsThresholds.find(l => l.name === achievement.name);
                    return levelInfo && zPoint >= levelInfo.points;
                } else if (achievement.type === 'streak') {
                    return dailyStreak >= achievement.value;
                } else if (achievement.type === 'totalTasks') {
                    return tasks.filter(t => t.completed).length >= achievement.value;
                } else if (achievement.type === 'importantTasks') {
                    return tasks.filter(t => t.completed && t.importance === 'important').length >= achievement.value;
                } else if (achievement.type === 'customTasks') {
                    return totalCustomTasksCompleted >= achievement.value;
                } else if (achievement.type === 'points') {
                    return zPoint >= achievement.value;
                }
                return false;
            });

            if (unlockedAchievements.length === 0) {
                noAchievementsMessage.style.display = 'block';
            } else {
                noAchievementsMessage.style.display = 'none';
                unlockedAchievements.forEach(achievement => {
                    const achievementItem = document.createElement('div');
                    // اعمال کلاس‌های حالت تاریک برای آیتم‌های دستاورد
                    achievementItem.className = `flex items-center bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-full px-4 py-2 shadow-sm text-gray-700 dark:text-gray-200 text-sm clickable-item`;
                    
                    // حذف توضیحات از نمایش صفحه اصلی
                    achievementItem.innerHTML = `
                        <span class="text-xl mr-2">${achievement.icon}</span>
                        <span>${achievement.name}</span>
                    `;
                    
                    // اضافه کردن شنونده کلیک برای نمایش جزئیات
                    achievementItem.addEventListener('click', () => showDetailModal(achievement.type, achievement.type === 'level' ? achievement.level : achievement.name));
                    
                    achievementsList.appendChild(achievementItem);
                });
            }
        }

        // افزودن وظیفه
        addTaskBtn.addEventListener('click', () => {
            const taskName = taskInput.value.trim();
            const importance = importanceSelect.value;
            let customPoints = 0;

            if (taskName.length === 0) {
                showMessageBox('لطفاً نام وظیفه را وارد کنید.', 'info');
                return;
            }

            if (taskName.length > 15) {
                showMessageBox('مقدار ورودی نباید بیش از 15 کاراکتر باشد.', 'error');
                return;
            }

            if (importance === 'custom') {
                // تبدیل اعداد فارسی به انگلیسی قبل از تجزیه
                const convertedPoints = convertPersianNumbersToEnglish(customPointsInput.value);
                customPoints = parseInt(convertedPoints, 10);
                if (isNaN(customPoints) || customPoints <= 0 || customPoints > MAX_CUSTOM_POINTS) {
                    showMessageBox(`لطفاً یک مقدار پوینت سفارشی معتبر (حداکثر ${MAX_CUSTOM_POINTS}) وارد کنید.`, 'info');
                    return;
                }
            }

            const newTask = {
                id: Date.now().toString(), // شناسه منحصر به فرد برای وظیفه
                name: taskName,
                completed: false,
                importance: importance,
                customPoints: importance === 'custom' ? customPoints : undefined, // ذخیره پوینت‌های سفارشی اگر اهمیت سفارشی باشد
                isPinned: false // ویژگی جدید برای پین کردن
            };
            tasks.push(newTask);
            taskInput.value = ''; // پاک کردن ورودی
            customPointsInput.value = ''; // پاک کردن ورودی پوینت‌های سفارشی
            importanceSelect.value = 'normal'; // بازنشانی انتخاب اهمیت
            customPointsInput.classList.add('hidden'); // پنهان کردن ورودی پوینت‌های سفارشی
            saveToLocalStorage(); // ذخیره پس از افزودن
            renderTasks(); // رندر مجدد وظایف پس از افزودن
            showMessageBox('وظیفه جدید با موفقیت اضافه شد!', 'success');
        });

        // تغییر وضعیت نمایش بخش وظایف تکمیل شده
        toggleCompletedTasksBtn.addEventListener('click', () => {
            completedTasksSection.classList.toggle('hidden');
            toggleIcon.classList.toggle('rotate-180'); // چرخش آیکون فلش
            // رندر مجدد کنترل‌های صفحه‌بندی برای به‌روزرسانی قابلیت مشاهده بر اساس وضعیت بخش
            renderPaginationControls(completedTasksPagination, tasks.filter(t => t.completed).length, completedCurrentPage, 'completed');
        });

        // مدیریت اقدامات وظیفه (تغییر وضعیت تکمیل، حذف، ویرایش، ذخیره، لغو)
        // هندلر اصلی برای کلیک‌ها روی آیتم‌های وظیفه
        // این تابع توسط touchend برای ضربه‌ها و مستقیماً توسط اقدامات منو فراخوانی می‌شود
        function handleTaskClick(e) {
            const taskItemElement = e.target.closest('.task-item');
            if (!taskItemElement) return;

            const taskId = taskItemElement.dataset.id;
            const target = e.target;

            // بررسی اینکه آیا کلیک روی یک عنصر فرزند تعاملی (چک‌باکس، دکمه منو) بوده است
            const isCheckbox = (target.tagName === 'INPUT' && target.type === 'checkbox');
            const isMenuButton = target.closest('.three-dot-menu-btn');
            const action = target.closest('button')?.dataset.action; // دریافت اکشن از دکمه منو

            if (isCheckbox) {
                // اگر چک‌باکس کلیک شد، وضعیت تکمیل را تغییر دهید
                toggleTaskCompletion(taskId, taskItemElement);
            } else if (isMenuButton) {
                // اگر دکمه منو کلیک شد، منوی اکشن را نمایش دهید
                const task = tasks.find(t => t.id === taskId);
                if (task) {
                    showTaskActionsMenu(taskId, isMenuButton, task.completed);
                }
            } else if (action === 'pin-task' || action === 'unpin-task') {
                pinTask(taskId);
            }
            else {
                // اگر خود کارت وظیفه (و نه یک فرزند تعاملی) کلیک شد، وضعیت تکمیل را تغییر دهید
                toggleTaskCompletion(taskId, taskItemElement);
            }
        }

        // اضافه کردن شنونده رویداد به activeTaskList و completedTasksContainer برای تفویض
        activeTaskList.addEventListener('click', handleTaskClick);
        completedTasksContainer.addEventListener('click', handleTaskClick);


        function toggleTaskCompletion(taskId, taskItemElement) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                const task = tasks[taskIndex];
                let pointsGained = 0;

                if (!task.completed) { // کاربر می‌خواهد وظیفه را تکمیل کند
                    task.completed = true;
                    task.isPinned = false; // وظیفه را هنگام تکمیل از پین خارج کنید
                    if (task.importance === 'important') {
                        pointsGained = pointsPerImportantTask;
                    } else if (task.importance === 'normal') {
                        pointsGained = pointsPerNormalTask;
                    } else if (task.importance === 'custom' && task.customPoints) {
                        pointsGained = task.customPoints;
                        totalCustomTasksCompleted++; // افزایش شمارنده وظایف سفارشی
                    }
                    zPoint += pointsGained;
                    showMessageBox('وظیفه تکمیل شد!', 'success');
                    showPointsGainFeedback(pointsGained, taskItemElement); // نمایش انیمیشن برای تمام وظایف تکمیل شده

                    // منطق زنجیره روزانه (فقط در زمان تکمیل)
                    const today = new Date().toDateString();

                    if (!lastCompletionDate) {
                        dailyStreak = 1;
                        showMessageBox('زنجیره روزانه شما آغاز شد!', 'info');
                    } else {
                        const lastDate = new Date(lastCompletionDate);
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);

                        if (lastDate.toDateString() === yesterday.toDateString()) {
                            dailyStreak++;
                            showMessageBox(`زنجیره: ${dailyStreak} روز متوالی!`, 'info');
                        } else if (lastDate.toDateString() !== today) {
                            dailyStreak = 1; // بازنشانی اگر متوالی نباشد و امروز قبلاً تکمیل نشده باشد
                            showMessageBox('زنجیره روزانه شما بازنشانی و مجدداً آغاز شد.', 'info');
                        }
                    }
                    lastCompletionDate = today;
                    highestDailyStreak = Math.max(highestDailyStreak, dailyStreak); // به‌روزرسانی بالاترین زنجیره

                    // مرتب‌سازی مجدد وظایف به طوری که تکمیل شده‌ها در انتها قرار گیرند
                    tasks.sort((a, b) => (a.completed === b.completed) ? 0 : a.completed ? 1 : -1);

                } else { // کاربر روی یک وظیفه تکمیل شده کلیک کرد، به این معنی که می‌خواهد یک نمونه فعال جدید ایجاد کند و نمونه تکمیل شده اصلی را حذف کند
                    // کسر پوینت برای وظیفه‌ای که "ناتمام" می‌شود (از لیست تکمیل شده حذف می‌شود)
                    let pointsDeducted = 0;
                    if (task.importance === 'important') {
                        pointsDeducted = pointsPerImportantTask;
                    } else if (task.importance === 'normal') {
                        pointsDeducted = pointsPerNormalTask;
                    } else if (task.importance === 'custom' && task.customPoints) {
                        pointsDeducted = task.customPoints;
                        totalCustomTasksCompleted--; // کاهش شمارنده وظایف سفارشی
                    }
                    zPoint -= pointsDeducted; // کسر پوینت
                    if (zPoint < 0) zPoint = 0; // اطمینان از منفی نشدن پوینت‌ها

                    // ایجاد یک وظیفه جدید بر اساس وظیفه تکمیل شده
                    const newActiveTask = {
                        id: Date.now().toString(), // شناسه منحصر به فرد جدید
                        name: task.name,
                        completed: false, // این نمونه جدید فعال است
                        importance: task.importance,
                        customPoints: task.customPoints,
                        isPinned: false // وظایف جدید به طور پیش‌فرض پین نمی‌شوند
                    };

                    tasks.push(newActiveTask); // اضافه کردن وظیفه فعال جدید به انتهای آرایه وظایف

                    // حالا، وظیفه تکمیل شده اصلی را از آرایه حذف کنید
                    tasks.splice(taskIndex, 1); // حذف وظیفه تکمیل شده اصلی

                    // کسر پوینت برای وظیفه اصلی وجود ندارد، زیرا آن به عنوان تکمیل شده باقی می‌ماند.
                    // تغییری در زنجیره روزانه برای این عملیات وجود ندارد.

                    showMessageBox(`وظیفه بازنشانی شد!`, 'success');
                }
                saveToLocalStorage();
                renderTasks();
            }
        }

        // تابع برای تغییر وضعیت پین شده یک وظیفه
        function pinTask(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                const task = tasks[taskIndex];
                task.isPinned = !task.isPinned; // تغییر وضعیت پین
                saveToLocalStorage();
                renderTasks();
                showMessageBox(`وظیفه "${task.name}" ${task.isPinned ? 'پین شد!' : 'از پین خارج شد.'}`, 'info');
            }
        }


        // تابع برای نمایش پاپ‌آپ منوی سه نقطه
        function showTaskActionsMenu(taskId, buttonElement, isCompletedTask) {
            // بستن هر منوی موجود
            document.querySelectorAll('.task-action-menu').forEach(menu => menu.remove());

            const menu = document.createElement('div');
            menu.className = 'task-action-menu';
            menu.style.position = 'absolute';
            menu.style.zIndex = '100';
            menu.style.visibility = 'hidden'; // در ابتدا برای گرفتن ابعاد پنهان شود

            document.body.appendChild(menu); // اضافه کردن به بدنه برای گرفتن عرض واقعی

            const task = tasks.find(t => t.id === taskId);
            let menuHtml = ``;
            if (isCompletedTask) {
                menuHtml = `
                    <button data-action="copy-task">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"></path></svg>
                        کپی
                    </button>
                    <button data-action="delete-task">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        حذف
                    </button>
                `;
            } else {
                menuHtml = `
                    <button data-action="edit-task">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                        ویرایش
                    </button>
                    <button data-action="change-order">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"></path></svg>
                        تغییر چیدمان
                    </button>
                    <button data-action="${task.isPinned ? 'unpin-task' : 'pin-task'}">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                            ${task.isPinned ?
                                '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14m-5 0l4 4m-4-4l-4 4m-4-4l4-4m-4-4l4 4"></path>' : // آیکون برداشتن پین
                                '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.828 0L6.343 16.657a4 4 0 115.656-5.656l1.414 1.414a1.998 1.998 0 002.828 0l1.414-1.414a4 4 0 115.656 5.656z"></path>' // آیکون پین
                            }
                        </svg>
                        ${task.isPinned ? 'برداشتن پین' : 'پین کردن'}
                    </button>
                    <button data-action="delete-task">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        حذف
                    </button>
                `;
            }
            menu.innerHTML = menuHtml;

            // موقعیت‌دهی پویا
            const rect = buttonElement.getBoundingClientRect();
            const padding = 5; // پدینگ کوچک از لبه‌های صفحه

            // محاسبه موقعیت اولیه بالا و چپ بر اساس موقعیت دکمه
            let menuTop = rect.bottom + window.scrollY + 5;
            let menuLeft = rect.left + window.scrollX;

            // تنظیم اگر منو از سمت راست صفحه خارج شود (در زمینه RTL، لبه راست مهم‌تر است)
            if (menuLeft + menu.offsetWidth > window.innerWidth - padding) {
                menuLeft = window.innerWidth - menu.offsetWidth - padding;
            }
            // تنظیم اگر منو از سمت چپ صفحه خارج شود
            if (menuLeft < padding) {
                menuLeft = padding;
            }

            // تنظیم اگر منو از پایین صفحه خارج شود
            if (menuTop + menu.offsetHeight > window.innerHeight + window.scrollY - padding) {
                menuTop = rect.top + window.scrollY - menu.offsetHeight - 5;
                if (menuTop < padding + window.scrollY) { // اگر هنوز از بالا خارج بود، در بالا با پدینگ قرار دهید
                    menuTop = padding + window.scrollY;
                }
            }

            menu.style.top = `${menuTop}px`;
            menu.style.left = `${menuLeft}px`;
            menu.style.visibility = 'visible'; // قابل مشاهده کردن

            // شنونده رویداد برای اقدامات منو
            menu.addEventListener('click', (e) => {
                const action = e.target.closest('button')?.dataset.action;
                if (action) {
                    menu.remove(); // بستن منو پس از اقدام
                    document.removeEventListener('click', closeMenu); // حذف شنونده سراسری
                    if (action === 'edit-task') {
                        showEditTaskModal(taskId);
                    } else if (action === 'change-order') {
                        showChangeOrderModal(taskId);
                    } else if (action === 'delete-task') {
                        deleteTask(taskId);
                    } else if (action === 'copy-task') {
                        copyTask(taskId);
                    } else if (action === 'pin-task' || action === 'unpin-task') {
                        pinTask(taskId);
                    }
                }
            });

            // بستن منو هنگام کلیک در خارج
            const closeMenu = (e) => {
                // بررسی اینکه آیا کلیک در خارج از منو و خارج از دکمه‌ای که آن را باز کرده بود، انجام شده است
                // همچنین بررسی کنید که آیا هدف کلیک یک عنصر تعاملی (input, select, button, checkbox) است
                // اگر یک عنصر تعاملی است، اجازه دهید اقدام پیش‌فرض آن ادامه یابد، اما همچنان منو را ببندید.
                const isInteractiveElement = e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.type === 'checkbox';

                if (!menu.contains(e.target) && !buttonElement.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            // اضافه کردن یک تأخیر کوچک برای اجازه رندر شدن منو قبل از اتصال شنونده کلیک سراسری
            // این کار از بسته شدن فوری منو توسط کلیک اولیه که آن را باز کرده بود، جلوگیری می‌کند.
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 50);
        }

        // تابع برای نمایش مودال ویرایش وظیفه
        function showEditTaskModal(taskId) {
            currentTaskBeingEditedId = taskId;
            const task = tasks.find(t => t.id === taskId);
            if (!task) {
                showMessageBox('خطا: وظیفه برای ویرایش یافت نشد.', 'error');
                return;
            }

            editTaskNameInput.value = task.name;
            editTaskNameInput.setAttribute('maxlength', '15'); // تنظیم حداکثر طول در اینجا
            editTaskImportanceSelect.value = task.importance;
            if (task.importance === 'custom') {
                editTaskCustomPointsInput.classList.remove('hidden');
                editTaskCustomPointsInput.value = task.customPoints || '';
                editTaskCustomPointsInput.focus(); // فوکوس خودکار هنگام انتخاب سفارشی
            } else {
                editTaskCustomPointsInput.classList.add('hidden');
                editTaskCustomPointsInput.value = ''; // پاک کردن مقدار در صورت پنهان بودن
            }

            // حذف هندلر onchange قبلی در صورت وجود
            editTaskImportanceSelect.onchange = null; 
            // اضافه کردن شنونده‌های رویداد جدید برای editTaskImportanceSelect
            editTaskImportanceSelect.addEventListener('change', handleEditTaskImportanceChange);
            editTaskImportanceSelect.addEventListener('blur', handleEditTaskImportanceBlur);
            
            editTaskModal.classList.remove('hidden'); // اطمینان از عدم پنهان بودن مودال قبل از نمایش
            void editTaskModal.offsetWidth; // اجبار به رندر مجدد
            editTaskModal.classList.add('show');
            editTaskNameInput.focus();
        }

        // هندلر برای رویداد تغییر editTaskImportanceSelect
        function handleEditTaskImportanceChange() {
            if (editTaskImportanceSelect.value === 'custom') {
                editTaskCustomPointsInput.classList.remove('hidden');
                editTaskCustomPointsInput.focus();
            } else {
                editTaskCustomPointsInput.classList.add('hidden');
                editTaskCustomPointsInput.value = '';
                // ذخیره خودکار وظیفه ویرایش شده اگر نام پر شده و اهمیت سفارشی نباشد
                if (editTaskNameInput.value.trim().length > 0) {
                    console.log('اهمیت ویرایش به غیر سفارشی تغییر یافت، تلاش برای ذخیره وظیفه.');
                    saveEditedTask(); // فراخوانی مستقیم تابع ذخیره
                }
            }
        }

        // هندلر برای رویداد blur editTaskImportanceSelect
        function handleEditTaskImportanceBlur() {
            // فقط در صورتی فعال شود که سفارشی نباشد و ورودی وظیفه محتوا داشته باشد
            if (editTaskImportanceSelect.value !== 'custom' && editTaskNameInput.value.trim().length > 0) {
                console.log('اهمیت ویرایش (غیر سفارشی) blur شد، تلاش برای ذخیره وظیفه.');
                saveEditedTask(); // فراخوانی مستقیم تابع ذخیره
            }
        }


        // ذخیره وظیفه ویرایش شده
        function saveEditedTask() {
            const taskId = currentTaskBeingEditedId;
            const newTaskName = editTaskNameInput.value.trim();
            const newImportance = editTaskImportanceSelect.value;
            let newCustomPoints = undefined;

            if (newTaskName.length === 0) {
                showMessageBox('نام وظیفه نمی‌تواند خالی باشد.', 'info');
                return;
            }

            if (newTaskName.length > 15) {
                showMessageBox('مقدار ورودی نباید بیش از 15 کاراکتر باشد.', 'error');
                return;
            }

            if (newImportance === 'custom') {
                // تبدیل اعداد فارسی به انگلیسی قبل از تجزیه
                const convertedPoints = convertPersianNumbersToEnglish(editTaskCustomPointsInput.value);
                newCustomPoints = parseInt(convertedPoints, 10);
                if (isNaN(newCustomPoints) || newCustomPoints <= 0 || newCustomPoints > MAX_CUSTOM_POINTS) {
                    showMessageBox(`لطفاً یک مقدار پوینت سفارشی معتبر (حداکثر ${MAX_CUSTOM_POINTS}) وارد کنید.`, 'info');
                    return;
                }
            }

            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                tasks[taskIndex].name = newTaskName;
                tasks[taskIndex].importance = newImportance;
                tasks[taskIndex].customPoints = newCustomPoints;
                saveToLocalStorage();
                renderTasks();
                showMessageBox('وظیفه با موفقیت ویرایش شد!', 'success');
                editTaskModal.classList.remove('show');
                setTimeout(() => { // اضافه کردن تأخیر برای پنهان شدن پس از انتقال
                    editTaskModal.classList.add('hidden');
                }, 50);
            } else {
                showMessageBox('خطا: وظیفه برای ویرایش یافت نشد.', 'error');
            }
        }

        saveEditedTaskBtn.addEventListener('click', saveEditedTask);


        // لغو ویرایش وظیفه
        cancelEditTaskBtn.addEventListener('click', () => {
            editTaskModal.classList.remove('show');
            setTimeout(() => { // اضافه کردن تأخیر برای پنهان شدن پس از انتقال
                editTaskModal.classList.add('hidden');
            }, 50);
            showMessageBox('ویرایش وظیفه لغو شد.', 'info');
        });

        // تابع برای نمایش مودال تغییر چیدمان
        function showChangeOrderModal(taskId) {
            currentTaskBeingEditedId = taskId;
            const activeTasks = tasks.filter(t => !t.completed);
            const taskIndex = activeTasks.findIndex(t => t.id === taskId);
            
            if (taskIndex === -1) {
                showMessageBox('امکان تغییر چیدمان وظایف تکمیل شده یا وظیفه یافت نشد.', 'error');
                return;
            }

            changeOrderInput.value = taskIndex + 1; // ایندکس بر اساس 1
            changeOrderModal.classList.remove('hidden'); // اطمینان از عدم پنهان بودن مودال قبل از نمایش
            void changeOrderModal.offsetWidth; // اجبار به رندر مجدد
            changeOrderModal.classList.add('show');
            changeOrderInput.focus();
            changeOrderInput.select(); // انتخاب خودکار متن
        }

        // ذخیره چیدمان تغییر یافته
        saveChangedOrderBtn.addEventListener('click', () => {
            // تبدیل اعداد فارسی به انگلیسی قبل از تجزیه
            const newPosition = parseInt(convertPersianNumbersToEnglish(changeOrderInput.value), 10);
            const taskId = currentTaskBeingEditedId;

            const taskIndexInTasks = tasks.findIndex(t => t.id === taskId);
            if (taskIndexInTasks === -1) {
                showMessageBox('خطا در تغییر چیدمان وظیفه. وظیفه یافت نشد.', 'error');
                return;
            }

            const taskToMove = tasks[taskIndexInTasks];

            // فقط اجازه تغییر چیدمان وظایف فعال را بدهید
            if (taskToMove.completed) {
                showMessageBox('امکان تغییر چیدمان وظایف تکمیل شده وجود ندارد.', 'info');
                return;
            }

            const activeTasks = tasks.filter(t => !t.completed);
            const taskInActiveTasksIndex = activeTasks.findIndex(t => t.id === taskId);

            if (isNaN(newPosition) || newPosition < 1 || newPosition > activeTasks.length) {
                showMessageBox(`لطفاً یک موقعیت معتبر بین 1 و ${activeTasks.length} وارد کنید.`, 'info');
                return;
            }

            if (taskInActiveTasksIndex > -1) {
                // حذف وظیفه از موقعیت فعلی آن در آرایه وظایف فعال
                const [movedTask] = activeTasks.splice(taskInActiveTasksIndex, 1);
                
                // درج وظیفه در موقعیت جدید مورد نظر در آرایه وظایف فعال
                activeTasks.splice(newPosition - 1, 0, movedTask);

                // اگر وظیفه پین شده بود، هنگام تغییر چیدمان دستی آن را از پین خارج کنید
                if (movedTask.isPinned) {
                    movedTask.isPinned = false;
                    showMessageBox('وظیفه به دلیل تغییر چیدمان دستی از پین خارج شد.', 'info');
                }

                // بازسازی آرایه اصلی وظایف برای منعکس کردن ترتیب جدید
                const completedTasks = tasks.filter(t => t.completed);
                tasks = [...activeTasks, ...completedTasks]; // وظایف فعال ابتدا، سپس تکمیل شده‌ها

                saveToLocalStorage();
                renderTasks();
                showMessageBox('چیدمان وظیفه با موفقیت تغییر یافت!', 'success');
                changeOrderModal.classList.remove('show');
                setTimeout(() => { // اضافه کردن تأخیر برای پنهان شدن پس از انتقال
                    changeOrderModal.classList.add('hidden');
                }, 50);
            } else {
                showMessageBox('خطا در تغییر چیدمان وظیفه. وظیفه یافت نشد یا قبلاً تکمیل شده است.', 'error');
            }
        });

        // لغو تغییر چیدمان
        cancelChangeOrderBtn.addEventListener('click', () => {
            changeOrderModal.classList.remove('show');
            setTimeout(() => { // اضافه کردن تأخیر برای پنهان شدن پس از انتقال
                changeOrderModal.classList.add('hidden');
            }, 50);
            showMessageBox('تغییر چیدمان لغو شد.', 'info');
        });

        // تابع برای حذف وظیفه (فراخوانی شده از منو)
        function deleteTask(taskId) {
            const taskIndex = tasks.findIndex(t => t.id === taskId);
            if (taskIndex > -1) {
                const taskItemElement = document.querySelector(`.task-item[data-id="${taskId}"]`);
                const taskToDelete = tasks[taskIndex];
                taskToDelete.isPinned = false; // وظیفه را هنگام حذف از پین خارج کنید

                // ایجاد یک کپی از وظیفه با ایندکس اصلی آن برای بازگردانی
                const deletedTaskCopy = { ...taskToDelete, originalIndex: taskIndex };

                tasks.splice(taskIndex, 1); // حذف وظیفه
                saveToLocalStorage();

                // انیمیشن حذف
                if (taskItemElement) {
                    taskItemElement.style.transform = `translateX(-100vw)`;
                    taskItemElement.style.opacity = '0';
                    taskItemElement.addEventListener('transitionend', () => {
                        renderTasks(); // رندر مجدد پس از انیمیشن
                        // استفاده از showMessageBox برای پیام بازگردانی
                        showMessageBox(`وظیفه "${deletedTaskCopy.name}" حذف شد. برای بازگردانی ضربه بزنید.`, 'info', {
                            position: 'bottom-center',
                            isUndo: true,
                            duration: 5000,
                            taskData: deletedTaskCopy // ارسال داده‌های وظیفه خاص برای بازگردانی
                        });
                    }, { once: true });
                } else {
                    // اگر عنصر یافت نشد، همچنان از داده‌ها حذف و رندر مجدد کنید
                    renderTasks();
                    showMessageBox(`وظیفه "${deletedTaskCopy.name}" حذف شد. برای بازگردانی ضربه بزنید.`, 'info', {
                        position: 'bottom-center',
                        isUndo: true,
                        duration: 5000,
                        taskData: deletedTaskCopy // ارسال داده‌های وظیفه خاص برای بازگردانی
                    });
                }
            } else {
                showMessageBox('خطا: وظیفه برای حذف یافت نشد.', 'error');
            }
        }

        // تابع برای کپی وظیفه (برای وظایف تکمیل شده)
        function copyTask(taskId) {
            const originalTask = tasks.find(t => t.id === taskId);
            if (originalTask) {
                const newTask = {
                    id: Date.now().toString(), // شناسه منحصر به فرد جدید
                    name: originalTask.name,
                    completed: false, // همیشه فعال
                    importance: originalTask.importance,
                    customPoints: originalTask.customPoints, // حفظ پوینت‌های سفارشی اصلی
                    isPinned: false // وظیفه جدید به طور پیش‌فرض پین نمی‌شود
                };
                tasks.push(newTask); // اضافه کردن به انتهای لیست
                saveToLocalStorage();
                renderTasks();
                showMessageBox(`وظیفه "${newTask.name}" به وظایف فعال کپی شد!`, 'success');
            } else {
                showMessageBox('خطا: وظیفه اصلی برای کپی یافت نشد.', 'error');
            }
        }

        // --- منطق کشیدن و رها کردن (رویدادهای ماوس) ---
        activeTaskList.addEventListener('dragstart', (e) => {
            const taskItem = e.target.closest('.task-item');
            // اطمینان حاصل کنید که فقط وظایف فعال قابل کشیدن هستند و از کشیدن وظایف تکمیل شده جلوگیری کنید
            if (taskItem && !taskItem.classList.contains('bg-green-100')) { 
                draggedTaskId = taskItem.dataset.id;
                draggedElement = taskItem;
                e.dataTransfer.setData('text/plain', draggedTaskId);
                e.dataTransfer.effectAllowed = 'move';
                setTimeout(() => {
                    taskItem.classList.add('opacity-0'); // پنهان کردن عنصر اصلی در حین کشیدن
                }, 0);
            } else {
                e.preventDefault(); // جلوگیری از کشیدن اگر وظیفه فعال نیست
            }
        });

        activeTaskList.addEventListener('dragover', (e) => {
            e.preventDefault(); // اجازه رها کردن
            e.dataTransfer.dropEffect = 'move';
            const targetItem = e.target.closest('.task-item');

            // پاک کردن تمام هایلایت‌های drop-target موجود
            document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));

            // فقط در صورتی هایلایت کنید که روی یک وظیفه فعال رها شود و نه خود وظیفه‌ای که در حال کشیدن است
            if (targetItem && targetItem.dataset.id !== draggedTaskId && !targetItem.classList.contains('bg-green-100')) {
                const boundingBox = targetItem.getBoundingClientRect();
                const offset = e.clientY - boundingBox.top;

                if (offset < boundingBox.height / 2) {
                    targetItem.classList.add('drop-target'); // نشان دادن رها کردن در بالا
                } else {
                    // هایلایت کردن عنصر فعال بعدی اگر در پایین رها شود، یا خود هدف اگر آخرین باشد
                    let nextActiveTask = null;
                    let current = targetItem.nextElementSibling;
                    while (current) {
                        if (current.classList.contains('task-item') && !current.classList.contains('bg-green-100')) {
                            nextActiveTask = current;
                            break;
                        }
                        current = current.nextElementSibling;
                    }

                    if (nextActiveTask) {
                        nextActiveTask.classList.add('drop-target');
                    } else {
                        targetItem.classList.add('drop-target'); // اگر هیچ آیتم فعال دیگری در پایین وجود ندارد، خود هدف را هایلایت کنید
                    }
                }
            }
        });

        activeTaskList.addEventListener('dragleave', (e) => {
            // حذف drop-target از تمام عناصر هنگام ترک کشیدن
            document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
        });

        activeTaskList.addEventListener('drop', (e) => {
            e.preventDefault();
            const dropTargetItem = e.target.closest('.task-item');
            
            // پاکسازی بازخورد بصری
            document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
            if (draggedElement) {
                draggedElement.classList.remove('opacity-0'); // نمایش مجدد عنصر اصلی
            }

            if (!dropTargetItem || !draggedTaskId) {
                showMessageBox('هدف رها کردن نامعتبر است یا وظیفه‌ای در حال کشیدن نیست.', 'error');
                resetDragState();
                return;
            }

            const droppedOnTaskId = dropTargetItem.dataset.id;
            const draggedTaskIndex = tasks.findIndex(t => t.id === draggedTaskId);
            const droppedOnTaskIndex = tasks.findIndex(t => t.id === droppedOnTaskId);

            if (draggedTaskIndex === -1 || droppedOnTaskIndex === -1 || draggedTaskId === droppedOnTaskId) {
                // کشیدن نامعتبر یا رها کردن روی خود
                showMessageBox('امکان رها کردن وظیفه در اینجا وجود ندارد.', 'error');
                resetDragState();
                return;
            }

            // اطمینان حاصل کنید که فقط وظایف فعال را مرتب می‌کنیم
            if (tasks[draggedTaskIndex].completed || tasks[droppedOnTaskIndex].completed) {
                showMessageBox('فقط وظایف فعال را می‌توان مرتب کرد.', 'info');
                resetDragState();
                return;
            }

            // دریافت وظایف فعال برای انجام مرتب‌سازی در آن زیرمجموعه
            const activeTasks = tasks.filter(task => !task.completed);
            const draggedActiveIndex = activeTasks.findIndex(t => t.id === draggedTaskId);
            const droppedActiveIndex = activeTasks.findIndex(t => t.id === droppedOnTaskId);

            if (draggedActiveIndex === -1 || droppedActiveIndex === -1) {
                 // این نباید اتفاق بیفتد اگر بررسی‌های بالا صحیح باشند، اما به عنوان یک محافظ
                showMessageBox('خطا در یافتن وظایف فعال برای مرتب‌سازی.', 'error');
                resetDragState();
                return;
            }

            const [draggedTask] = activeTasks.splice(draggedActiveIndex, 1);
            let newActiveIndex = droppedActiveIndex;

            // تنظیم ایندکس بر اساس موقعیت رها کردن (بالا یا پایین)
            const boundingBox = dropTargetItem.getBoundingClientRect();
            const offset = e.clientY - boundingBox.top;
            if (offset > boundingBox.height / 2) {
                newActiveIndex++; // رها شده در پایین هدف
            }

            activeTasks.splice(newActiveIndex, 0, draggedTask);

            // اگر وظیفه پین شده بود، هنگام مرتب‌سازی دستی آن را از پین خارج کنید
            if (draggedTask.isPinned) {
                draggedTask.isPinned = false;
                showMessageBox('وظیفه به دلیل تغییر چیدمان دستی از پین خارج شد.', 'info');
            }

            // بازسازی آرایه اصلی وظایف
            const completedTasks = tasks.filter(t => t.completed);
            tasks = [...activeTasks, ...completedTasks];

            saveToLocalStorage();
            renderTasks(); // رندر مجدد برای نمایش ترتیب جدید
            showMessageBox('چیدمان وظیفه با موفقیت تغییر یافت!', 'success');
            resetDragState();
        });

        activeTaskList.addEventListener('dragend', (e) => {
            // پاکسازی کلاس‌های کشیدن بدون توجه به موفقیت رها کردن
            if (draggedElement) {
                draggedElement.classList.remove('opacity-0');
            }
            document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
            resetDragState();
        });

        function resetDragState() {
            draggedTaskId = null;
            draggedElement = null;
        }

        // --- منطق کشیدن و رها کردن (رویدادهای لمسی) ---
        activeTaskList.addEventListener('touchstart', (e) => {
            const taskItem = e.target.closest('.task-item');
            if (!taskItem) return;

            const targetTagName = e.target.tagName;
            const isInteractiveChild = (targetTagName === 'INPUT' && (e.target.type === 'checkbox' || e.target.type === 'number' || e.target.type === 'text')) ||
                                       targetTagName === 'BUTTON' ||
                                       targetTagName === 'SELECT' ||
                                       e.target.closest('.three-dot-menu-btn');

            if (isInteractiveChild) {
                resetTouchStates(); // اطمینان از پاک بودن وضعیت‌ها حتی اگر کشیدن شروع نشود
                return; // اجازه دهید رفتار بومی آن (مثلاً کلیک چک‌باکس، کلیک دکمه منو) آن را مدیریت کند
            }

            if (e.touches.length === 1) {
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
                touchCurrentX = touchStartX;
                touchCurrentY = touchStartY;

                const boundingBox = taskItem.getBoundingClientRect();
                initialTouchOffsetX = e.touches[0].clientX - boundingBox.left;
                initialTouchOffsetY = e.touches[0].clientY - boundingBox.top;

                resetTouchStates(); // اطمینان از پاک بودن تمام وضعیت‌ها قبل از شروع یک حرکت جدید
                isGestureStarted = true;

                // فقط در صورتی تایمر نگه داشتن طولانی را شروع کنید که وظیفه فعال باشد (قابل کشیدن)
                if (!taskItem.classList.contains('bg-green-100')) {
                    longPressTimer = setTimeout(() => {
                        isLongPressDetected = true;
                        isDragging = true;
                        draggedTaskId = taskItem.dataset.id;
                        draggedElement = taskItem;

                        // ایجاد عنصر شبح و پنهان کردن اصلی
                        ghostElement = taskItem.cloneNode(true);
                        ghostElement.style.position = 'fixed';
                        ghostElement.style.width = boundingBox.width + 'px';
                        ghostElement.style.height = boundingBox.height + 'px';
                        ghostElement.style.pointerEvents = 'none';
                        ghostElement.style.opacity = '0.7';
                        ghostElement.style.zIndex = '1000';
                        ghostElement.classList.add('dragging');
                        document.body.appendChild(ghostElement);

                        ghostElement.style.left = (touchStartX - initialTouchOffsetX) + 'px';
                        ghostElement.style.top = (touchStartY - initialTouchOffsetY) + 'px';
                        ghostElement.style.transform = 'none'; // پاک کردن هرگونه تبدیل قبلی

                        taskItem.classList.add('opacity-0'); // پنهان کردن عنصر اصلی
                        // جلوگیری از رفتار پیش‌فرض لمس (مانند اسکرول یا ضربه) پس از تأیید کشیدن
                        e.preventDefault(); // جلوگیری از اسکرول بلافاصله پس از فعال شدن نگه داشتن طولانی
                    }, DRAG_LONG_PRESS_TIME);
                }
            }
        }, { passive: false }); // استفاده از passive: false برای اجازه e.preventDefault() در touchstart/touchmove

        activeTaskList.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            touchCurrentX = touch.clientX;
            touchCurrentY = touch.clientY;

            const deltaX = touchCurrentX - touchStartX;
            const deltaY = touchCurrentY - touchStartY;

            const absDeltaX = Math.abs(deltaX);
            const absDeltaY = Math.abs(deltaY);

            // اگر یک حرکت شروع شد و حرکت قابل توجهی قبل از نگه داشتن طولانی وجود داشت، تایمر نگه داشتن طولانی را پاک کنید
            if (isGestureStarted && !isLongPressDetected && (absDeltaX > TAP_THRESHOLD || absDeltaY > TAP_THRESHOLD)) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
                isGestureStarted = false; // این یک اسکرول است، نه تلاش برای ضربه یا کشیدن
                // اجازه اسکرول بومی را بدهید، در اینجا از پیش‌فرض جلوگیری نکنید
                return; 
            }

            // اگر کشیدن رسماً شروع شده باشد (نگه داشتن طولانی تشخیص داده شده باشد)
            if (isDragging) {
                e.preventDefault(); // جلوگیری از اسکرول و سایر رفتارهای پیش‌فرض
                if (ghostElement) {
                    ghostElement.style.left = (touchCurrentX - initialTouchOffsetX) + 'px';
                    ghostElement.style.top = (touchCurrentY - initialTouchOffsetY) + 'px';

                    // منطق برای هایلایت drop-target
                    // به طور موقت شبح را پنهان کنید تا عنصر زیر آن را دریافت کنید
                    ghostElement.style.display = 'none';
                    const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                    ghostElement.style.display = 'block';

                    document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target'));
                    let closestTaskItem = elementUnderTouch ? elementUnderTouch.closest('.task-item') : null;

                    if (closestTaskItem && closestTaskItem.dataset.id !== draggedTaskId && !closestTaskItem.classList.contains('bg-green-100')) {
                        const boundingBox = closestTaskItem.getBoundingClientRect();
                        const offset = touch.clientY - boundingBox.top;

                        if (offset < boundingBox.height / 2) {
                            closestTaskItem.classList.add('drop-target');
                        } else {
                            let nextActiveTask = null;
                            let current = closestTaskItem.nextElementSibling;
                            while (current) {
                                if (current.classList.contains('task-item') && !current.classList.contains('bg-green-100')) {
                                    nextActiveTask = current;
                                    break;
                                }
                                current = current.nextElementSibling;
                            }
                            if (nextActiveTask) {
                                nextActiveTask.classList.add('drop-target');
                            } else {
                                closestTaskItem.classList.add('drop-target');
                            }
                        }
                    }
                }
            }
        }, { passive: false }); // استفاده از passive: false برای اجازه e.preventDefault()

        activeTaskList.addEventListener('touchend', (e) => {
            clearTimeout(longPressTimer);
            longPressTimer = null;

            if (draggedElement) {
                draggedElement.classList.remove('opacity-0'); // نمایش مجدد عنصر اصلی
            }
            if (ghostElement) {
                ghostElement.remove(); // حذف عنصر شبح
            }
            document.querySelectorAll('.drop-target').forEach(el => el.classList.remove('drop-target')); // پاک کردن هایلایت drop target

            const absDeltaX = Math.abs(touchCurrentX - touchStartX);
            const absDeltaY = Math.abs(touchCurrentY - touchStartY);

            if (isDragging) { // اگر عملیات کشیدن در حال انجام بود
                const elementAtEnd = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
                const dropTargetItem = elementAtEnd ? elementAtEnd.closest('.task-item') : null;

                const originalDraggedTaskIndex = tasks.findIndex(t => t.id === draggedTaskId);
                const draggedTask = tasks[originalDraggedTaskIndex];

                if (!dropTargetItem || draggedTask.completed) {
                    // اگر خارج از یک هدف معتبر یا روی یک وظیفه تکمیل شده رها شد، بازگردانی کنید
                    renderTasks(); // رندر مجدد برای بازگرداندن تغییرات بصری
                    showMessageBox('تغییر چیدمان وظیفه لغو شد.', 'info');
                } else if (dropTargetItem.dataset.id === draggedTaskId) {
                    // رها شده روی خود، بدون تغییر
                    renderTasks();
                } else {
                    // تکرار منطق رها کردن ماوس برای لمس
                    const activeTasks = tasks.filter(task => !task.completed);
                    const draggedActiveIndex = activeTasks.findIndex(t => t.id === draggedTaskId);
                    const droppedActiveIndex = activeTasks.findIndex(t => t.id === dropTargetItem.dataset.id);

                    if (draggedActiveIndex === -1 || droppedActiveIndex === -1) {
                        showMessageBox('خطا در یافتن وظایف فعال برای تغییر چیدمان (لمس).', 'error');
                        renderTasks();
                        resetTouchStates();
                        return;
                    }

                    const [movedTask] = activeTasks.splice(draggedActiveIndex, 1);
                    let newActiveIndex = droppedActiveIndex;

                    const boundingBox = dropTargetItem.getBoundingClientRect();
                    const offset = e.changedTouches[0].clientY - boundingBox.top;
                    if (offset > boundingBox.height / 2) {
                        newActiveIndex++; // رها شده در پایین هدف
                    }
                    activeTasks.splice(newActiveIndex, 0, movedTask);

                    // اگر وظیفه پین شده بود، هنگام تغییر چیدمان دستی با کشیدن/رها کردن آن را از پین خارج کنید
                    if (movedTask.isPinned) {
                        movedTask.isPinned = false;
                        showMessageBox('وظیفه به دلیل تغییر چیدمان دستی از پین خارج شد.', 'info');
                    }

                    // بازسازی آرایه اصلی وظایف
                    const completedTasks = tasks.filter(t => t.completed);
                    tasks = [...activeTasks, ...completedTasks];

                    saveToLocalStorage();
                    renderTasks();
                    showMessageBox('چیدمان وظیفه با موفقیت تغییر یافت!', 'success');
                }
            } else if (isGestureStarted && absDeltaX < TAP_THRESHOLD && absDeltaY < TAP_THRESHOLD) {
                // این یک ضربه خالص بود (نه کشیدن یا سوایپ، و حداقل حرکت)
                handleTaskClick(e); // شبیه‌سازی کلیک برای ضربه
            }

            // بازنشانی تمام پرچم‌ها و تبدیل‌های عنصر
            resetTouchStates();
            // اطمینان از بازنشانی بصری موقعیت آیتم وظیفه اگر توسط touchstart/touchmove جابجا شده بود
            const taskItem = e.target.closest('.task-item');
            if (taskItem) {
                taskItem.style.transform = 'translateX(0)';
            }
        });

        // برای وظایف تکمیل شده، فقط اجازه ضربه زدن برای تغییر وضعیت تکمیل را بدهید
        completedTasksContainer.addEventListener('touchstart', (e) => {
            const taskItem = e.target.closest('.task-item');
            if (!taskItem) return;

            const targetTagName = e.target.tagName;
            const isInteractiveChild = (targetTagName === 'INPUT' && (e.target.type === 'checkbox' || e.target.type === 'number' || e.target.type === 'text')) ||
                                       targetTagName === 'BUTTON' ||
                                       targetTagName === 'SELECT' ||
                                       e.target.closest('.three-dot-menu-btn');

            if (isInteractiveChild) {
                resetTouchStates(); // اطمینان از پاک بودن وضعیت‌ها حتی اگر کشیدن شروع نشود
                return; // اجازه دهید رفتار بومی آن را مدیریت کند
            }

            // در اینجا e.preventDefault() وجود ندارد تا اجازه اسکرول برای وظایف تکمیل شده داده شود
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchCurrentX = touchStartX;
            touchCurrentY = touchStartY;
            isGestureStarted = true;
        });

        completedTasksContainer.addEventListener('touchmove', (e) => {
            touchCurrentX = e.touches[0].clientX;
            touchCurrentY = e.touches[0].clientY;
            const absDeltaX = Math.abs(touchCurrentX - touchStartX);
            const absDeltaY = Math.abs(touchCurrentY - touchStartY);

            // اگر حرکت قابل توجهی وجود داشت، این یک ضربه نیست
            if (absDeltaX > TAP_THRESHOLD || absDeltaY > TAP_THRESHOLD) {
                isGestureStarted = false; // ضربه نیست
            }
        });

        completedTasksContainer.addEventListener('touchend', (e) => {
            const taskItem = e.target.closest('.task-item');
            if (!taskItem) {
                resetTouchStates(); // اگر لمس در خارج از یک آیتم وظیفه به پایان رسید، بازنشانی کنید
                return;
            }

            const absDeltaX = Math.abs(touchCurrentX - touchStartX);
            const absDeltaY = Math.abs(touchCurrentY - touchStartY);

            if (isGestureStarted && absDeltaX < TAP_THRESHOLD && absDeltaY < TAP_THRESHOLD) {
                handleTaskClick(e); // شبیه‌سازی کلیک برای ضربه
            }
            resetTouchStates(); // بازنشانی برای حرکت بعدی
        });

        // تابع کمکی برای بازنشانی تمام وضعیت‌های مرتبط با لمس
        function resetTouchStates() {
            isDragging = false;
            isGestureStarted = false;
            isLongPressDetected = false;
            draggedTaskId = null;
            draggedElement = null;
            if (ghostElement) {
                ghostElement.remove();
                ghostElement = null;
            }
            touchStartX = 0;
            touchStartY = 0;
            touchCurrentX = 0;
            touchCurrentY = 0;
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }

        // تابع برای بازگردانی یک حذف خاص
        function undoLastDeletion(taskToRestore) {
            if (taskToRestore) {
                // یافتن موقعیت صحیح برای درج مجدد وظیفه
                // اگر originalIndex معتبر و در محدوده باشد، سعی کنید در آنجا درج کنید.
                // در غیر این صورت، به انتهای وظایف فعال اضافه کنید.
                let insertIndex = tasks.length; // پیش‌فرض به انتها
                if (taskToRestore.originalIndex !== undefined && taskToRestore.originalIndex <= tasks.length) {
                    insertIndex = taskToRestore.originalIndex;
                }

                // اطمینان حاصل کنید که وظیفه قبلاً وجود ندارد (مثلاً اگر بازگردانی دو بار سریع کلیک شد)
                if (!tasks.some(t => t.id === taskToRestore.id)) {
                    tasks.splice(insertIndex, 0, taskToRestore);
                    saveToLocalStorage();
                    renderTasks();
                    showMessageBox(`وظیفه "${taskToRestore.name}" بازگردانی شد.`, 'info');
                } else {
                    console.warn(`وظیفه با شناسه ${taskToRestore.id} قبلاً وجود دارد، مجدداً اضافه نمی‌شود.`);
                }
            }
        }


        // --- منطق تغییر تم ---
        function applyTheme(theme) {
            const htmlElement = document.documentElement;
            if (theme === 'dark') {
                htmlElement.classList.add('dark');
                // آیکون ماه برای حالت تاریک
                themeIcon.innerHTML = `<path d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>`;
            } else {
                htmlElement.classList.remove('dark');
                // آیکون خورشید برای حالت روشن
                themeIcon.innerHTML = `<path d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.325 6.675l-.707-.707M6.318 6.318l-.707-.707m12.728 0l-.707.707M6.318 17.682l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>`;
            }
            // اعمال مجدد تم سطح پس از تغییر کلی حالت روشن/تاریک
            applyLevelTheme(level);
        }

        // مقداردهی اولیه تم در زمان بارگذاری و گوش دادن به تغییرات تم سیستم
        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) {
                applyTheme(savedTheme);
            } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                applyTheme('dark');
            } else { // Corrected from 'سپس' to 'else'
                applyTheme('light');
            }

            // گوش دادن به تغییرات در طرح رنگ ترجیحی سیستم
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                const newSystemTheme = e.matches ? 'dark' : 'light';
                // همیشه تم سیستم را اعمال کنید اگر تم خاصی توسط کاربر ذخیره نشده باشد
                applyTheme(newSystemTheme);
            });
        }

        // --- منطق منو و مودال ---
        menuBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // جلوگیری از انتشار کلیک به پنجره و بسته شدن دراپ‌داون
            menuDropdown.classList.toggle('hidden');
        });

        // بستن دراپ‌داون هنگام کلیک در خارج
        window.addEventListener('click', (e) => {
            // بررسی اینکه آیا هدف کلیک در داخل دکمه منو یا خود دراپ‌داون است
            const isClickInsideMenu = menuBtn.contains(e.target) || menuDropdown.contains(e.target);
            // بررسی اینکه آیا هدف کلیک یک عنصر تعاملی خارج از منو/دکمه است (مثلاً یک چک‌باکس دیگر، دکمه)
            const isInteractiveElement = e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.type === 'checkbox';

            // بستن منو اگر کلیک خارج از منو و دکمه آن باشد،
            // و اگر کلیک روی یک عنصر تعاملی دیگر نباشد که باید اجازه عملکرد داشته باشد.
            // اگر یک عنصر تعاملی است، ما همچنان می‌خواهیم منو بسته شود، اما اقدام عنصر ادامه یابد.
            if (!isClickInsideMenu) {
                menuDropdown.classList.add('hidden');
            }
        });


        profileMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // پنهان کردن دراپ‌داون

            // نمایش مودال پروفایل با انیمیشن
            profileModal.classList.remove('hidden');
            void profileModalContent.offsetWidth; // اجبار به رندر مجدد
            profileModalContent.classList.remove('opacity-0', 'scale-95');
            profileModalContent.classList.add('opacity-100', 'scale-100');

            const totalTasks = tasks.length;
            const completedTasksCount = tasks.filter(t => t.completed).length;

            let achievementsHtml = '';
            const unlockedAchievements = achievementsData.filter(achievement => {
                if (achievement.type === 'level') {
                    const levelInfo = levelPointsThresholds.find(l => l.name === achievement.name);
                    return levelInfo && zPoint >= levelInfo.points;
                } else if (achievement.type === 'streak') {
                    return dailyStreak >= achievement.value;
                } else if (achievement.type === 'totalTasks') {
                    return completedTasksCount >= achievement.value;
                } else if (achievement.type === 'importantTasks') {
                    return tasks.filter(t => t.completed && t.importance === 'important').length >= achievement.value;
                } else if (achievement.type === 'customTasks') {
                    return totalCustomTasksCompleted >= achievement.value;
                } else if (achievement.type === 'points') {
                    return zPoint >= achievement.value;
                }
                return false;
            });

            if (unlockedAchievements.length > 0) {
                achievementsHtml = `
                    <h4 class="text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2 mt-4">دستاوردها:</h4>
                    <div class="flex flex-wrap gap-2">
                        ${unlockedAchievements.map(ach => `
                            <span class="flex items-center bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-1 rounded-full text-sm clickable-item" data-type="${ach.type}" data-id="${ach.type === 'level' ? ach.level : ach.name}">
                                <span class="text-xl mr-2">${ach.icon}</span><span>${ach.name}</span>
                            </span>
                        `).join('')}
                    </div>
                `;
            } else {
                achievementsHtml = `<p class="text-gray-500 dark:text-gray-400 mt-4">هنوز دستاوردی کسب نشده است.</p>`;
            }

            // بدنه مودال پروفایل بازطراحی شده
            profileModalBody.innerHTML = `
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 mb-4">
                    <div class="p-3 rounded-lg shadow-sm bg-blue-50 dark:bg-blue-900 text-blue-800 dark:text-blue-200 flex items-center justify-between">
                        <span class="font-semibold">نام کاربری:</span>
                        <span>${userName || 'ناشناس'}</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-green-50 dark:bg-green-900 text-green-800 dark:text-green-200 flex items-center justify-between">
                        <span class="font-semibold">کل وظایف:</span>
                        <span>${totalTasks}</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-teal-50 dark:bg-teal-900 text-teal-800 dark:text-teal-200 flex items-center justify-between">
                        <span class="font-semibold">وظایف تکمیل شده:</span>
                        <span>${completedTasksCount}</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-yellow-50 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 flex items-center justify-between">
                        <span class="font-semibold">تعداد پوینت:</span>
                        <span>${zPoint}</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-purple-50 dark:bg-purple-900 text-purple-800 dark:text-purple-200 flex items-center justify-between">
                        <span class="font-semibold">سطح:</span>
                        <span>${level}</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-orange-50 dark:bg-orange-900 text-orange-800 dark:text-orange-200 flex items-center justify-between">
                        <span class="font-semibold">زنجیره:</span>
                        <span>${dailyStreak} روز</span>
                    </div>
                    <div class="p-3 rounded-lg shadow-sm bg-pink-50 dark:bg-pink-900 text-pink-800 dark:text-pink-200 flex items-center justify-between">
                        <span class="font-semibold">بیشترین زنجیره:</span>
                        <span>${highestDailyStreak} روز</span>
                    </div>
                </div>
                ${achievementsHtml}
            `;

            // اضافه کردن شنونده رویداد به آیتم‌های قابل کلیک تازه ایجاد شده در مودال پروفایل
            profileModalBody.querySelectorAll('.clickable-item').forEach(item => {
                item.addEventListener('click', (event) => {
                    const type = event.currentTarget.dataset.type;
                    const id = event.currentTarget.dataset.id;
                    const name = event.currentTarget.dataset.id; // تصحیح شد تا از data-id برای نام استفاده شود
                    if (type === 'level') {
                        showDetailModal('level', id);
                    } else {
                        showDetailModal(type, name);
                    }
                });
            });
        });

        closeProfileModalBtn.addEventListener('click', () => {
            profileModalContent.classList.remove('opacity-100', 'scale-100');
            profileModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                profileModal.classList.add('hidden');
            }, 50);
        });

        helpMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // پنهان کردن دراپ‌داون

            // نمایش مودال راهنما با انیمیشن
            helpModal.classList.remove('hidden');
            void helpModalContent.offsetWidth; // اجبار به رندر مجدد
            helpModalContent.classList.remove('opacity-0', 'scale-95');
            helpModalContent.classList.add('opacity-100', 'scale-100');

            // به‌روزرسانی پویا محتوای مودال راهنما با مقادیر پوینت فعلی
            helpModalBody.innerHTML = `
                <h3 class="text-xl sm:text-2xl font-bold mb-2 text-gray-600 dark:text-gray-300">به زی تسک خوش آمدید!</h3>
                <p class="mb-3 text-gray-700 dark:text-gray-300">این برنامه به شما کمک می‌کند تا وظایف خود را مدیریت کنید، پوینت کسب کنید، سطح خود را ارتقا دهید و از طریق گیمیفیکیشن به نقاط عطف مختلفی دست یابید.</p>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-gray-600 dark:text-gray-300">نحوه استفاده از برنامه</h3>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">افزودن وظیفه:</strong> نام وظیفه را وارد کرده و اهمیت آن (مهم/عادی/سفارشی) را انتخاب کنید. وظایف مهم و سفارشی پوینت بیشتری به شما می‌دهند.</p>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">تغییر ترتیب وظایف:</strong> می‌توانید وظایف فعال را با کشیدن و رها کردن مرتب کنید.</p>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">تکمیل وظیفه:</strong> برای تکمیل یک وظیفه، کادر کنار آن را علامت بزنید. این به شما پوینت می‌دهد و وظیفه را به بخش "وظایف تکمیل شده" منتقل می‌کند.</p>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">ویرایش وظیفه:</strong> برای ویرایش نام و اهمیت یک وظیفه، روی آیکون سه نقطه کنار آن کلیک کرده و "ویرایش" را انتخاب کنید یا روی خود وظیفه کلیک کنید.</p>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">حذف وظیفه:</strong> برای حذف یک وظیفه، روی آیکون سه نقطه کنار آن کلیک کرده و "حذف" را انتخاب کنید.</p>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">تغییر ترتیب دستی:</strong> برای تغییر دستی موقعیت یک وظیفه، روی آیکون سه نقطه کنار آن کلیک کرده و "تغییر ترتیب" را انتخاب کنید.</p>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">وظایف تکمیل شده:</strong> روی دکمه کلیک کنید تا وظایف تکمیل شده خود را نمایش یا پنهان کنید.</p>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-gray-600 dark:text-gray-300">سیستم گیمیفیکیشن</h3>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">پوینت:</strong>
                    پوینت‌ها صرفاً نمادین هستند و برای اندازه‌گیری پیشرفت و فعالیت شما در برنامه استفاده می‌شوند.
                    <ul>
                        <li>وظایف عادی: ${pointsPerNormalTask} پوینت</li>
                        <li>وظایف مهم: ${pointsPerImportantTask} پوینت</li>
                        <li>وظایف سفارشی: تا ${MAX_CUSTOM_POINTS} پوینت</li>
                    </ul>
                </p>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">زنجیره روزانه:</strong> تکمیل حداقل یک وظیفه در روزهای متوالی، زنجیره روزانه شما را افزایش می‌دهد و به شما امکان می‌دهد دستاوردهای ویژه‌ای کسب کنید.</p>
                
                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-gray-600 dark:text-gray-300">سطوح</h3>
                <p class="mb-2 text-gray-700 dark:text-gray-300">با کسب پوینت، به سطوح بالاتر صعود خواهید کرد. برای جزئیات بیشتر روی یک سطح کلیک کنید:</p>
                <div class="flex flex-wrap gap-2 mb-3">
                    ${levelPointsThresholds.map((levelInfo, index) => {
                        return `
                            <span class="bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-1 rounded-full text-sm flex items-center clickable-item" data-type="level" data-id="${index + 1}">
                                سطح ${index + 1}: ${levelInfo.name}
                            </span>
                        `;
                    }).join('')}
                </div>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-gray-600 dark:text-gray-300">دستاوردها</h3>
                <p class="mb-2 text-gray-700 dark:text-gray-300">با پیشرفت در بازی، دستاوردهای مختلفی کسب خواهید کرد. برای جزئیات بیشتر روی یک دستاورد کلیک کنید:</p>
                <div class="flex flex-wrap gap-2 mb-3">
                    ${achievementsData.map(ach => {
                        // فقط دستاوردهای غیر سطحی را در اینجا لیست کنید
                        if (ach.type !== 'level') {
                            return `<span class="bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-1 rounded-full text-sm flex items-center clickable-item" data-type="achievement" data-name="${ach.name}">${ach.icon} <span class="mr-1">${ach.name}</span></span>`;
                        }
                        return '';
                    }).join('')}
                </div>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-gray-600 dark:text-gray-300">پشتیبان‌گیری و بازیابی داده‌ها</h3>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">امنیت داده‌ها:</strong> تمام داده‌های شما به صورت امن در حافظه محلی مرورگر شما ذخیره می‌شوند و هیچ اطلاعاتی به هیچ سروری ارسال نمی‌شود.</p>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">پشتیبان‌گیری (خروجی گرفتن):</strong> می‌توانید با کلیک بر روی دکمه "ذخیره داده‌ها"، یک فایل پشتیبان JSON از تمام داده‌های برنامه خود دانلود کنید. این فایل را در مکانی امن نگهداری کنید.</p>
                <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">بازیابی (ورودی گرفتن):</strong> برای بازیابی داده‌ها، به سادگی فایل پشتیبان JSON را که قبلاً دانلود کرده‌اید از طریق بخش "انتخاب فایل" انتخاب کنید، سپس روی دکمه "بارگذاری از فایل" کلیک کنید. این کار داده‌های فعلی برنامه شما را با داده‌های موجود در فایل جایگزین می‌کند.</p>

                <h3 class="text-xl sm:text-2xl font-bold mb-2 mt-4 text-gray-600 dark:text-gray-300">حمایت مالی</h3>
                <p class="mb-2 text-gray-700 dark:text-gray-300">این بخش در حال حاضر غیرفعال است. از علاقه شما سپاسگزاریم!</p>

                <p class="mt-4 text-center text-gray-700 dark:text-gray-300">هدف این برنامه ایجاد انگیزه و کمک به سازماندهی بهتر وظایف شماست. موفق باشید!</p>
            `;
            // اضافه کردن شنونده رویداد به آیتم‌های قابل کلیک تازه ایجاد شده در مودال راهنما
            helpModalBody.querySelectorAll('.clickable-item').forEach(item => {
                item.addEventListener('click', (event) => {
                    const type = event.currentTarget.dataset.type;
                    const id = event.currentTarget.dataset.id;
                    const name = event.currentTarget.dataset.name;
                    if (type === 'level') {
                        showDetailModal('level', id);
                    } else {
                        showDetailModal(type, name);
                    }
                });
            });
        });

        closeHelpModalBtn.addEventListener('click', () => {
            helpModalContent.classList.remove('opacity-100', 'scale-100');
            helpModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                helpModal.classList.add('hidden');
            }, 50);
        });

        aboutMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // پنهان کردن دراپ‌داون

            // نمایش مودال درباره ما با انیمیشن
            aboutModal.classList.remove('hidden');
            void aboutModalContent.offsetWidth; // اجبار به رندر مجدد
            aboutModalContent.classList.remove('opacity-0', 'scale-95');
            aboutModalContent.classList.add('opacity-100', 'scale-100');

            aboutModalBody.innerHTML = `
                <p class="mb-3">این برنامه به منظور مدیریت وظایف و افزایش انگیزه طراحی شده است.</p>
                <p class="mb-3">این پروژه به صورت اختصاصی توسط <strong class="text-gray-600 dark:text-gray-300"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">سایت عمو لئو</a></strong> طراحی شده است. این نسخه، اولین و آخرین نسخه از این پروژه است.</p>
                <p class="mb-3">تمامی حقوق متعلق به <strong class="text-gray-600 dark:text-gray-300"><a href="https://amuleo.ir" target="_blank" rel="noopener noreferrer">عمو لئو</a></strong> است.</p>
                <p class="mb-3">تاریخ: ۴ خرداد ۱۴۰۴</p>
            `;
        });

        closeAboutModalBtn.addEventListener('click', () => {
            aboutModalContent.classList.remove('opacity-100', 'scale-100');
            aboutModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                aboutModal.classList.add('hidden');
            }, 50);
        });

        backupMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // پنهان کردن دراپ‌داون

            // نمایش مودال پشتیبان‌گیری با انیمیشن
            backupModal.classList.remove('hidden');
            void backupModalContent.offsetWidth; // اجبار به رندر مجدد
            backupModalContent.classList.remove('opacity-0', 'scale-95');
            backupModalContent.classList.add('opacity-100', 'scale-100');

            importFileInput.value = ''; // پاک کردن ورودی فایل در زمان باز شدن
            selectedFileNameSpan.textContent = 'فایلی انتخاب نشده است.';
        });

        // اضافه کردن شنونده برای دکمه بستن مودال پشتیبان‌گیری
        closeBackupModalBtn.addEventListener('click', () => {
            backupModalContent.classList.remove('opacity-100', 'scale-95');
            backupModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                backupModal.classList.add('hidden');
            }, 50);
        });

        donateMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            showMessageBox('این بخش در حال حاضر غیرفعال است. از علاقه شما سپاسگزاریم!', 'info');
            menuDropdown.classList.add('hidden'); // پنهان کردن دراپ‌داون پس از انتخاب
        });

        resetMenuItem.addEventListener('click', (e) => {
            e.preventDefault();
            menuDropdown.classList.add('hidden'); // پنهان کردن دراپ‌داون

            // نمایش مودال تأیید بازنشانی با انیمیشن
            resetConfirmModal.classList.remove('hidden');
            void resetConfirmModalContent.offsetWidth; // اجبار به رندر مجدد
            resetConfirmModalContent.classList.remove('opacity-0', 'scale-95');
            resetConfirmModalContent.classList.add('opacity-100', 'scale-100');
        });

        confirmResetBtn.addEventListener('click', () => {
            localStorage.clear(); // پاک کردن تمام داده‌ها از حافظه محلی
            location.reload(); // بارگذاری مجدد صفحه برای بازنشانی برنامه
        });

        cancelResetBtn.addEventListener('click', () => {
            resetConfirmModalContent.classList.remove('opacity-100', 'scale-100');
            resetConfirmModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                resetConfirmModal.classList.add('hidden');
            }, 50);
        });

        closeResetModalBtn.addEventListener('click', () => {
            resetConfirmModalContent.classList.remove('opacity-100', 'scale-100');
            resetConfirmModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                resetConfirmModal.classList.add('hidden');
            }, 50);
        });

        // منطق مودال خوش‌آمدگویی
        startBtn.addEventListener('click', () => {
            const inputName = userNameInput.value.trim();
            if (inputName.length === 0) {
                showMessageBox('لطفاً نام خود را وارد کنید.', 'info');
                return;
            }
            if (inputName.length > 15) {
                showMessageBox('مقدار ورودی نباید بیش از 15 کاراکتر باشد.', 'error');
                return;
            }

            userName = inputName;
            saveToLocalStorage();
            welcomeModalContent.classList.remove('opacity-100', 'scale-100');
            welcomeModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                welcomeModal.classList.add('hidden');
            }, 50);
            showMessageBox(`${userName}، خوش آمدید!`, 'success');
        });

        // خروجی گرفتن داده‌ها (دانلود به عنوان فایل)
        exportDataBtn.addEventListener('click', () => {
            const dataToSave = {
                tasks: tasks,
                zPoint: zPoint,
                level: level,
                dailyStreak: dailyStreak,
                highestDailyStreak: highestDailyStreak, // شامل بالاترین زنجیره در خروجی
                lastCompletionDate: lastCompletionDate,
                totalCustomTasksCompleted: totalCustomTasksCompleted,
                userName: userName
            };
            const jsonString = JSON.stringify(dataToSave, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            const date = new Date();
            const dateString = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
            a.download = `tasks_backup_${dateString}_zitask.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url); // پاکسازی شیء URL
            showMessageBox('فایل پشتیبان با موفقیت دانلود شد!', 'success');
        });

        // به‌روزرسانی نمایش نام فایل انتخاب شده
        importFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                selectedFileNameSpan.textContent = e.target.files[0].name;
            } else {
                selectedFileNameSpan.textContent = 'فایلی انتخاب نشده است.';
            }
        });

        // ورودی گرفتن داده‌ها (بارگذاری از فایل)
        importDataBtn.addEventListener('click', () => {
            const file = importFileInput.files[0];
            if (!file) {
                showMessageBox('لطفاً یک فایل پشتیبان برای بارگذاری انتخاب کنید.', 'info');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const dataString = e.target.result;
                    const importedData = JSON.parse(dataString);

                    // اعتبارسنجی اولیه ساختار داده وارد شده
                    if (
                        typeof importedData.tasks === 'object' && Array.isArray(importedData.tasks) &&
                        typeof importedData.zPoint === 'number' &&
                        typeof importedData.level === 'number' &&
                        typeof importedData.dailyStreak === 'number' &&
                        (typeof importedData.highestDailyStreak === 'number' || typeof importedData.highestDailyStreak === 'undefined') && // اعتبارسنجی بالاترین زنجیره
                        (typeof importedData.lastCompletionDate === 'string' || importedData.lastCompletionDate === null) &&
                        typeof importedData.totalCustomTasksCompleted === 'number' &&
                        (typeof importedData.userName === 'string' || importedData.userName === null || importedData.userName === undefined)
                    ) {
                        tasks = importedData.tasks;
                        zPoint = importedData.zPoint;
                        level = importedData.level;
                        dailyStreak = importedData.dailyStreak;
                        highestDailyStreak = importedData.highestDailyStreak || 0; // تنظیم بالاترین زنجیره، پیش‌فرض 0 اگر تعریف نشده باشد
                        lastCompletionDate = importedData.lastCompletionDate;
                        totalCustomTasksCompleted = importedData.totalCustomTasksCompleted;
                        userName = importedData.userName || null; // اطمینان از تنظیم userName یا null

                        // اطمینان حاصل کنید که وظایف وارد شده ویژگی 'isPinned' جدید را دارند
                        tasks.forEach(task => {
                            if (typeof task.isPinned === 'undefined') {
                                task.isPinned = false;
                            }
                        });

                        saveToLocalStorage(); // ذخیره داده‌های وارد شده در حافظه محلی
                        renderTasks(); // رندر مجدد رابط کاربری با داده‌های جدید
                        
                        // پنهان کردن مودال پشتیبان‌گیری با انیمیشن
                        backupModalContent.classList.remove('opacity-100', 'scale-95');
                        backupModalContent.classList.add('opacity-0', 'scale-95');
                        setTimeout(() => {
                            backupModal.classList.add('hidden');
                        }, 50);
                        showMessageBox('داده‌ها با موفقیت بارگذاری شد!', 'success');
                    } else {
                        showMessageBox('فرمت داده وارد شده نامعتبر است. لطفاً یک فایل پشتیبان معتبر را وارد کنید.', 'error');
                    }
                } catch (error) {
                    console.error("خطا در تجزیه داده وارد شده:", error);
                    showMessageBox('خطا در پردازش فایل وارد شده. اطمینان حاصل کنید که یک فایل JSON صحیح است.', 'error');
                }
            };
            reader.onerror = (e) => {
                console.error("خطا در خواندن فایل:", e);
                showMessageBox('خطا در خواندن فایل. لطفاً دوباره امتحان کنید.', 'error');
            };
            reader.readAsText(file);
        });

        // --- منطق مودال جزئیات سطح/دستاورد ---
        function showDetailModal(type, identifier) {
            detailModal.classList.remove('hidden');
            void detailModalContent.offsetWidth; // اجبار به رندر مجدد
            // اضافه کردن کلاس‌های انیمیشن برای ورود مودال
            detailModalContent.classList.remove('opacity-0', 'scale-95');
            detailModalContent.classList.add('opacity-100', 'scale-100');

            let contentHtml = '';
            let titleText = ''; 

            if (type === 'level') {
                const levelNum = parseInt(identifier, 10);
                const levelInfo = levelPointsThresholds[levelNum - 1];
                
                titleText = levelInfo.name;

                contentHtml = `
                    <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">توضیحات:</strong> برای رسیدن به این سطح، شما به ${levelInfo.points} پوینت نیاز دارید.</p>
                `;
            } else { // این بلوک else اکنون تمام انواع غیر سطحی مانند 'totalTasks', 'importantTasks' و غیره را پوشش می‌دهد.
                const achievement = achievementsData.find(ach => ach.name === identifier);
                
                if (achievement) {
                    titleText = achievement.name;
                    contentHtml = `
                        <p class="mb-2"><strong class="text-gray-600 dark:text-gray-300">توضیحات:</strong> ${achievement.description || 'توضیحات در دسترس نیست.'}</p>
                    `;
                } else {
                    titleText = `خطا`;
                    contentHtml = `<p class="text-red-500">دستاورد یافت نشد.</p>`;
                }
            }

            detailModalTitle.textContent = titleText;
            detailModalBody.innerHTML = contentHtml;
        }

        closeDetailModalBtn.addEventListener('click', () => {
            detailModalContent.classList.remove('opacity-100', 'scale-100');
            detailModalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => {
                detailModal.classList.add('hidden');
            }, 50);
        });

        // اضافه کردن شنونده کلیک برای نمایش سطح فعلی در صفحه اصلی
        currentLevelDisplay.addEventListener('click', () => showDetailModal('level', level));


        // --- منطق کلید Enter (مدیریت خودکار حذف شد) ---
        // شنونده سراسری keydown برای کلید Enter (فقط برای دکمه‌های مودال خاص)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                const activeElement = document.activeElement;

                // 1. مودال خوش‌آمدگویی (فقط برای userNameInput)
                if (welcomeModal.classList.contains('show') || !welcomeModal.classList.contains('hidden')) {
                    if (activeElement === userNameInput) {
                        e.preventDefault(); // جلوگیری از رفتار پیش‌فرض Enter (مثلاً خط جدید در textarea)
                        return;
                    }
                }

                // 2. بخش افزودن وظیفه (فقط برای customPointsInput)
                if (addTaskSection.contains(activeElement)) {
                    // اگر customPointsInput فوکوس شده است
                    if (activeElement === customPointsInput) {
                        e.preventDefault();
                        return;
                    }
                }

                // 3. مودال ویرایش وظیفه (فقط برای customPointsInput)
                if (editTaskModal.classList.contains('show') || !editTaskModal.classList.contains('hidden')) {
                    if (editTaskModalContent.contains(activeElement)) {
                        // اگر editTaskCustomPointsInput فوکوس شده است
                        if (activeElement === editTaskCustomPointsInput) {
                            e.preventDefault();
                            return;
                        }
                    }
                }

                // 4. مودال تغییر چیدمان (فقط برای changeOrderInput)
                if (changeOrderModal.classList.contains('show') || !changeOrderModal.classList.contains('hidden')) {
                    if (activeElement === changeOrderInput) {
                        e.preventDefault();
                        return;
                    }
                }
            }
        });

        // شنونده رویداد برای importanceSelect برای نمایش/پنهان کردن ورودی پوینت‌های سفارشی
        importanceSelect.addEventListener('change', () => {
            if (importanceSelect.value === 'custom') {
                customPointsInput.classList.remove('hidden');
                customPointsInput.focus();
            } else {
                customPointsInput.classList.add('hidden');
                customPointsInput.value = ''; // پاک کردن مقدار در صورت پنهان بودن
            }
        });

        // بارگذاری داده‌ها از حافظه محلی و مقداردهی اولیه تم در زمان بارگذاری پنجره
        window.onload = () => {
            loadFromLocalStorage();
            initializeTheme();

            // نمایش مودال خوش‌آمدگویی اگر نام کاربر تنظیم نشده باشد
            if (!userName) {
                welcomeModal.classList.remove('hidden');
                void welcomeModalContent.offsetWidth; // اجبار به رندر مجدد
                welcomeModalContent.classList.remove('opacity-0', 'scale-95'); // اطمینان از شروع انیمیشن
                welcomeModalContent.classList.add('opacity-100', 'scale-100');
                userNameInput.focus();
            }
        };
    </script>
</body>
</html>
